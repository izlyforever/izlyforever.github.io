

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="izlyforever">
  <meta name="keywords" content="math, cpp, python, sagemath">
  
    <meta name="description" content="跟同事 WZ 讨论了一些 C++ 特征之后，觉得 C++17 并没有掌握的那么好，于是重新去翻了一遍 《C++17 入门经典》第五版（这书确实太入门了，已经将《Effienct Modern C++》放进 ToDo 列表，已看完，看的时候书中内容基本之前都了解），多学学 ANSI C 和 C99(多了 for 中定义，双杠注释，变长数组（无意义），复数)，不优先学 C11（你都用 C11 了干嘛不">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 学习笔记">
<meta property="og:url" content="http://izlyforever.com/learnCpp/index.html">
<meta property="og:site_name" content="记录程序和数学的点滴">
<meta property="og:description" content="跟同事 WZ 讨论了一些 C++ 特征之后，觉得 C++17 并没有掌握的那么好，于是重新去翻了一遍 《C++17 入门经典》第五版（这书确实太入门了，已经将《Effienct Modern C++》放进 ToDo 列表，已看完，看的时候书中内容基本之前都了解），多学学 ANSI C 和 C99(多了 for 中定义，双杠注释，变长数组（无意义），复数)，不优先学 C11（你都用 C11 了干嘛不">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-07-17T17:00:02.000Z">
<meta property="article:modified_time" content="2022-06-25T09:14:02.545Z">
<meta property="article:author" content="izlyforever">
<meta property="article:tag" content="note">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>C++ 学习笔记 - 记录程序和数学的点滴</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"izlyforever.com","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>izlyforever</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/cppTemplate/">
                <i class="iconfont icon-book"></i>
                cpp
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/webTools/">
                <i class="iconfont icon-briefcase"></i>
                网页工具
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ 学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-07-18 01:00" pubdate>
          2020年7月18日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          139 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++ 学习笔记</h1>
            
              <p class="note note-info">
                
                  
                    <!-- compatible with older versions-->
                    最后更新于：2022年6月25日 下午
                  
                
              </p>
            
            <div class="markdown-body">
              
              <p>跟同事 WZ 讨论了一些 C++ 特征之后，觉得 C++17 并没有掌握的那么好，于是重新去翻了一遍 《C++17 入门经典》第五版（这书确实太入门了，已经将《Effienct Modern C++》放进 ToDo 列表，已看完，看的时候书中内容基本之前都了解），多学学 ANSI C 和 C99(多了 for 中定义，双杠注释，变长数组（无意义），复数)，不优先学 C11（你都用 C11 了干嘛不用 C++），除非你要做多线程然后只能用 C，这有意义吗？ C99 也可以用 pthread 搞呀</p>
<blockquote>
<p>没有必要关心你自己不用的特征！但是用的就一定要搞清楚。</p>
</blockquote>
<p>等到 Codeforces 支持 <code>C++20</code> 后开始学习 <code>C++2x</code>，十分期待 C++23 和 C++26。 <del>我猜应该等到 C++23 出来之后 Codeforces 才会添加 C++2x</del>（<a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/96040">已出</a> 但是没有学的动力，静等 C++23 网络库的加入）。</p>
<span id="more"></span>
<blockquote>
<p>后来我知道语言能做到跨平台是因为语言或者标准库帮你用类似宏的方式做了，没有的部分我们也可以手动做</p>
</blockquote>
<h2 id="文件拓展名只是约定其实文件名想怎么取都行">文件拓展名（只是约定，其实文件名想怎么取都行）</h2>
<ul>
<li><code>.h</code>: C/C++ 头文件</li>
<li><code>.hpp</code>: 有模板的带实现的 C++ 的头文件</li>
<li><code>.c</code>, <code>cpp</code>: 分别是 C, C++ 实现文件</li>
<li><code>.cc</code>: 既可以用是 c 也可以是 c++ 的混合实现文件</li>
<li><code>.m</code>: objective-C 的实现文件</li>
<li><code>.mm</code>: objective-C 和 C++ 的混合实现文件</li>
</ul>
<blockquote>
<p>C 是面向机器编程，C++ 是面向编译器编程</p>
</blockquote>
<h2 id="头文件原则">头文件原则</h2>
<p>以前我以为应该让头文件包含越少越好，甚至要用工具来简化所有多余的头文件，这是十分错误的做法</p>
<p>正确的做法：自身的头文件不应该依赖包含的头文件，你要啥就 include 啥，不要的就不 include，能放在 <code>.cpp</code> 就不要放在 <code>.h</code>。这样看上去更合理，并且你包含的头文件修改时，自己不必修改</p>
<h2 id="c-之坑总结">C++ 之坑总结</h2>
<p>了解一门语言的痛点，比了解一门语言的优势更为重要 ### <code>std::vector&lt;bool&gt;</code> 并不是 bool 的数组</p>
<p>避免使用 <code>vector&lt;bool&gt;</code>，推荐使用 <code>bitset&lt;N&gt;</code></p>
<p>（更省内存，O2 优化后特别快！，但是注意不能开特别大的局部变量，太大就开全局变量，注意 bitset 是从后往前记的） 简单的说就是它并未实际保存一个 <code>bool</code>, 而是用位域的概念进行了封装</p>
<p>所以你在实际应用的时候可能会发生一些你意料之外的问题</p>
<h3 id="整型提升">整型提升</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">uint16_t</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> c = a - b <span class="hljs-comment">// c 的类型竟然是 int</span><br></code></pre></td></tr></table></figure>
<h3 id="vector-引用">vector 引用</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; a&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;&#125;;<br><span class="hljs-keyword">auto</span> &amp;b = a[<span class="hljs-number">1</span>];<br>a.<span class="hljs-built_in">emplace_back</span>(std::vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;<span class="hljs-number">6</span>&#125;); <span class="hljs-comment">// no copy here</span><br>std::cout &lt;&lt; b.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// b.size() = 0</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>用引用的时候要相当小心</p>
</blockquote>
<h3 id="常引用的值可以改变">常引用的值可以改变</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;y = x; <span class="hljs-comment">// 只是说 y 指向的值不能由 y 来变罢了</span><br>x = <span class="hljs-number">3</span>; <span class="hljs-comment">// 此时 y 的值也改变了</span><br>std::cout &lt;&lt; y &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>当然这就可以给出：单例的神仙用法，具体见 poly 中的用法</p>
</blockquote>
<h3 id="c-类型的数组并不会做安全的检测">C 类型的数组并不会做安全的检测</h3>
<p>这其实也是取舍问题，如果做了检测，必然会带了性能的降低。只是 C 更想要性能，然后安全检测可以交给应用程序，或者其他包装的库，例如 <code>std::array</code>, <code>std::vector</code></p>
<h2 id="编辑器编译器ide">编辑器/编译器/IDE</h2>
<p>VScode 查看代码管理代码还是特别好的，但是 debug 还是选择各个平台对应的 IDE 较好，特别是 Xcode 除了 debug 还有一些性能工具真的难用的一 p， VS 也是！</p>
<h3 id="vscode">VScode</h3>
<ul>
<li>一定要去掉 use ignore Files 一定要关闭，否则很容易查找不到东西</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/w5688414/article/details/118561289">visual studio code (Error: Handler already set!)</a>，但是本质上是插件冲突导致的，插件尽量少装，不要重复装各种插件</li>
</ul>
<h3 id="xcode">Xcode</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/BX_Jobs/article/details/50404404">xcode中的方法command+左键不能进行索引跳转的解决方法</a></li>
</ul>
<h2 id="数值范围">数值范围</h2>
<p><code>double</code> 会出现大数吃小数（这个涉及 double 的二进制表达，加减的时候要向大的数对齐），一旦超过了 <code>DBL_MAX</code>，那就变成 <code>inf</code>，<code>inf</code> 的运算规则跟数学的一致。<code>inf - inf = nan</code> 跟 <code>1/0 = nan</code> 一致都是未定义数。（他们都有自己特殊的二进制表示，且 nan == nan 返回值为 false）</p>
<p><code>INT_MAX</code>, <code>INT64_MAX</code>, <code>DBL_MAX</code> 等都是常见的常数，当然也可以用 <code>std::numeric_limits&lt;T&gt;::max()</code> 或 <code>std::numeric_limits&lt;T&gt;::min()</code></p>
<h2 id="引用">引用</h2>
<h3 id="指针-vs-引用">指针 VS 引用</h3>
<p>引用安全不用管回收，应该尽量使用引用</p>
<p>指针是一个非常重要的东西，它可以做四则运算相当灵活，而且有空指针却没有空引用</p>
<h3 id="void-shared_ptrvoid-stdany"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gnivor/p/12793239.html"><code>void*</code>, <code>shared_ptr&lt;void&gt;</code>, <code>std::any</code></a></h3>
<ul>
<li><code>void*</code> 可以理解为单位长度为 0 的指针</li>
<li>库无法复制 <code>void*</code> 指向的对象，因为不知道类型</li>
<li><code>shared_ptr</code> 能释放内存，但是依然解决不了上面的类型安全问题</li>
<li>C++17 才有的 any 有一说一相当牛，可看 C++ reference 的实例</li>
</ul>
<h3 id="指向-const-的指针-p-const-指针-q-和-指向-const-的-const-指针-pq">指向 const 的指针 p, const 指针 q 和 指向 const 的 const 指针 pq</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p &#123;&amp;i&#125;;<br>*p = &amp;j;<br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> q &#123;&amp;k&#125;;<br>*q = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> pq&#123;&amp;j&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="stdref-和-stdcref"><code>std::ref</code> 和 <code>std::cref</code></h3>
<p>这两个在多线程中尤为重要</p>
<h3 id="左值右值右值引用">左值，右值，右值引用</h3>
<ul>
<li>单个变量的表达式必然是左值，用户返回的引用表达式也是左值，不是左值的表达值就是右值。</li>
<li>右值引用可以延长右值的生命周期，但是它出现的作用是为了减少 copy 操作，如果你没有这个需求完全不用理会这个概念。</li>
<li><code>std::move</code> 是将左值转换成右值引用，<code>std::forward</code> 则是原封不动的保持数据的类型（这是因为一个右值引用放在表达式的右边还是一个左值，要想它保持右值，就可以用 <code>std::forward</code></li>
<li>右值引用就是引用，它可以修改对应的值，可以转移所有权限</li>
<li><code>std::move</code> 和 <code>std::forward</code> 在运行期都不做任何事情</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cerr(x) std::cerr &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;&amp; a_;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">A</span>(std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;&amp;a) : <span class="hljs-built_in">a_</span>(std::forward&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(a)) &#123;<br>    a_.<span class="hljs-built_in">pop_back</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a_.<span class="hljs-built_in">size</span>();<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 根据情况换成 bool</span><br><span class="hljs-function">A <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; x&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>  <span class="hljs-function">A <span class="hljs-title">y</span><span class="hljs-params">(std::move(x))</span></span>;<br>  <span class="hljs-built_in">cerr</span>(y.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-built_in">cerr</span>(x.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// x 因为 y 而改变了</span><br>  x.<span class="hljs-built_in">pop_back</span>();<br>  <span class="hljs-built_in">cerr</span>(y.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// y 也因为 x 改变了</span><br>  <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-built_in">cerr</span>(xxx);<br>  <span class="hljs-keyword">int</span> cas = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// std::cin &gt;&gt; cas; // 根据情况注释掉</span><br>  <span class="hljs-keyword">while</span> (cas--) &#123;<br>    <span class="hljs-keyword">auto</span> z = <span class="hljs-built_in">solve</span>(); <span class="hljs-comment">// 随着 solve() 中 x 被释放 y.a 也跟着消失了</span><br>    <span class="hljs-built_in">cerr</span>(z.<span class="hljs-built_in">size</span>());   <span class="hljs-comment">// 答案为非合理值</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/guxuanqing/p/6594857.html" class="uri">https://www.cnblogs.com/guxuanqing/p/6594857.html</a>(以及我在此篇的评论)</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。</p>
<p>但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为"万能引用"）。</p>
<p>在函数模板中:</p>
<p>当实参为左值或者左值引用（A&amp;）时， T&amp;&amp; 将转变为 A&amp;（A&amp; &amp;&amp; = A&amp;）； 当实参为右值或者右值引用（A&amp;&amp;）时，T&amp;&amp; 将转变为 A&amp;&amp;（A&amp;&amp; &amp;&amp; = A&amp;&amp;）。 在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</p>
<blockquote>
<p>此时使用 <code>std::forward&lt;T&gt;</code> 就相当有价值了，以上部分来自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lvwx369/article/details/118405626" class="uri">https://blog.csdn.net/lvwx369/article/details/118405626</a></p>
</blockquote>
<h3 id="可变参数">可变参数</h3>
<p>新版本：关于 可选参数 即参数带默认值（本质是添加一个函数，且是非 virtual 的！）</p>
<ol type="1">
<li>接口一般不推荐带可选参数，这是因为接口可选参数，那么所有实现都要有可选参数(否则实现类无法单独使用默认参数)，要小心不同参数可能参数不一致，此时是特别危险的，因为编译器添加的函数是非 virtual 的。</li>
<li>接口无可选参数，实现带可选参数，可行不推荐，因为不够优雅且应用不广泛：我们一般用接口的指针搞，缺失参数将会无法通过编译</li>
<li>如果可选参数是指针，默认参数是 nullptr 也可以让接口是可选参数，也不是不行</li>
</ol>
<p>添加缺省参数的步骤 1. 直接添加参数，解决编译问题（让编译器帮助自己，防止遗漏自己想要改的内容） 2. 把默认值加上，使用默认值的回退不用修改</p>
<h3 id="weak_ptr">weak_ptr</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> sharedPtr = weakptr_.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (!sharedPtr) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure>
<p>确实是一个优雅的做法！这样如果这个 ptr 无效了那就啥也不做，当前有效就让它在这个区域一直有效！</p>
<h3 id="模版类型萃取">模版类型萃取</h3>
<p>模版添加了功能，但是有时我们的模版仅对一些特定类型正确，此时类型萃取提前告知用户这是错误的用法，确实不错</p>
<h3 id="链接错误总结">链接错误（总结）</h3>
<ul>
<li>类中有 static 变量，但没有 inline</li>
<li>多线程中有 static 变量，没有再类外面申明一下</li>
<li>编译的时候 symbol 有两个</li>
</ul>
<h3 id="参数传入">参数传入</h3>
<p><code>void f(D x)</code>, <code>void f(const D &amp;x)</code> 都可以接受全部参数类型（这是历史原因），但是两个不能同时出现！但是纯左值，纯右值的方式，就是根据自己的需要组合（不想说的太细，很繁琐）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> &#123;</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> a;<br>  <span class="hljs-built_in">D</span>() &#123;a = <span class="hljs-number">0</span>; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>  ~<span class="hljs-built_in">D</span>() &#123;<br>    ++cnt;<br>  &#125;<br>  D <span class="hljs-keyword">operator</span>+() &#123;<br>    <span class="hljs-function">D <span class="hljs-title">y</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>    ++y.a;<br>    <span class="hljs-keyword">return</span> y;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(D x)</span> </span>&#123;<br>  x.<span class="hljs-built_in">print</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;f(D x)&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>  &#123; <span class="hljs-comment">// complie error</span><br>    D x;<br>    x.a = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">f</span>(x);<br>    <span class="hljs-built_in">cerr</span>(D::cnt);<br>    <span class="hljs-built_in">f</span>(std::<span class="hljs-built_in">move</span>(x));  <span class="hljs-comment">// 这里为什么不被优化呢？</span><br>    <span class="hljs-built_in">cerr</span>(D::cnt);<br>    <span class="hljs-built_in">f</span>(+x);           <span class="hljs-comment">//</span><br>    <span class="hljs-built_in">cerr</span>(D::cnt);<br>    <span class="hljs-built_in">f</span>(<span class="hljs-built_in">D</span>());<br>    <span class="hljs-built_in">cerr</span>(D::cnt);<br>  &#125;<br>  <span class="hljs-built_in">cerr</span>(D::cnt);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实这本质就是一个需求问题，C++11 之前，你有时想穿进常引用，但是有时传入的是一个临时值，这都可以满足条件，但是如果你想传一个非临时的值，但是它在内部又回被修改，但你知道之后不会用它你应该怎么办？右值引用就是来解决这个问题的</p>
<h2 id="c-类">C++ 类</h2>
<p>权限问题，public, protected, private 要根据需求来。</p>
<p>其实 private 的变量是最让人喜欢的，因为它一来防止了别人瞎搞，二来如果你有代码修改，那么只用关心类中的更改，但是你要修改一个 public 的那问题就大了，特别是如果你这个是给别人提供 API，那这个就更不可能修改了</p>
<h3 id="类的构造函数">类的构造函数</h3>
<p>用 <code>Node(const int &amp;A)</code> 这种写法可以自动进行转化。但是又多个时候也要写反推回去的版本。</p>
<p>类用同类初始化和类等号运算符有本质的区别（虽然他们很多时候行为一致）</p>
<blockquote>
<p>从 C++11 之后类构造函数可以设置默认值</p>
</blockquote>
<p>有时我们不想<code>隐式类型转换</code>带来不可预期的问题，可以使用 explict 关键字</p>
<h3 id="mutable-成员">mutable 成员</h3>
<p>multable 成员指出，即使是 const 对象，它的 mutable 成员也是可以被修改的（例如计数的）</p>
<h3 id="虚函数-virtual-重载-overide不再允许子类重载-final">虚函数 virtual, 重载 overide，不再允许子类重载 final</h3>
<p>虚函数直白的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// void print() &#123;</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printS</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print</span>();<br>  &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  A a;<br>  B b;<br>  A *p1 = &amp;a;<br>  A *p2 = &amp;b;<br>  B *p3 = &amp;b;<br>  p1-&gt;<span class="hljs-built_in">print</span>();<br>  p2-&gt;<span class="hljs-built_in">print</span>();<br>  p3-&gt;<span class="hljs-built_in">print</span>();<br>  p1-&gt;<span class="hljs-built_in">printS</span>();<br>  p2-&gt;<span class="hljs-built_in">printS</span>();<br>  p3-&gt;<span class="hljs-built_in">print</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>A 的 print 函数前加 virtual 和不加有很大的不同</p>
</blockquote>
<p>假设基类 的 A 函数需要调用 B 函数，而子类有对 B 进行覆盖。那么子类在调用（从基类继承的） A 函数时，并不会调用子类的 B 函数，而是调用基类的 B 函数。如果像 A 函数调用的是子类中的 B 函数，那么只需在 A 函数前加 virtual 关键字即可，此时最好在子类的函数中添加一个 overide 关键字，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Box.hpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> BOX_HPP</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BOX_HPP</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> &#123;</span><br>  <span class="hljs-keyword">double</span> x = <span class="hljs-number">2</span>;<br> <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-keyword">double</span> length &#123;<span class="hljs-number">1.0</span>&#125;;<br>  <span class="hljs-keyword">double</span> width &#123;<span class="hljs-number">1.0</span>&#125;;<br>  <span class="hljs-keyword">double</span> height &#123;<span class="hljs-number">1.0</span>&#125;;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Box</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">Box</span>(<span class="hljs-keyword">double</span> lv, <span class="hljs-keyword">double</span> wv, <span class="hljs-keyword">double</span> hv) : length &#123;lv&#125;, width &#123;wv&#125;, height &#123;hv&#125; &#123;&#125;<br>  <span class="hljs-comment">// Function to show the volume of an object</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showVolume</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Box usable volume is &quot;</span> &lt;&lt; <span class="hljs-built_in">volume</span>() &lt;&lt; std::endl; &#125;<br>  <span class="hljs-comment">// Function to calculate the volume of a Box object</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> length * width * height; &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// Package.hpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> PACKAGE_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PACKAGE_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Box.hpp&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Package</span> :</span> <span class="hljs-keyword">public</span> Box &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Constructor</span><br>  <span class="hljs-built_in">Package</span>(<span class="hljs-keyword">double</span> lv, <span class="hljs-keyword">double</span> wv, <span class="hljs-keyword">double</span> hv) : Box &#123;lv, wv, hv&#125; &#123;&#125;<br>  <span class="hljs-comment">// Function to calculate volume of a ToughPack allowing 15% for packing</span><br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0.85</span> * length * width * height; &#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Box.hpp&quot;</span> <span class="hljs-comment">// For the Box class</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Package.hpp&quot;</span> <span class="hljs-comment">// For the ToughPack class</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Box box &#123;<span class="hljs-number">20.0</span>, <span class="hljs-number">30.0</span>, <span class="hljs-number">40.0</span>&#125;; <span class="hljs-comment">// Define a box</span><br>  Package hardcase &#123;<span class="hljs-number">20.0</span>, <span class="hljs-number">30.0</span>, <span class="hljs-number">40.0</span>&#125;; <span class="hljs-comment">// Declare tough box - same size</span><br>  box.<span class="hljs-built_in">showVolume</span>(); <span class="hljs-comment">// Display volume of base box</span><br>  hardcase.<span class="hljs-built_in">showVolume</span>(); <span class="hljs-comment">// Display volume of derived box</span><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>虚函数一般用来作为接口，是特别有用的</p>
</blockquote>
<h2 id="混合特征">混合特征</h2>
<h3 id="mixin"><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/460825741">Mixin</a></h3>
<p>利用可变参数模版和 C++ 多继承来把一些不相关的功能做成一个类</p>
<h3 id="constexpr-用编译时间换运行时间">constexpr 用编译时间换运行时间</h3>
<p>好处：安全，加密； 坏处：延长了编译时间。看以后的发展了。</p>
<p>替代解决方案：预处理得到文件，然后读取文件（容易有安全问题，另外要考虑独写效率）</p>
<h3 id="optional-有三个顾名思义的函数have_value-value-value_or">optional 有三个顾名思义的函数：have_value, value, value_or</h3>
<p>如果无值时调用 value，那么会 RE，这是件好事。 ### reserve 是个好东西，多注意内存相关</p>
<p><code>std::vector&lt;T&gt;</code> 有三个重要的 "指针"：<code>begin()</code>, <code>end()</code> 和一个确定占用空间的（对应着 capacity 函数)。然后扩容是按照初始容量倍增的。然后 <code>pop_back()</code>, <code>clear()</code> 这些都不会影响到 <code>capacity()</code>（它只会被 reserve 和 扩容影响）</p>
<h3 id="vectorat">vector::at</h3>
<p>at 会做边界检测，而 <code>[]</code> 默认不会，但是可以在编译中加<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16620222/vector-going-out-of-bounds-without-giving-error">如下参数</a>做边界检测。例如我可以如下编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ main.cpp -O2 -std=c++17 -D_GLIBCXX_DEBUG -o main<br></code></pre></td></tr></table></figure>
<h3 id="gcc-与-g的区别"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/oxspirt/p/6847438.html">gcc 与 g++的区别</a></h3>
<h4 id="gnu-libstdc">gnu libstdc++</h4>
<ul>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode.html">Debug mode</a> -- general info about libstdc++ debugging</li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/debug_mode_using.html">_GLIBCXX_DEBUG</a></li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/concept_checking.html">_GLIBCXX_CONCEPT_CHECKS</a>, with -fconcepts -- enable c++ concepts</li>
<li><h4 id="clang-libcxx">clang libcxx</h4></li>
<li><a target="_blank" rel="noopener" href="https://libcxx.llvm.org//DesignDocs/DebugMode.html#using-debug-mode">_LIBCPP_DEBUG_LEVEL=1</a></li>
</ul>
<h4 id="boost">boost</h4>
<p><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_66_0/libs/assert/doc/html/assert.html">BOOST_DISABLE_ASSERTS</a> -- disable asserts in the boost library.</p>
<h4 id="microsoft">Microsoft</h4>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/standard-library/checked-iterators?redirectedfrom=MSDN&amp;view=msvc-170">Checked Iterators</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/standard-library/iterator-debug-level?redirectedfrom=MSDN&amp;view=msvc-170">_ITERATOR_DEBUG_LEVEL</a> -- set iterator debug level</p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/security-features-in-the-crt?view=msvc-170">Security Features in the CRT</a></p></li>
<li><p>_CRT_SECURE_NO_WARNINGS : disable deprecation warnings</p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/standard-library/scl-secure-no-warnings?redirectedfrom=MSDN&amp;view=msvc-170">_SCL_SECURE_NO_WARNINGS</a> -- less safe(according to microsoft), but more standard compliant:</p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/standard-library/secure-scl?redirectedfrom=MSDN&amp;view=msvc-170">_SECURE_SCL</a> -- old method of setting iterator debug level</p></li>
<li><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/standard-library/has-iterator-debugging?view=msvc-170">_HAS_ITERATOR_DEBUGGING</a> - deprecated macro &gt; Note that gnu and clang disable the checks by default, while microsoft has them enabled by default. If you are unaware of this, your code may run significantly slower in debug mode on a microsoft system.</p></li>
</ul>
<h3 id="gcc-内建的一些好用的函数">gcc 内建的一些好用的函数</h3>
<blockquote>
<p>下面函数后加 <code>ll</code> 就可以得到 <code>unsigned long long</code> 对应的版本。应该尽量避免这样写，因为如果公司需要用 clang 你还要迁移</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> uint = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>;<br>__builtin_clz(uint n);           <span class="hljs-comment">// 返回n的二进制前置0的个数（有汇编支持）</span><br>__builtin_clrsb (<span class="hljs-keyword">int</span> x);         <span class="hljs-comment">// 返回冗余位个数</span><br>__builtin_ctz(uint n);           <span class="hljs-comment">// 返回n的二进制后置0的个数</span><br>__builtin_ffs(<span class="hljs-keyword">int</span> n) = __builtin_ctz(uint n) + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 返回n的二进制从后往前第一次出现1的位置</span><br>__builtin_popcount(uint n);      <span class="hljs-comment">// 返回n的二进制1的个数，以上函数仅在GCC中有</span><br><span class="hljs-keyword">int</span> __builtin_parity(uint n);    <span class="hljs-comment">// 返回n的二进制1的个数奇偶性</span><br>std::__lg(<span class="hljs-keyword">int</span> n);                <span class="hljs-comment">//  返回log2(n)的整数部分</span><br><span class="hljs-built_in">lowbit</span>(uint n) = n &amp; -n;         <span class="hljs-comment">//  返回使得最大的2^i|n // 这个不是内建的</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html" class="uri">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>，其中 <code>__builtin_clz, __builtin_clrsb, __builtin_ctz, __builtin_ffs, std::__lg</code> 可认为有内置汇编语言支持，<code>__builtin_popcount</code> 有更快的实现，而 <code>__builtin_parity</code> 我尝试了各种写法都无法超过内建的，不知道它怎么写的</p>
</blockquote>
<h3 id="智能指针">智能指针</h3>
<p>一般根据需求使用 <code>unique_ptr&lt;T&gt;</code> 或 <code>shared_ptr&lt;T&gt;</code></p>
<p><code>weak_ptr&lt;T&gt;</code> 可以理解为 <code>shared_ptr&lt;T&gt;</code> 的引用，可以解决 <code>shared_ptr&lt;T&gt;</code> 的循环引用导致无法释放内存的问题。</p>
<p><code>unique_ptr&lt;T&gt;</code> 可以通过 <code>std::move</code> 转移所有权；<code>shared_ptr&lt;T&gt;</code> 可以通过 reset 释放或者指向其他内存（谨慎使用 release，最好别用）</p>
<blockquote>
<p>智能指针唯一的劣势：无法进行四则运算</p>
</blockquote>
<h3 id="free-store-vs-heap"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/QG-whz/p/5060894.html">free store VS heap</a></h3>
<p>简单的说，用户申请内存在 heap 上，这是 C 原有的，C++ 兼容了这一点，当然 C++ new 是在 free store 上的（这是一个抽象的概念），但是主流编译器实现的都是基于 C 的 malloc，因此其实也是在 heap 上的。但是用户可以重载 new/delete 使得它们不在 heap 上</p>
<h3 id="烫烫烫烫烫-的原因">烫烫烫烫烫 的原因</h3>
<p><code>0xCCCCCCCC -858993460</code>: <a target="_blank" rel="noopener" href="https://blog.csdn.net/huijiaaa1/article/details/89361230" class="uri">https://blog.csdn.net/huijiaaa1/article/details/89361230</a></p>
<h3 id="lambda-函数做计数器"><a target="_blank" rel="noopener" href="https://github.com/shuai132/blog_code/tree/master/src/1.closure">lambda 函数做计数器</a></h3>
<h3 id="c-代码注入"><a href="../preload">C++ 代码注入</a></h3>
<h3 id="volatile-关键字"><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">volatile 关键字</a></h3>
<p>特别重要的特征，在跟操作系统，硬件交互或者多线程的编程中尤为重要</p>
<p>A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</p>
<p>当使用并发时使用 <code>std::atomic</code>，对特定内存才使用（要接触硬件）时使用 volatile</p>
<h3 id="extern-关键字"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html">extern 关键字</a></h3>
<h3 id="可变参数模版">可变参数模版</h3>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yyxt/p/4204933.html" class="uri">https://www.cnblogs.com/yyxt/p/4204933.html</a></p>
<p>完全 C++ 风格示例（可以不用 <code>va_start</code>, <code>va_args</code>, <code>va_end</code>, <code>va_list</code> 这一套了）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cerr(x) std::cerr &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo_print</span><span class="hljs-params">(Ts... args)</span> </span>&#123;<br>  ((std::cout &lt;&lt; args &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>), ...);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo_sum</span><span class="hljs-params">(Ts... args)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-keyword">sizeof</span>...(args) &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> ((args) + ...);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cout &lt;&lt; std::boolalpha;<br>  <span class="hljs-built_in">foo_print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3.14f</span>); <span class="hljs-comment">// 1 3.14</span><br>  <span class="hljs-built_in">foo_print</span>(<span class="hljs-string">&quot;Foo&quot;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// Foo b true nullptr</span><br>  std::cout &lt;&lt; <span class="hljs-built_in">foo_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Variadic_function#Variadic_functions_in_C.2C_Objective-C.2C_C.2B.2B.2C_and_D" class="uri">https://en.wikipedia.org/wiki/Variadic_function#Variadic_functions_in_C.2C_Objective-C.2C_C.2B.2B.2C_and_D</a></p>
<h3 id="宏编程">宏编程</h3>
<p>有时候一些平台相关的代码，或者一些预处理必然需要用的宏，但是有时一句话很长为此可以在后面加入 <code>\</code> 来换行</p>
<ul>
<li><code>#if, #define #has_include</code> 等等，可以把 <code>#</code> 全部放在第一列，这样看上去就跟普通 <code>if else</code> 一样（看 stl 的实现可以看到这样的技巧）</li>
<li><code>#x</code> 表示 <span class="math inline">\(x\)</span> 的字符串，<code>x##y</code> 表示将 <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> 这两个字符串拼接起来</li>
</ul>
<p><code>g++ -dM -E main.cpp</code> 查看全部宏(main.cpp 内容可以为空) gcc, clang 用法一样，其它未求证</p>
<h2 id="常用算法简化编程实例">常用算法简化编程实例</h2>
<h3 id="最小最大值">最小最大值</h3>
<p><code>min, max, minmax</code> 都是参数个数为 2，返回的是值。所以不举例了，注意到 <code>minmax</code> 返回的是 <code>pair</code></p>
<p><code>min_element,max_element,minmax_element</code> 参数都是 <code>vector</code>，且返回的是索引。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; *<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) &lt;&lt; std::endl;<br><span class="hljs-keyword">auto</span> lr = <span class="hljs-built_in">minmax_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//不能取*,因为返回的是pair类型</span><br>std::cout &lt;&lt; *lr.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *lr.second &lt;&lt; std::endl;<br><span class="hljs-keyword">auto</span>[l, r] = <span class="hljs-built_in">minmax_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//自动解析也行</span><br>std::cout &lt;&lt; *l &lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *r &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>
<h3 id="累积运算-accumulate-长没关系有代码补全">累积运算 accumulate （长没关系，有代码补全）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-keyword">int</span>&gt; a&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>) &lt;&lt; std::endl; <span class="hljs-comment">//默认累和</span><br>std::cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, std::plus&lt;<span class="hljs-keyword">int</span>&gt;()) &lt;&lt; std::endl; <span class="hljs-comment">//可选加减乘除</span><br>std::cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, std::minus&lt;<span class="hljs-keyword">int</span>&gt;()) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>, std::multiplies&lt;<span class="hljs-keyword">int</span>&gt;()) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>, std::divides&lt;<span class="hljs-keyword">int</span>&gt;()) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, [](<span class="hljs-keyword">auto</span> &amp; x, <span class="hljs-keyword">auto</span> &amp; y) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x + y;<br>&#125;) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>
<h3 id="排序">排序</h3>
<blockquote>
<p>sort 的时候不能出现 <span class="math inline">\(a &lt; b\)</span> 且 <span class="math inline">\(b &lt; a\)</span> 同时出现的情况 <code>stable_sort</code> 是稳定排序，即不改变原有相互不小于的元素的相对位置</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 默认从小到大排序</span><br>std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), std::less&lt;<span class="hljs-keyword">int</span>&gt;()); <span class="hljs-comment">// 手动从小到大排序（不一定是int，具体问题具体修改）</span><br>std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">rbegin</span>(), a.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 从大到小排序</span><br>std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), std::greater&lt;<span class="hljs-keyword">int</span>&gt;()); <span class="hljs-comment">// 从大到小排序</span><br><span class="hljs-comment">//对于 tuple 和 pair 大小关系都是从按照字典序比较的</span><br>std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">int</span> &amp; x, <span class="hljs-keyword">int</span> &amp; y) &#123;<br>  <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (x ^ <span class="hljs-number">4</span>) &lt; (y ^ <span class="hljs-number">4</span>); <span class="hljs-comment">// 位运算的优先级好低呀</span><br>&#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; x: a) std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>std::tuple_size&lt;decltype(tupleExample)&gt;::value;</code> 可以获得 tuple 是多少维的。其中 <code>decltype</code> 代表 <code>declare type</code> 即声明类型。</p>
</blockquote>
<h3 id="集合交并运算">集合交并运算</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::set&lt;<span class="hljs-keyword">int</span>&gt; x&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::set&lt;<span class="hljs-keyword">int</span>&gt; y&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>std::set&lt;<span class="hljs-keyword">int</span>&gt; t;<br>std::<span class="hljs-built_in">set_intersection</span>(x.<span class="hljs-built_in">begin</span>(), x.<span class="hljs-built_in">end</span>(), y.<span class="hljs-built_in">begin</span>(), y.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">inserter</span>(t, t.<span class="hljs-built_in">begin</span>()));<br><span class="hljs-comment">// 若x,y,t是vector等有push_back 的容器，就可以使用</span><br><span class="hljs-comment">// set_intersection(x.begin(),x.end(),y.begin(),y.end(),back_inserter(t));</span><br><span class="hljs-comment">// set_union,set_difference,set_symmetric_difference 等同理</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>优先使用 <code>unorder_set</code></p>
</blockquote>
<h3 id="lambda-表达式递归写法">lambda 表达式递归写法</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; gcd = [ &amp; ](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; <span class="hljs-keyword">int</span> &#123; <span class="hljs-comment">// 注意最前面不能用auto</span><br>  <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">gcd</span>(<span class="hljs-number">102</span>, <span class="hljs-number">210</span>) &lt;&lt; std::endl;<br>std::cout &lt;&lt; std::__gcd(<span class="hljs-number">102</span>, <span class="hljs-number">210</span>) &lt;&lt; std::endl;<br><span class="hljs-comment">// 也可以这么写，但是调用的时候要使用  gcd(gcd, a, b) 不如上面来的方便</span><br><span class="hljs-keyword">auto</span> gcd = [&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; self, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123;<br>  <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">self</span>(self, b, a % b) : a;<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意全局变量和全局函数，即使 lambda 列表为空，也能访问它们 注意 lambda 列表中如果是传值，那么默认不会修改，要修改可以加 mutable, 注意一旦传值就是另一个副本了，即此时原来的值改变不会影响 lambda 列表中的值（见下面例子）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">auto</span> f = [x]() <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-keyword">int</span> &#123;<br>    <span class="hljs-keyword">return</span> --x;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> g = [x]() -&gt; <span class="hljs-keyword">int</span> &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;;<br>  ++x; <span class="hljs-comment">// x 再次改变不会影响 f 和 g 中的 x</span><br>  <span class="hljs-built_in">cerr</span>(<span class="hljs-built_in">f</span>()); <span class="hljs-comment">// -1</span><br>  <span class="hljs-built_in">cerr</span>(<span class="hljs-built_in">g</span>()); <span class="hljs-comment">// 0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们为了性能一般会优先选择传引用，但是默认不支持传 const 引用，此时可以用 C++17 中的 <code>as_cost</code> 的做法(当然了 const 引用你也可以直接写 引用，毕竟 const 只是编译器帮助自己检查罢了，对于机器来说并无区别)</p>
<h3 id="普通函数转-lambda-函数利用-stdbind">普通函数转 lambda 函数（利用 <code>std::bind</code>)</h3>
<p><code>std::placeholders::_1, std::placeholders::_2, ..., std::placeholders::_N</code>，貌似很有用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-number">2</span> * i + x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-number">1LL</span> * i * x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; f = &amp;Print;<br>  <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 7</span><br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; g = std::<span class="hljs-built_in">bind</span>(Print, std::placeholders::_1, <span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">g</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 11</span><br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; h = std::<span class="hljs-built_in">bind</span>(Print, <span class="hljs-number">3</span>, std::placeholders::_1);<br>  <span class="hljs-built_in">h</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">// 11</span><br>  A x;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; i = std::<span class="hljs-built_in">bind</span>(&amp;A::Print, &amp;x, <span class="hljs-number">3</span>, std::placeholders::_1);<br>  <span class="hljs-built_in">i</span>(<span class="hljs-number">6</span>);    <span class="hljs-comment">// 18</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>官方示例：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/functional/bind" class="uri">https://en.cppreference.com/w/cpp/utility/functional/bind</a></p>
<h2 id="容器简介">容器简介</h2>
<ul>
<li>array, vector, deque, list（双向链表）, forward_list（单向链表）都是顺序容器。</li>
<li>set, map 是关联容器。</li>
<li>unordered_map 和 unordered_set 是无序关联容器</li>
<li>stack，queue，priority_queue 严格说不是容器，而是容器适配器（默认使用 deque，可以自己换成 vector）</li>
</ul>
<h3 id="优先队列-priority_queue">优先队列 priority_queue</h3>
<ul>
<li><p><code>std::priority_queue&lt;int&gt;</code> 是默认最大堆，即头部是最大值。</p></li>
<li><p>最小堆可以用 <code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;&gt;&gt;</code>。</p></li>
<li><p>如果一般化地情况，<code>std::priority_queue&lt;Node&gt;</code> 其中 Node 中要定义小于号，然后也是最大堆。例如 Node 可以是 <code>std::pair&lt;int, int&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  <span class="hljs-keyword">int</span> x, y;<br>  <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _x, <span class="hljs-keyword">int</span> _y) : <span class="hljs-built_in">x</span>(_x), <span class="hljs-built_in">y</span>(_y) &#123;&#125;<br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> Node &amp;A) <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">return</span> x * A.y &lt; y * A.x;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>另一种方式（cmp 中出现的 lambda 函数必须是全局变量），例如对 <code>pii = std::pair&lt;int, int&gt;</code> 的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cmp</span> &#123;</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> pii &amp;lhs, <span class="hljs-keyword">const</span> pii &amp;rhs)</span> <span class="hljs-keyword">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.first * rhs.second &lt; rhs.second * rhs.first;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意优先队列不能随机访问和自然遍历 0.0</p>
</blockquote>
<h3 id="注意-map-和-unordered_map-的数据污染问题">注意 map 和 unordered_map 的数据污染问题</h3>
<p>map 中支持 <code>mp[i]</code> 的直接调用（即使没有数据 i，此时默认返回 0），但是次调用会污染了数据，即此时无论 mp 中是否有元素 i, i 都被添加到 mp 中。此时调用迭代器，i 就会出现了，这里需要特别注意。</p>
<p>unordered_map 同理。</p>
<h2 id="pb_ds"><a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/11080">pb_ds</a></h2>
<p>过题的实例代码：<a target="_blank" rel="noopener" href="https://codeforces.com/gym/103076/submission/115854517">gym 103076I</a></p>
<h2 id="大数库">大数库</h2>
<h3 id="gmp">GMP</h3>
<blockquote>
<p>谁说 GMP 好用的，出来挨打！已经抛弃</p>
</blockquote>
<p>Ubuntu 20.04 好像内置安装了 GMP，如果没安装可以使用 <code>sudo apt install libgmp-dev</code> 安装（可能需要安装 m4) 使用的时候 <code>#include &lt;gmpxx.h&gt;</code> 就好了（带 xx 表示 C++ 使用，不带表示 C 使用），不过它真的难用</p>
<h3 id="ntl专攻数论以后再学吧"><a target="_blank" rel="noopener" href="https://www.shoup.net/ntl/doc/tour.html">NTL</a>：专攻数论，以后再学吧</h3>
<blockquote>
<p>NTL 才是正确的选择，但是它的高效是需要借助 GMP 的</p>
</blockquote>
<h3 id="boost最终选择"><a target="_blank" rel="noopener" href="https://www.boost.org/">Boost</a>：最终选择</h3>
<blockquote>
<p>Boost 是激进的 STL，STL 是保守的 Boost</p>
</blockquote>
<p>一键安装：<code>sudo apt install libboost-all-dev</code>，正确用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> BINT = boost::multiprecision::cpp_int;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>win10 下 WSL ubuntu20.04 真香。全所未有的方便！ win10 下 还可以用 <a target="_blank" rel="noopener" href="https://packages.msys2.org/package/mingw-w64-x86_64-boost?repo=mingw64">MSYS2 安装</a></p>
</blockquote>
<h2 id="网络编程之-asio">网络编程之 asio</h2>
<blockquote>
<p>很依赖 boost，将于 C++23 加入 STL</p>
</blockquote>
<p>学习资料：<a target="_blank" rel="noopener" href="http://think-async.com/Asio/">官方库</a>，<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007225464">基于 asio 的 C++ 网络编程</a></p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/note/">#note</a>
      
        <a href="/tags/cpp/">#cpp</a>
      
    </div>
  
</div>


              

              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.4.17/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"hello-cloudbase-6gua2z7k094e2b64","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      沪ICP备2021025739号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
