<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>快速除法取模</title>
    <link href="/fastDivMod/"/>
    <url>/fastDivMod/</url>
    
    <content type="html"><![CDATA[<p>在知乎好友 <a href="https://www.zhihu.com/people/supersodasea">SuperSodaSea</a> 的<a href="https://zhuanlan.zhihu.com/p/151038723">文章</a>中看到，对于<strong>模数为常量的情况</strong>编译器会帮我们做优化（所以我们按照同种方式手写肯定跑不过编译器，真的如此吗？）</p><span id="more"></span><h2 id="模数为常量的快速模">模数为常量的快速模</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">powMod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> M)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n) &#123;<br>    <span class="hljs-keyword">if</span> (n&amp;<span class="hljs-number">1</span>) r = <span class="hljs-number">1LL</span> * r * x % M;<br>    n &gt;&gt;= <span class="hljs-number">1</span>; x = <span class="hljs-number">1LL</span> * x * x % M;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此对于 powMod，上面写法会慢于下面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">998244353</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">powMod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n) &#123;<br>    <span class="hljs-keyword">if</span> (n&amp;<span class="hljs-number">1</span>) r = <span class="hljs-number">1LL</span> * r * x % M;<br>    n &gt;&gt;= <span class="hljs-number">1</span>; x = <span class="hljs-number">1LL</span> * x * x % M;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为对于模为 const 的情形，编译器可以在<strong>编译期</strong>利用 Barrett Modular Multiplication 把除法变成乘法（如果我们自定义高精度还是需要自己写这些优化）。但是其实我们可以利用 <a href="https://www.rieselprime.de/ziki/Montgomery_multiplication">Montgomery multiplication</a> 做的更好即如下写法：</p><p>我们来证明一波。首先给定常数 <span class="math inline">\(m, n\)</span> 使得 <span class="math inline">\(m &lt; 2^n\)</span> 且 <span class="math inline">\(m\)</span> 为奇数（这是必不可少的限制条件）。且使用无符号整型。对于任意数字 <span class="math inline">\(a\)</span>, 定义 <span class="math inline">\(a&#39; \equiv 2^n a \mod m\)</span>，那么我们想要计算 <span class="math inline">\(c \equiv ab \mod m\)</span>，那么我们只需要计算出 <span class="math display">\[c&#39; \equiv (ab)&#39; \equiv 2^n ab \equiv 2^{-n} a&#39;b&#39; \mod m\]</span> 所以我们需要找到一个 <span class="math inline">\(s\)</span> 使得 <span class="math inline">\(a&#39;b&#39; + sm\)</span> 是 <span class="math inline">\(2^n\)</span> 的倍数，然后 <span class="math inline">\(\frac{a&#39;b&#39; + sm}{2^n}\)</span> 即为所求，且我们可以找 <span class="math inline">\(s &lt; 2^n\)</span> 那么此时这个结果会 小于 <span class="math inline">\(2m\)</span>。然后做一个判断即可。而 <span class="math inline">\(s\)</span> 显然可以用 exgcd 来求（这也是为什么要求 <span class="math inline">\(m\)</span> 为奇数），即 <span class="math inline">\(s = -\frac{1}{m} \mod 2^n\)</span>（代码中为 <code>mr</code>）.</p><p>为了高效，实现的时候我们取 <span class="math inline">\(n = 32\)</span>。注意到一般我们的模都小于 <span class="math inline">\(2^{30}\)</span>, 即 <span class="math inline">\(m &lt; 2^{n - 2}\)</span>，若 <span class="math inline">\(a&#39;, b&#39; &lt; 2^{n - 1}\)</span>, 又因为 <span class="math inline">\(s &lt; 2^n\)</span>，从而 <span class="math inline">\(sm + a&#39;b&#39; &lt; 2^{2n - 1}\)</span>，从而保证了 <span class="math inline">\(c&#39; &lt; 2^{n - 1}\)</span>，从而就可以不要每次都取一次最小值，只需最后搞一下即可（下面情形依然可以省去）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 40% faster</span><br><span class="hljs-keyword">using</span> ULL = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">fastPowMod998244353</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> x, <span class="hljs-keyword">unsigned</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> m = <span class="hljs-number">998244353U</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> mr = <span class="hljs-number">998244351U</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> m1 = <span class="hljs-number">301989884U</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> m1inv = <span class="hljs-number">232013824U</span>;<br>  <span class="hljs-keyword">unsigned</span> xx = (<span class="hljs-built_in">ULL</span>(x) &lt;&lt; <span class="hljs-number">32</span>) % m, rr = m1;<br>  <span class="hljs-keyword">while</span> (n) &#123;<br>    <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>      ULL t = <span class="hljs-built_in">ULL</span>(rr) * xx;<br>      rr = (t + <span class="hljs-built_in">ULL</span>(<span class="hljs-built_in"><span class="hljs-keyword">unsigned</span></span>(t) * mr) * m) &gt;&gt; <span class="hljs-number">32</span>;<br>    &#125;<br>    ULL t = <span class="hljs-built_in">ULL</span>(xx) * xx;<br>    xx = (t + <span class="hljs-built_in">ULL</span>(<span class="hljs-built_in"><span class="hljs-keyword">unsigned</span></span>(t) * mr) * m) &gt;&gt; <span class="hljs-number">32</span>;<br>    n &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ULL</span>(rr) * m1inv % m;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><del>实测 <code>xx = std::min(xx, xx - m);</code> 会比 <code>if (xx &gt;= m) xx -= m</code> 快不少，主要是因为后者有分支会比较耗时</del>，这段被直接优化掉了 其实上述做法对 <span class="math inline">\(m\)</span> 不是常数也能做，只是此时不能在编译期计算 <code>mr, m1, m1inv</code> 所以会很慢，从而就没有太大的意义了（极端特殊的场景还是能用的） 上面有一段特别类似的代码（也可以写成函数然后强制内联，但没必要），如果写成函数会增加耗时，所以还是单独写吧。然后如果我们有如下的函数，<del>可以跑的更快（以后再加）</del>，并不会更快，因为 <code>(x + y) &gt;&gt; 32</code> 并不等于 <code>(x &gt;&gt; 32) + (y &gt;&gt; 32)</code>，但是不妨碍写汇编(x86_64 gcc)，以下汇编修改于 SuperSodaSea 给我的汇编代码。可是 arm64 的版本一直搞不好</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span>  __attribute__((always_inline))<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">muluh</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> a, <span class="hljs-keyword">unsigned</span> b, <span class="hljs-keyword">unsigned</span>&amp; c)</span> </span>&#123;<br>  <span class="hljs-keyword">unsigned</span> x;<br>  __asm__ __volatile__(<br>    <span class="hljs-string">&quot;mull %%edx&quot;</span><br>    : <span class="hljs-string">&quot;=a&quot;</span>(c), <span class="hljs-string">&quot;=d&quot;</span>(x)<br>    : <span class="hljs-string">&quot;a&quot;</span>(a), <span class="hljs-string">&quot;d&quot;</span>(b)<br>  );<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span>  __attribute__((always_inline))<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">muluh</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> a, <span class="hljs-keyword">unsigned</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">unsigned</span> x;<br>  __asm__ __volatile__(<br>    <span class="hljs-string">&quot;mull %%edx&quot;</span><br>    : <span class="hljs-string">&quot;=d&quot;</span>(x)<br>    : <span class="hljs-string">&quot;a&quot;</span>(a), <span class="hljs-string">&quot;d&quot;</span>(b)<br>  );<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实我们可以<strong>写代码生成常数模的 fastPowMod 代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cerr(x) std::cerr &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">powMod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> M)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n) &#123;<br>    <span class="hljs-keyword">if</span> (n&amp;<span class="hljs-number">1</span>) r = <span class="hljs-number">1LL</span> * r * x % M;<br>    n &gt;&gt;= <span class="hljs-number">1</span>; x = <span class="hljs-number">1LL</span> * x * x % M;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">std::tuple&lt;T, T, T&gt; <span class="hljs-title">exGcd</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;a, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">auto</span> [d, y, x] = <span class="hljs-built_in">exGcd</span>(b, a % b);<br>  <span class="hljs-keyword">return</span> &#123;d, x, y - a / b * x&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> ((m &amp; -m) == m) &#123;<br>    std::clog &lt;&lt; <span class="hljs-string">&quot;You may use bit operators instead:\n\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;unsigned fastPowMod&quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">&quot;(unsigned x, unsigned n) &#123;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;  unsigned r = 1;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;  while (n) &#123;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;    if (n &amp; 1) r = 1LL * r * x &amp;&quot;</span> &lt;&lt;  m - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;U;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;    n &gt;&gt;= 1;   r = 1LL * x * x &amp;&quot;</span> &lt;&lt;  m - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;U;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;  &#125;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;  return r;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;&#125;\n\n&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Sorry, not support for even number which is not power of 2: &quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt;&gt; <span class="hljs-number">30</span>) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Sorry, not support for number bigger than 2^30: &quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> [d, x, y] = <span class="hljs-built_in">exGcd</span>(<span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">32</span>, <span class="hljs-number">1LL</span> * m);<br>  y = -y;<br>  <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span>) y += <span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">32</span>;<br>  <span class="hljs-keyword">int</span> m1 = (<span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">32</span>) % m;<br>  <span class="hljs-keyword">auto</span> [d1, x1, y1] = <span class="hljs-built_in">exGcd</span>(m1, m);<br>  <span class="hljs-keyword">if</span> (x1 &lt; <span class="hljs-number">0</span>) x1 += m;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;using ULL = unsigned long long;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;unsigned fastPowMod&quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">&quot;(unsigned x, unsigned n) &#123;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;  static const unsigned m = &quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">&quot;U;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;  static const unsigned mr = &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;U;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;  static const unsigned m1 = &quot;</span> &lt;&lt; m1 &lt;&lt; <span class="hljs-string">&quot;U;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;  static const unsigned m1inv = &quot;</span> &lt;&lt; x1 &lt;&lt; <span class="hljs-string">&quot;U;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;  unsigned xx = (ULL(x) &lt;&lt; 32) % m, rr = m1;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;  while (n) &#123;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;    if (n &amp; 1) &#123;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;      ULL t = ULL(rr) * xx;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;      rr = (t + ULL(unsigned(t) * mr) * m) &gt;&gt; 32;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;    &#125;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;    ULL t = ULL(xx) * xx;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;    xx = (t + ULL(unsigned(t) * mr) * m) &gt;&gt; 32;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;    n &gt;&gt;= 1;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;  &#125;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;  return ULL(rr) * m1inv % m;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;&#125;\n\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">generate</span>(<span class="hljs-number">998244353</span>);<br>  <span class="hljs-built_in">generate</span>(<span class="hljs-number">1000000007</span>);<br>  <span class="hljs-built_in">generate</span>(<span class="hljs-number">1000000009</span>);<br>  <span class="hljs-built_in">generate</span>(<span class="hljs-number">1024</span>);<br>  <span class="hljs-built_in">generate</span>(<span class="hljs-number">39</span>);<br>  <span class="hljs-built_in">generate</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">generate</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>) + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们验证效率和正确性的代码（以 998244353 为例）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cerr(x) std::cerr &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">using</span> ULL = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> <span class="hljs-keyword">final</span> &#123;</span><br>  std::chrono::high_resolution_clock::time_point start_;<br>  std::string name_;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Timer</span>(std::string name = &#123;&#125;) : <span class="hljs-built_in">start_</span>(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>()), <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>  ~<span class="hljs-built_in">Timer</span>() &#123;<br>    <span class="hljs-keyword">auto</span> elapsedTime = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - start_;<br>    std::cerr &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; std::fixed &lt;&lt; <span class="hljs-string">&quot;[Time used: &quot;</span> &lt;&lt;<br>        name_ &lt;&lt; <span class="hljs-string">&quot;] &quot;</span> &lt;&lt; elapsedTime.<span class="hljs-built_in">count</span>() / <span class="hljs-number">1&#x27;000&#x27;000.0</span> &lt;&lt; <span class="hljs-string">&quot;ms\n&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">998244353</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">powMod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> r = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n) &#123;<br>    <span class="hljs-keyword">if</span> (n&amp;<span class="hljs-number">1</span>) r = <span class="hljs-number">1LL</span> * r * x % M;<br>    n &gt;&gt;= <span class="hljs-number">1</span>; x = <span class="hljs-number">1LL</span> * x * x % M;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-comment">// 40% faster</span><br><span class="hljs-keyword">using</span> ULL = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">fastPowMod998244353</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> x, <span class="hljs-keyword">unsigned</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> m = <span class="hljs-number">998244353U</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> mr = <span class="hljs-number">998244351U</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> m1 = <span class="hljs-number">301989884U</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> m1inv = <span class="hljs-number">232013824U</span>;<br>  <span class="hljs-keyword">unsigned</span> xx = (<span class="hljs-built_in">ULL</span>(x) &lt;&lt; <span class="hljs-number">32</span>) % m, rr = m1;<br>  <span class="hljs-keyword">while</span> (n) &#123;<br>    <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>      ULL t = <span class="hljs-built_in">ULL</span>(rr) * xx;<br>      rr = (t + <span class="hljs-built_in">ULL</span>(<span class="hljs-built_in"><span class="hljs-keyword">unsigned</span></span>(t) * mr) * m) &gt;&gt; <span class="hljs-number">32</span>;<br>    &#125;<br>    ULL t = <span class="hljs-built_in">ULL</span>(xx) * xx;<br>    xx = (t + <span class="hljs-built_in">ULL</span>(<span class="hljs-built_in"><span class="hljs-keyword">unsigned</span></span>(t) * mr) * m) &gt;&gt; <span class="hljs-number">32</span>;<br>    n &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">ULL</span>(rr) * m1inv % m;<br>&#125;<br><br><span class="hljs-function">std::mt19937 <span class="hljs-title">rnd</span><span class="hljs-params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">3e7</span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) a[i] = <span class="hljs-built_in">rnd</span>() % M;<br>&#123;<br>  <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;fast?&quot;</span>)</span></span>;<br>  LL sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>    sum += <span class="hljs-built_in">fastPowMod998244353</span>(a[i], i);<br>  &#125;<br>  <span class="hljs-built_in">cerr</span>(sum);<br>&#125;<br>&#123;<br>  <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;default&quot;</span>)</span></span>;<br>  LL sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>    sum += <span class="hljs-built_in">powMod</span>(a[i], i);<br>  &#125;<br>  <span class="hljs-built_in">cerr</span>(sum);<br>&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此快速模部分已经搞定。我们下面来看 SuperSodaSea 在知乎介绍的 Barrett Modular Multiplication方法（写的特别好，严谨，循序渐进，一点点的发现问题修复问题），当然了他参考了 Barrett 的<a href="https://gmplib.org/~tege/divcnst-pldi94.pdf">论文</a></p><blockquote><p>最后这部分可以写成一个类，对于模非常量时也能用上述方式做快速幂</p></blockquote><h2 id="模数为常量的快速除法">模数为常量的快速除法</h2><p>主定理：设 <span class="math inline">\(m, l \geq 0, d &gt; 0\)</span> 且满足 <span class="math inline">\(2^{N + l} \leq m \cdot d \leq 2^{N + l} + 2^l\)</span>, 则对于 <span class="math inline">\(0 \leq n &lt; 2^N\)</span> 成立 <span class="math inline">\(\lfloor \frac{n}{d} \rfloor = \lfloor \frac{n m}{2^{N + l}}\rfloor\)</span>（证明自行推导或看原始论文或看 SuperSodaSea 的文章）</p><p>从而可以取 <span class="math inline">\(l = \lceil \log_2 d \rceil\)</span> 保证区间非空，然后不断的减小 <span class="math inline">\(l\)</span>，从而让 <span class="math inline">\(m\)</span> 变小。然后注意到最初 <span class="math inline">\(l\)</span> 的取值会导致最终 <span class="math inline">\(m \leq \frac{2^{N + l} + 2^{l}}{d} &lt; 2^{N + 1}\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ctz</span><span class="hljs-params">(T x)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-number">4</span> == <span class="hljs-keyword">sizeof</span> (T))</span> <span class="hljs-keyword">return</span> __<span class="hljs-title">builtin_ctz</span><span class="hljs-params">(x)</span></span>;<br>  <span class="hljs-keyword">return</span> __builtin_ctzll(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function">std::pair&lt;<span class="hljs-keyword">int</span>, T2&gt; <span class="hljs-title">chooseMultiplier</span><span class="hljs-params">(T d)</span> </span>&#123;<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> bitLen = __CHAR_BIT__ * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T);<br>  <span class="hljs-keyword">if</span> ((d &amp; -d) == d) <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">ctz</span>(d), <span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>)&#125;;<br>  T2 lb = <span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>) &lt;&lt; bitLen;<br>  <span class="hljs-keyword">int</span> l = std::__lg(d - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; (lb &lt;&lt; l) / d != (lb + <span class="hljs-number">1</span> &lt;&lt; l) / d) --l;<br>  ++l;<br>  <span class="hljs-keyword">return</span> &#123;l, (lb + <span class="hljs-number">1</span> &lt;&lt; l) / d&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">unsigned</span> x;<br>  std::cin &gt;&gt; x;<br>  <span class="hljs-keyword">auto</span> [l, m] = <span class="hljs-built_in">chooseMultiplier</span>(x);<br>  std::cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后确实有 <span class="math inline">\(m \geq 2^N\)</span> 的时候，例如 <span class="math inline">\(d = 7\)</span>，因此可以把 <span class="math inline">\(n m = n(m - 2^N) + n \cdot 2^N\)</span>。即另 <span class="math inline">\(t = n (m - 2^N) / 2^N\)</span>，然后最终答案就是 <span class="math inline">\((n + t) / 2^l\)</span>。但是若 <span class="math inline">\(n\)</span> 很大，还是有溢出的风险。因此可以写成 <code>(n - t &gt;&gt; 1) + t &gt;&gt; (l - 1)</code>（注意此处 <span class="math inline">\(n \geq t\)</span> 恒成立）。注意此时还有一个风险：<span class="math inline">\(l = 0\)</span>，但是这不可能因为此时 <span class="math inline">\(m &lt; 2^N\)</span>。另外注意到若 <span class="math inline">\(d\)</span> 是 2 的倍数，那么我们可以计算 <span class="math inline">\((n / 2) / (d / 2)\)</span>，这么我们就可以保证 <span class="math inline">\(\frac{n}{2} m &lt; 2^{2N}\)</span> 了。因此最终代码生成的方式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cerr(x) std::cerr &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ctz</span><span class="hljs-params">(T x)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-number">4</span> == <span class="hljs-keyword">sizeof</span> (T))</span> <span class="hljs-keyword">return</span> __<span class="hljs-title">builtin_ctz</span><span class="hljs-params">(x)</span></span>;<br>  <span class="hljs-keyword">return</span> __builtin_ctzll(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function">std::pair&lt;<span class="hljs-keyword">int</span>, T2&gt; <span class="hljs-title">chooseMultiplier</span><span class="hljs-params">(T d)</span> </span>&#123;<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> bitLen = __CHAR_BIT__ * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T);<br>  <span class="hljs-keyword">if</span> ((d &amp; -d) == d) <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">ctz</span>(d), <span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>)&#125;;<br>  T2 lb = <span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>) &lt;&lt; bitLen;<br>  <span class="hljs-keyword">int</span> l = std::__lg(d - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; (lb &lt;&lt; l) / d != (lb + <span class="hljs-number">1</span> &lt;&lt; l) / d) --l;<br>  ++l;<br>  <span class="hljs-keyword">return</span> &#123;l, (lb + <span class="hljs-number">1</span> &lt;&lt; l) / d&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateUnsignedDivision</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> d)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(d != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">int</span> dd = <span class="hljs-built_in">ctz</span>(d);<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;inline uint32_t div&quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot;(uint32_t n) &#123;\n&quot;</span>;<br>  <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">31</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;  return n &gt;= &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span> &lt;&lt; dd) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;  return n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (dd) std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&gt; &quot;</span> &lt;&lt; dd;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">auto</span> [l, m] = chooseMultiplier&lt;<span class="hljs-keyword">uint32_t</span>, <span class="hljs-keyword">uint64_t</span>&gt;(d);<br>    <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">1ull</span> &lt;&lt; <span class="hljs-number">32</span>) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;  return &quot;</span> &lt;&lt; m  &lt;&lt; <span class="hljs-string">&quot;ull * n &gt;&gt; &quot;</span> &lt;&lt; l + <span class="hljs-number">32</span> &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dd == <span class="hljs-number">0</span>) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;  uint32_t t = &quot;</span> &lt;&lt; (m - (<span class="hljs-number">1ull</span> &lt;&lt; <span class="hljs-number">32</span>)) &lt;&lt; <span class="hljs-string">&quot;ull * n &gt;&gt; 32;\n&quot;</span>;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;  return (n - t &gt;&gt; 1) + t&quot;</span>;<br>      <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">1</span>) std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&gt; &quot;</span> &lt;&lt; l - <span class="hljs-number">1</span>;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">auto</span> [l2, m2] = chooseMultiplier&lt;<span class="hljs-keyword">uint32_t</span>, <span class="hljs-keyword">uint64_t</span>&gt;(d &gt;&gt; <span class="hljs-number">1</span>);<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;  return &quot;</span> &lt;&lt; m2  &lt;&lt; <span class="hljs-string">&quot;ull * (n &gt;&gt; 1) &gt;&gt; &quot;</span> &lt;&lt; l2 + <span class="hljs-number">32</span> &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;&#125;\n\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// only for gcc and x86_64</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateUnsignedDivisionAsm</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> d)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(d != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">int</span> dd = <span class="hljs-built_in">ctz</span>(d);<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;inline uint32_t div&quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot;Asm(uint32_t n) &#123;\n&quot;</span>;<br>  <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">31</span>) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;  return n &gt;= &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (d == (<span class="hljs-number">1</span> &lt;&lt; dd)) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;  return n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (dd) std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&gt; &quot;</span> &lt;&lt; dd;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">auto</span> [l, m] = chooseMultiplier&lt;<span class="hljs-keyword">uint32_t</span>, <span class="hljs-keyword">uint64_t</span>&gt;(d);<br>    <span class="hljs-keyword">if</span> (m &lt; (<span class="hljs-number">1ull</span> &lt;&lt; <span class="hljs-number">32</span>)) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;  return muluh(&quot;</span> &lt;&lt; m  &lt;&lt; <span class="hljs-string">&quot;, n)&quot;</span>;<br>      <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">0</span>) std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&gt; &quot;</span> &lt;&lt; l;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dd == <span class="hljs-number">0</span>) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;  uint32_t t = &quot;</span> &lt;&lt; <span class="hljs-string">&quot;muluh(&quot;</span> &lt;&lt; m - (<span class="hljs-number">1ull</span> &lt;&lt; <span class="hljs-number">32</span>) &lt;&lt; <span class="hljs-string">&quot;, n);\n&quot;</span>;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;  return (n - t &gt;&gt; 1) + t&quot;</span>;<br>      <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">1</span>) std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&gt; &quot;</span> &lt;&lt; l - <span class="hljs-number">1</span>;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">auto</span> [l2, m2] = chooseMultiplier&lt;<span class="hljs-keyword">uint32_t</span>, <span class="hljs-keyword">uint64_t</span>&gt;(d &gt;&gt; <span class="hljs-number">1</span>);<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;  return muluh(&quot;</span> &lt;&lt; m2  &lt;&lt; <span class="hljs-string">&quot;, n &gt;&gt; 1)&quot;</span>;<br>      <span class="hljs-keyword">if</span> (l2 &gt; <span class="hljs-number">0</span>) std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&gt; &quot;</span> &lt;&lt; l2;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;&#125;\n\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">16</span>; ++i) &#123;<br>    <span class="hljs-built_in">generateUnsignedDivision</span>(i);<br>    <span class="hljs-built_in">generateUnsignedDivisionAsm</span>(i);<br>  &#125;<br>  <span class="hljs-keyword">uint32_t</span> x = <span class="hljs-number">6700417</span>;<br>  <span class="hljs-comment">// std::cin &gt;&gt; x;</span><br>  <span class="hljs-built_in">generateUnsignedDivision</span>(x);<br>  <span class="hljs-built_in">generateUnsignedDivisionAsm</span>(x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>测试后发现跟预期的一样，<strong>自己写的并没有默认跑的快，即 以上所有代码仅有理论意义</strong>，那么我们就止步于此了吗？</p><h2 id="模数非常量的快速除法和快速模乘">模数非常量的快速除法和快速模乘</h2><blockquote><p><strong>必须承认一点</strong>：无论被除数 d 是否为常量，我们都不可能比默认的快，但是如果 d 为变量，但是会被多次使用，那么我们就大概率可以比默认的快，这部分其实还要部分归功于 lambda 函数（否则要用函数指针，写起来十分麻烦），但是这部分如何做成内联呢）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cerr(x) std::cerr &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NewLine std::cerr &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> IntLong = std::<span class="hljs-keyword">enable_if_t</span>&lt;<br>    std::is_same_v&lt;<span class="hljs-keyword">int32_t</span>, T&gt;  ||<br>    std::is_same_v&lt;<span class="hljs-keyword">uint32_t</span>, T&gt; ||<br>    std::is_same_v&lt;<span class="hljs-keyword">int64_t</span>, T&gt;  ||<br>    std::is_same_v&lt;<span class="hljs-keyword">uint64_t</span>, T&gt;&gt;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">using</span> Twice = std::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-number">2</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T) == <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T2)&gt;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> check = IntLong&lt;T&gt;&gt;<br><span class="hljs-keyword">int</span> <span class="hljs-built_in">ctz</span>(T x) &#123;<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in"><span class="hljs-keyword">constexpr</span></span>(<span class="hljs-number">4</span> == <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T)) <span class="hljs-keyword">return</span> __builtin_ctz(x);<br>  <span class="hljs-keyword">return</span> __builtin_ctzll(x);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> check = Twice&lt;T,T2&gt;&gt;<br>std::pair&lt;<span class="hljs-keyword">int</span>, T2&gt; <span class="hljs-built_in">chooseMultiplier</span>(T d) &#123;<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> bitLen = __CHAR_BIT__ * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T);<br>  <span class="hljs-keyword">if</span> ((d &amp; -d) == d) <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">ctz</span>(d), <span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>)&#125;;<br>  T2 lb = <span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>) &lt;&lt; bitLen;<br>  <span class="hljs-keyword">int</span> l = std::__lg(d - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; (lb &lt;&lt; l) / d != (lb + <span class="hljs-number">1</span> &lt;&lt; l) / d) --l;<br>  ++l;<br>  <span class="hljs-keyword">return</span> &#123;l, (lb + <span class="hljs-number">1</span> &lt;&lt; l) / d&#125;;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> check = Twice&lt;T,T2&gt;&gt;<br>std::function&lt;<span class="hljs-built_in">T</span>(T)&gt; <span class="hljs-built_in">getDivFun</span>(T d) &#123;<br>  <span class="hljs-built_in">assert</span>(d != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> bitLen = __CHAR_BIT__ * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T);<br>  <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-built_in">T</span>(<span class="hljs-number">1</span>) &lt;&lt; bitLen - <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> [d](T n) &#123;<br>      <span class="hljs-keyword">return</span> n &gt;= d;<br>    &#125;;<br>  &#125;<br>  <span class="hljs-keyword">int</span> dd = <span class="hljs-built_in">ctz</span>(d);<br>  <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span> &lt;&lt; dd) &#123;<br>    <span class="hljs-keyword">return</span> [dd](T n) &#123;<br>      <span class="hljs-keyword">return</span> n &gt;&gt; dd;<br>    &#125;;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> [l, m] = chooseMultiplier&lt;T, T2&gt;(d);<br>  <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>) &lt;&lt; bitLen) &#123;<br>    <span class="hljs-keyword">return</span> [mf = m, lf = l + bitLen](T n) &#123;<br>      <span class="hljs-keyword">return</span> mf * n &gt;&gt; lf;<br>    &#125;;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (dd == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> [mf = m - (<span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>) &lt;&lt; bitLen), lf = l - <span class="hljs-number">1</span>](T n) &#123;<br>        T t = mf * n &gt;&gt; __CHAR_BIT__ * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T);<br>        <span class="hljs-keyword">return</span> (n - t &gt;&gt; <span class="hljs-number">1</span>) + t &gt;&gt; lf;<br>      &#125;;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> [mf = m - (<span class="hljs-built_in">T2</span>(<span class="hljs-number">1</span>) &lt;&lt; bitLen)](T n) &#123;<br>        T t = mf * n &gt;&gt; __CHAR_BIT__ * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (T);<br>        <span class="hljs-keyword">return</span> (n - t &gt;&gt; <span class="hljs-number">1</span>) + t;<br>      &#125;;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> [l2, m2] = chooseMultiplier&lt;T, T2&gt;(d &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> [mf = m2, lf = l2 + bitLen](T n) &#123;<br>    <span class="hljs-keyword">return</span> mf * (n &gt;&gt; <span class="hljs-number">1</span>) &gt;&gt; lf;<br>  &#125;;<br>&#125;<br><br><span class="hljs-function">std::mt19937 <span class="hljs-title">rnd</span><span class="hljs-params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>;<br><span class="hljs-function">std::mt19937_64 <span class="hljs-title">rnd64</span><span class="hljs-params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span> <span class="hljs-keyword">final</span> &#123;</span><br>  std::chrono::high_resolution_clock::time_point start_;<br>  std::string name_;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Timer</span>(std::string name = &#123;&#125;) : <span class="hljs-built_in">start_</span>(std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>()), <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br>  ~<span class="hljs-built_in">Timer</span>() &#123;<br>    <span class="hljs-keyword">auto</span> elapsedTime = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>() - start_;<br>    std::cerr &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; std::fixed &lt;&lt; <span class="hljs-string">&quot;[Time used: &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;] &quot;</span> &lt;&lt; elapsedTime.<span class="hljs-built_in">count</span>() / <span class="hljs-number">1&#x27;000&#x27;000.0</span> &lt;&lt; <span class="hljs-string">&quot;ms\n&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">div14</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">4908534053ull</span> * (n &gt;&gt; <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">35</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e7</span> + <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// test for mod = 14</span><br>  &#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">uint32_t</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) x = <span class="hljs-built_in">rnd</span>();<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> modConst = <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">uint32_t</span> mod = <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">div14</span>(x) != x / mod) &#123;<br>        std::cerr &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">div14</span>(x) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; x / mod &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>    &#125;<br>    &#123;<br>      <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;mod14&quot;</span>)</span></span>;<br>      <span class="hljs-keyword">uint64_t</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sum += <span class="hljs-built_in">div14</span>(x);<br>      <span class="hljs-built_in">cerr</span>(sum);<br>    &#125;<br>    &#123;<br>      <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;default&quot;</span>)</span></span>;<br>      <span class="hljs-keyword">uint64_t</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sum += x / mod;<br>      <span class="hljs-built_in">cerr</span>(sum);<br>    &#125;<br>    &#123;<br>      <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;const default&quot;</span>)</span></span>;<br>      <span class="hljs-keyword">uint64_t</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sum += x / modConst;<br>      <span class="hljs-built_in">cerr</span>(sum);<br>    &#125;<br>  &#125;<br>  NewLine;<br>  <span class="hljs-comment">// test for uint32</span><br>  &#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">uint32_t</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) x = <span class="hljs-built_in">rnd</span>();<br>    <span class="hljs-keyword">uint32_t</span> mod = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((mod = <span class="hljs-built_in">rnd</span>()) == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> f = getDivFun&lt;<span class="hljs-keyword">uint32_t</span>, <span class="hljs-keyword">u_int64_t</span>&gt;(mod);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(x) != x / mod) &#123;<br>        std::cerr &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">f</span>(x) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; x / mod &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>    &#125;<br>    &#123;<br>      <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;default&quot;</span>)</span></span>;<br>      <span class="hljs-keyword">uint64_t</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sum += x / mod;<br>      <span class="hljs-built_in">cerr</span>(sum);<br>    &#125;<br>    &#123;<br>      <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;fast?&quot;</span>)</span></span>;<br>      <span class="hljs-keyword">uint64_t</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sum += <span class="hljs-built_in">f</span>(x);<br>      <span class="hljs-built_in">cerr</span>(sum);<br>    &#125;<br>  &#125;<br>  NewLine;<br>  <span class="hljs-comment">// test for uint64</span><br>  &#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">uint64_t</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) x = <span class="hljs-built_in">rnd</span>();<br>    <span class="hljs-keyword">uint64_t</span> mod = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((mod = <span class="hljs-built_in">rnd64</span>()) == <span class="hljs-number">0</span>);<br>    mod = mod % INT_MAX; <span class="hljs-comment">// avoid answer too small</span><br>    <span class="hljs-keyword">auto</span> f = getDivFun&lt;<span class="hljs-keyword">u_int64_t</span>, <span class="hljs-keyword">__uint128_t</span>&gt;(mod);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(x) != x / mod) &#123;<br>        std::cerr &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">f</span>(x) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; x / mod &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>    &#125;<br>    &#123;<br>      <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;default&quot;</span>)</span></span>;<br>      <span class="hljs-keyword">__uint128_t</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sum += x / mod;<br>      <span class="hljs-built_in">cerr</span>(<span class="hljs-built_in">uint64_t</span>(sum &gt;&gt; <span class="hljs-number">64</span>));<br>      <span class="hljs-built_in">cerr</span>(<span class="hljs-built_in">uint64_t</span>(sum));<br>    &#125;<br>    &#123;<br>      <span class="hljs-function">Timer <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;fast?&quot;</span>)</span></span>;<br>      <span class="hljs-keyword">__uint128_t</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sum += <span class="hljs-built_in">f</span>(x);<br>      <span class="hljs-built_in">cerr</span>(<span class="hljs-built_in">uint64_t</span>(sum &gt;&gt; <span class="hljs-number">64</span>));<br>      <span class="hljs-built_in">cerr</span>(<span class="hljs-built_in">uint64_t</span>(sum));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实测代码发现 Mac M1 上比不过，但是其他指令集表现还不错</p><h2 id="遗留问题">遗留问题</h2><ul><li>关于 <code>muluh</code> 所有主流指令集的汇编写法</li><li>lambda 如何变成内联函数，有没有可能用函数指针做多情况下内联（貌似此处没有必要）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu 踩坑日记</title>
    <link href="/ubuntu/"/>
    <url>/ubuntu/</url>
    
    <content type="html"><![CDATA[<p>Mac M1 上装 ubuntu 的想法已经破灭（不会再去浪费时间了，最多花钱用 PD），Windows 的 Hyper-V 也弃坑了，双系统也算了。最终选择了 WMware Player。</p><span id="more"></span><p>微软开源三板斧：github, vscode, wsl 用的挺好的。但是 wsl 无法开启音视频，从而选择了只能选择双系统或者虚拟机了。考虑到双系统还是不方便。WMware Player 有免费版，所以还是 WMware Player 吧。而且虚拟机好迁移。</p><blockquote><p>后来我写好脚本做系统安装完后的初始化，然后把虚拟机备份。供换电脑使用</p></blockquote><h2 id="zsh-配置">zsh 配置</h2><p>先参考 <a href="https://segmentfault.com/a/1190000039860436">oh my zsh 安装详解</a>，再看 <a href="https://zhuanlan.zhihu.com/p/62419420">字体安装</a>，然后 terminal 选择 custom command: <code>/usr/bin/zsh</code></p><p>添加下面配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ZSH_THEME=&quot;essembeh&quot;<br>plugins=(git zsh-syntax-highlighting zsh-autosuggestions)<br>DISABLE_AUTO_UPDATE=&quot;true&quot;<br></code></pre></td></tr></table></figure><h2 id="升级">升级</h2><ul><li>18.04 --&gt; 20.04：<code>sudo sed -i 's/binoic/focal/g' /etc/apt/sources.list</code> 然后 <code>sudo apt update</code> 再 <code>sudo apt -y dist-upgrade</code></li><li>20.04 --&gt; 22.04 同理（<code>s/binoic/focal/g</code> 改成 <code>s/focal/jammy/g</code>），<strong>有风险</strong></li></ul><h2 id="低版本-ubuntu-安装高版本软件">低版本 Ubuntu 安装高版本软件</h2><ul><li><a href="https://codeantenna.com/a/ioXufiRy3V">Ubuntu下安装高版本clang-format 11, 12, 13</a></li></ul><h2 id="perf-的使用">perf 的使用</h2><p>首先直接输入 perf 会提示你安装一些 tool，安装好之后， - 设置 <code>/etc/sysctl.conf</code>，添加一句 <code>kernel.perf_event_paranoid = -1</code>，然后 <code>sudo sysctl -p /etc/sysctl.conf</code>， - 再 <code>sudo sh -c "echo 0 &gt; /proc/sys/kernel/kptr_restrict"</code>，不然没有符号</p><p>使用和现实可以用 <a href="https://github.com/jlfwong/speedscope/wiki/Importing-from-perf-(linux)">speedscope</a> 或者 <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> 可以参考 <a href="https://www.cnblogs.com/gnivor/p/12535005.html">Linux笔记-性能调优工具perf</a></p><h2 id="vpn-配置">VPN 配置</h2><ul><li>安装 openfortivpn</li><li>编辑 <code>/etc/openfortivpn/config</code> 如下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">host =<br>port = 10443<br>username =<br>password =<br>trusted-cert = 这行先不用写, 第一次会报错, 说要把一个 cert 字串加入到 trusted-cert 中, 到时加这一行, copy-paste 屏幕中的 cert<br></code></pre></td></tr></table></figure><h2 id="弱网环境">弱网环境</h2><p>查看当前的网络情况</p><p><code>nload -m</code> 一般会出现一个 <code>Device lo [127.0.0.1]</code> 还有另外一个 Device（这一个后面会用，比如我的是 <code>wlp1s0</code>），如果没有安装就 sudo apt 安装一下。</p><p>然后进行弱网设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo tc qdisc add dev wlp1s0 root netem delay 500ms       #设置500ms的延迟<br>sudo tc qdisc add dev wlp1s0 root netem loss 50%          #设置50%的丢包率<br>sudo tc qdisc add dev wlp1s0 root netem delay 500ms loss 50%  #同时设置<br>sudo tc qdisc del dev wlp1s0 root               #删除设置<br></code></pre></td></tr></table></figure><h2 id="apt-key">apt-key</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-key list<br>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys  xxxxxx<br></code></pre></td></tr></table></figure><blockquote><p><code>keyserver.ubuntu.com</code> 有时需要改成 <code>ktp://keyserver.ubuntu.com:80</code> 或者 <code>ktps://pgp.mit.edu</code>，可参考这里：<a href="https://superuser.com/questions/1250681/why-am-i-unable-to-fetch-pgp-keys-from-commandline" class="uri">https://superuser.com/questions/1250681/why-am-i-unable-to-fetch-pgp-keys-from-commandline</a></p></blockquote><p><a href="https://www.jianshu.com/p/9580f677ee70">ubuntu添加源后，更新提示缺少公钥</a>，详细可参考<a href="https://manpages.ubuntu.com/manpages/xenial/man8/apt-key.8.html">官方文档</a></p><p>再不行的话: <a href="https://einverne.github.io/post/2019/09/gpg-keyserver-receive-failed-server-indicated-a-failure.html" class="uri">https://einverne.github.io/post/2019/09/gpg-keyserver-receive-failed-server-indicated-a-failure.html</a></p><h2 id="gpg">GPG</h2><p><a href="https://zhuanlan.zhihu.com/p/348007824">GPG 入门</a> 和 <a href="https://zhuanlan.zhihu.com/p/76861431">github 上使用</a></p><h2 id="开机自启动">开机自启动</h2><p>在 <code>/etc/init.d/</code> 中新建一个 <code>my.sh</code>，然后参考其它的 <code>.sh</code> 的写法，写好之后记得 <code>./my.sh</code> 跑一下确保本身无误（没权限的话 <code>chmod +x</code>）</p><p>参考：<a href="https://www.cnblogs.com/Areas/p/13439000.html" class="uri">https://www.cnblogs.com/Areas/p/13439000.html</a></p><h2 id="system-program-problem-detected">system program problem detected</h2><p><code>out of sight, out of mind</code>，不让它显示就行了</p><p>先删除 <code>/var/crash/</code> 中的所有文件，再把 <code>/etc/default/apport</code> 中的 <code>enable=1</code> 改成 <code>enable=0</code></p><h2 id="删除安装失败的包">删除安装失败的包</h2><p><code>sudo dpkg --configure -a</code> 查看安装失败的包，删除掉它们 <code>sudo dpkg --remove --force-remove-reinstreq package_name</code></p><p>也可参考 <a href="https://ubuntuqa.com/article/10754.html" class="uri">https://ubuntuqa.com/article/10754.html</a> 操作</p><h2 id="hyper-v弃">Hyper-V（弃）</h2><blockquote><p>Windows 10 家庭普通版也能使用，网上有<a href="https://www.bilibili.com/read/cv4542085">简单教程</a></p></blockquote><ul><li>Hyper-V 全屏：https://www.jianshu.com/p/22cffcc4d5b9</li><li>Hyper-V 物理机/虚拟机 共享复制粘贴：https://www.cnblogs.com/kendoziyu/p/14741360.html</li></ul><blockquote><p>最后网络把我搞的心态爆炸，直接全给它删了，毁灭吧，烦了</p></blockquote><h2 id="双系统弃">双系统（弃）</h2><ol type="1"><li>修改 ubuntu 的 <code>/etc/default/grub</code> 的默认选择延迟为 5s。然后 <code>sudo update-grub</code> &gt; 如果要默认 windows 可以修改对应的 BIOS 为 windows 优先启动，启动 Ubuntu 可以通过 BIOS 进入</li><li>更换上交镜像源, 或者中科大镜像源（直接再 <code>Software &amp; Update</code> 中选即可，不用手动改 <code>/etc/apt/sources.list</code>）</li><li>apt update, apt install, apt upgrade</li><li>安装 vscode, curl, vim, xsel（剪切版）, htop, tmux, perf, sagemath, haskell, python</li><li><code>alias open=nautilus</code>（ubuntu 22.04 不再需要）</li><li>利用 scp 文件传输（目标机器需要开启端口） <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install openssh-server<br>sudo ufw allow 22<br></code></pre></td></tr></table></figure> 然后保持两台电脑在一个局域网上然后查看各自 ip，然后推流： <code>scp -r xxx/ username@xxx.xxx.xxx.xxx:~</code> 就可以把本机 xxx/ 下所有文件传输到对应 ip 的机器上。也可以拉流：<code>scp -r username@xxx.xxx.xxx.xxx:xxx/ .</code></li><li>kill 杀死进程需要配合 top 查看 pid，<strong>但是 pkill 可以直接根据进程名杀死进程</strong></li><li>按住一个 htop 比 top 好用不少，mac 上也可以用 homebrew 安装</li><li>Ubuntu 显示时间到秒：<code>gsettings set org.gnome.desktop.interface clock-show-seconds true</code></li><li><del><a href="https://cloud.tencent.com/developer/article/1672725">bash 中显示 git 分支</a> 效果很差，没啥意义</del></li></ol><blockquote><p><code>sudo apt-cache search</code> 是个好东西， <code>sudo apt install -y</code> 也是</p></blockquote><h3 id="笔记本设置盒盖不休眠">笔记本设置盒盖不休眠</h3><p><a href="https://www.jianshu.com/p/3fe469fc60c9" class="uri">https://www.jianshu.com/p/3fe469fc60c9</a></p><p>如果设置了不用 笔记本 的显示器，貌似就不用这么设置了</p><h3 id="无法外接显示器">无法外接显示器</h3><p><a href="https://askubuntu.com/a/1251457" class="uri">https://askubuntu.com/a/1251457</a></p><h3 id="网络问题">网络问题</h3><p>如果无法连接 wifi，三种方式联网</p><ul><li><p>有线</p></li><li><p>安卓手机 Usb 连接到电脑，然后手机个人热点里设置 usb 共享网络</p></li><li><p>安卓手机蓝牙连接电脑，然后手机个人热点里设置蓝牙共享网络</p></li><li><p>ubuntu 18.04 切记关闭 secure boot</p></li><li><p><a href="https://blog.csdn.net/tianzhenba/article/details/119331967">安装驱动</a></p></li><li><p><a href="https://blog.csdn.net/qq_43557907/article/details/122471195">有 wifi 图标无 wifi 列表</a></p></li></ul><p>也可以连好网络后可参考 <a href="https://juejin.cn/post/7022521662880874527" class="uri">https://juejin.cn/post/7022521662880874527</a> 再不行可参考 <a href="https://blog.rottenwifi.com/ubuntu-no-wifi-adapter-found/" class="uri">https://blog.rottenwifi.com/ubuntu-no-wifi-adapter-found/</a>，可能需要安装：backport-iwlwifi-dkms，如果还是不行，建议重新换个镜像安装（一般是硬件不匹配导致的），<strong>是在不行换镜像</strong></p><h3 id="安装完无法进入系统">安装完无法进入系统</h3><p>可参考：<a href="https://www.dell.com/support/kbdoc/zh-cn/000123893/%E6%89%8B%E5%8A%A8-nomodeset-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC-%E8%A1%8C%E9%80%89%E9%A1%B9-%E7%94%A8%E4%BA%8E-linux-%E5%BC%95%E5%AF%BC" class="uri">https://www.dell.com/support/kbdoc/zh-cn/000123893/%E6%89%8B%E5%8A%A8-nomodeset-%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC-%E8%A1%8C%E9%80%89%E9%A1%B9-%E7%94%A8%E4%BA%8E-linux-%E5%BC%95%E5%AF%BC</a></p><blockquote><p>如果还不行，可以尝试进入 BIOS 关闭 safe boot</p></blockquote><h3 id="重装-win10-后ubuntu-找不到了">重装 win10 后，Ubuntu 找不到了</h3><p>可参考：<a href="https://bktus.com/zh-cn/archives/2920" class="uri">https://bktus.com/zh-cn/archives/2920</a></p><h3 id="僵尸鼠标">僵尸鼠标</h3><p>开启后多一个僵尸鼠标：<a href="https://forum.ubuntu.org.cn/viewtopic.php?t=491536" class="uri">https://forum.ubuntu.org.cn/viewtopic.php?t=491536</a></p><h3 id="登陆后花屏">登陆后花屏</h3><p>可参考 <a href="https://blog.csdn.net/supe_tan/article/details/78336133" class="uri">https://blog.csdn.net/supe_tan/article/details/78336133</a></p><h3 id="ubuntu-开机慢">Ubuntu 开机慢</h3><p>参考 <a href="https://blog.csdn.net/qq_35251760/article/details/111037280" class="uri">https://blog.csdn.net/qq_35251760/article/details/111037280</a></p><h3 id="windows-时间差了-8h">windows 时间差了 8h</h3><p>管理员权限打开 PowerShell 然后输入： <code>reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1</code></p><p>参考：<a href="https://www.jianshu.com/p/cf445a2c55e8" class="uri">https://www.jianshu.com/p/cf445a2c55e8</a></p><h3 id="拓展分区大小">拓展分区大小</h3><p>用着用着就觉得 Ubuntu 比 Windows 用的多，而且给同事一个用户账号导致空间不足，然后我去查了一下分区方式。总结下来步骤如下</p><ul><li>win + r 打开 diskmgmt.msc 然后压缩出一块（未分配的）空间出来</li><li>找一个有 ubuntu 的 U 盘作为引导盘，然后开机的时候进入 BIOS，然后调整 U 盘作为启动盘</li><li>然后它默认有 gparted，然后 sudo gparted 就可以拓展 Ubuntu 的分区，点确定。重启即可</li></ul><h3 id="小功能合集">小功能合集</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">df # 查看各个分区大小<br>find . -type f | wc -l  #统计文件个数 https://blog.csdn.net/e15273/article/details/78824570<br>adduser xxx # 创建用户，并且创建用户目录<br>passwd xxx<br></code></pre></td></tr></table></figure><h2 id="vim-入门">Vi(m) 入门</h2><p>所有类 Unix 系统都自带 vi，所以学习 vi 收益满满！</p><blockquote><p>参考：<a href="https://codeshellme.github.io/2020/04/vim-use/">如何高效使用Vim</a>，<a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim | 菜鸟教程</a></p></blockquote><h3 id="vim-工作模式图解">vi(m) 工作模式图解</h3><figure><img src="vim-vi-workmodel.png" alt="vimWorkMod" /><figcaption aria-hidden="true">vimWorkMod</figcaption></figure><div class="line-block">常见命令（区分大小写) | 含义 |<br />-- --------------------------------- | ---------------------------------------------------- |<br /><code>gg</code> | 移动到当前文件的第一行 |<br /><code>G</code> | 移动到当前文件的最后一行 |<br /><code>M</code> | 移动到当前文件的中间一行 |<br /><code>Ctrl + o</code> | 移动到上一次编辑的地方 |<br /><code>:n</code> ， 其中 n 为数字 | 输入一个 <code>:</code>，再输入一个 <code>数字</code>，按回车，快速跳到某一行 |<br /><code>ndd</code>，其中 n 为数字（不写默认为 1） | 删除光标所在的行，并且内容在剪切板 |<br /><code>nyy</code>，其中 n 为数字（不写默认为 1） | 复制光标所在的行，并且内容在剪切板 |<br /><code>D</code> | 删除 <code>光标</code> 到行 <code>末尾</code> 所有的内容，并且内容在剪切板 |<br /><code>p</code> | 粘贴剪切板的内容到光标处 |<br /><code>/word</code> | 向光标之下寻找一个名称为 word 的字符串 |<br /><code>?word</code> | 向光标之上寻找一个字符串名称为 word 的字符串。 |<br /><code>n</code> | 这个 n 是英文按键。继续搜索下一个目标 |<br /><code>N</code> | 这个 N 是英文按键。与 n 刚好相反 |<br /><code>Ctrl + v</code> | 进入列选择模式 |<br /><code>Shift + v</code> | 进入行选择模式 |<br /><code>u</code> | 复原前一个动作 |<br /><code>Ctrl+r</code> | 重做上一个动作 |<br /><code>Ctrl+n</code> | 常规（Normal）补全 |<br /><code>Ctrl+o</code> | 全能（Omni）补全 |</div><h3 id="vimrc-超简洁设置"><code>.vimrc</code> 超简洁设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">syntax on    &quot; 语法高亮<br>set nu       &quot; 行数显示<br>set ts=4     &quot; tab 宽度<br>set spell    &quot; 语法拼写检测<br>set noexpandtab       &quot; 不将 tab 转换成空格<br></code></pre></td></tr></table></figure><h3 id="vim键盘图">vi(m)键盘图</h3><figure><img src="vi-vim.png" alt="vim-vim" /><figcaption aria-hidden="true">vim-vim</figcaption></figure><h3 id="vim-命令思维导图">vi(m) 命令思维导图</h3><figure><img src="vim.png" alt="vim" /><figcaption aria-hidden="true">vim</figcaption></figure><h2 id="linux-shell-入门">Linux Shell 入门</h2><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p><blockquote><p>参考：<a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程 | 菜鸟教程</a>，<a href="https://zhuanlan.zhihu.com/p/65106362">这些Shell编程必备知识你都掌握了吗？</a></p></blockquote><h3 id="hello-shell">Hello Shell</h3><p><code>vim test.sh</code> 编辑下面内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo &quot;Hello Shell &quot;<br></code></pre></td></tr></table></figure><p><code>esc</code> + <code>:wq</code> 保存，执行下面命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使脚本具有执行权限</span><br>$ chmod +x test.sh<br><span class="hljs-comment">#执行脚本，若报错则输入 chmod u+x test.sh</span><br>$ ./test.sh<br><span class="hljs-comment">#无执行权限时</span><br>$ sh ./test.sh<br></code></pre></td></tr></table></figure><h3 id="shell-变量">Shell 变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello=123 # 变量定义<br>readonly my_blog=&quot;izlyforever.com&quot; #只读变量（常量）定义<br>echo $my_blog   #变量引用方式一，不推荐<br>echo $&#123;my_blog&#125; #变量引用方式二，推荐<br>for skill in C++ Python SageMath; do<br>    echo &quot;I am good at $&#123;skill&#125;Script&quot;<br>done<br>unset my_blog   #删除变量<br></code></pre></td></tr></table></figure><blockquote><p>变量定义 <code>=</code> 两边不能有空格！</p></blockquote><h3 id="shell-字符串">Shell 字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">myBlog=&#x27;izlyforever.com&#x27; #单引号里的任何字符都会原样输出, 不支持转义<br>str=&quot;My Blog is \&quot;$myBlog\&quot;! \n&quot;<br>echo -e $str # -e 开启转义<br>echo &#x27;hello, &#x27; $&#123;myBlog&#125; &quot; Welcome!&quot; #单引号双引号都可以做字符拼接<br>echo $&#123;#myBlog&#125; #获取字符串长度<br>echo $&#123;myBlog:0:6&#125;<br></code></pre></td></tr></table></figure><h3 id="shell-传递参数">Shell 传递参数</h3><ul><li><code>$n</code>：传入参数，例如：<code>$0 $1 $2</code> 分别表示，脚本名，第一个参数，第二个参数</li><li><code>$#</code>：脚本后面跟的参数个数（不包含脚本名)</li><li><code>$@</code>：所有参数，并且可以被遍历</li><li><code>$*</code>：所有参数</li><li><code>\$$</code>：当前脚本的进程 ID (没有 <code>\</code>)</li><li><code>$?</code>：上一条命令的退出状态</li></ul><h3 id="shell-数组">Shell 数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">array=(A B &quot;cpp&quot; D)<br>echo $&#123;array[2]&#125;<br>echo &quot;数组元素个数为: $&#123;#array[*]&#125;&quot; # @* 都对应着全部内容<br>echo &quot;数组元素为: $&#123;array[@]&#125;&quot;<br>echo $&#123;array[@]:1:4&#125;<br>echo $&#123;array[@]::3&#125;<br></code></pre></td></tr></table></figure><h3 id="shell-运算符">Shell 运算符</h3><ul><li>算数运算符： <code>+ - * / % = == !=</code></li><li>关系运算符：<code>-eq -ne -ge -lt -gt -le</code></li><li>布尔运算符：<code>! -o -a</code> （取否，or，and）</li><li>逻辑运算符：<code>&amp;&amp; ||</code> ，需要： <code>[[ expr ]]</code></li><li>字符串运算符：<code>= != -z -n $</code></li><li>文件测试运算符：<code>-b -c -d -f -g -k -p -u -r -w -x -s -e</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=11;b=22<br>val=`expr $a + $b`<br>echo &quot;a + b : $val&quot;<br><br>if [ $a == $b ];then<br>  echo &quot;a 等于 b&quot;<br>elif [ $a -gt $b ];then<br>  echo &quot;a 大于 b&quot;<br>elif [ $a -lt $b ];then<br>  echo &quot;a 小于 b&quot;<br>else<br>  echo &quot;没有符合的条件&quot;<br>fi<br><br>if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]];then<br>  echo &quot;返回 true&quot;<br>else<br>  echo &quot;返回 false&quot;<br>fi<br><br>a=&quot;abc&quot;<br>if [ -n $a ];then<br>  echo &quot;-n $a : 字符串长度不为 0&quot;<br>else<br>  echo &quot;-n $a : 字符串长度为 0&quot;<br>fi<br></code></pre></td></tr></table></figure><blockquote><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作</p><p>条件表达式要放在方括号之间，并且要有空格，例如L：<code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></p></blockquote><h3 id="shell-printf-命令">Shell printf 命令</h3><p><code>printf  format-string  [arguments...]</code></p><p>例如： <code>printf "%-8s = %10.4f\n" pi 3.141592653</code></p><blockquote><p><code>%s %c %d %f</code> 都是格式替代符</p><p><code>%-8s</code> 指一个宽度为 8 个字符（<code>-</code> 表示左对齐，没有则表示右对齐），如果不足则自动以空格填充，超过也会将内容全部显示出来。</p></blockquote><h3 id="shell-流程控制">Shell 流程控制</h3><h4 id="条件控制">条件控制</h4><ul><li><p><code>if else-if else</code> 已经在上面例子中提过了。</p></li><li><p><code>case esac</code> 的奇葩写法，吐了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;输入 1 到 4 之间的数字:&#x27;<br>echo &#x27;你输入的数字为:&#x27;<br>read aNum<br>case $aNum in<br>  1)  echo &#x27;你选择了 1&#x27;<br>  ;;<br>  2)  echo &#x27;你选择了 2&#x27;<br>  ;;<br>  3)  echo &#x27;你选择了 3&#x27;<br>  ;;<br>  4)  echo &#x27;你选择了 4&#x27;<br>  ;;<br>  *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;<br>  ;;<br>esac<br></code></pre></td></tr></table></figure><blockquote><p><code>read</code> 输入快乐啊！</p></blockquote></li></ul><h4 id="循环控制for-while-until-break-continue">循环控制：<code>for while until break continue</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 例子来自 https://www.runoob.com/linux/linux-shell-process-control.html</span><br>for str in &#x27;This is a string&#x27;<br>do<br>  echo $str<br>done<br>for((i=1;i&lt;=5;i++));do<br>  echo &quot;这是第 $i 次调用&quot;;<br>done<br><br>echo &#x27;按下 &lt;CTRL-D&gt; 退出&#x27;<br>echo -n &#x27;输入你最喜欢的网站名: &#x27;<br>while read FILM<br>do<br>  echo &quot;是的！$FILM 是一个好网站&quot;<br>done<br><br>a=0<br>until [ ! $a -lt 10 ]<br>do<br>  echo $a<br>  a=`expr $a + 1`<br>done<br></code></pre></td></tr></table></figure><h3 id="shell-函数">Shell 函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">funWithParam()&#123;<br>  echo &quot;第一个参数为 $1 !&quot;<br>  echo &quot;第二个参数为 $2 !&quot;<br>  echo &quot;参数总数有 $# 个!&quot;<br>  echo &quot;作为一个字符串输出所有参数 $* !&quot;<br>&#125;<br>echo &quot;-----函数开始执行-----&quot;<br>funWithParam 3 . 1 4 1 5 9 2<br>echo &quot;-----函数执行完毕-----&quot;<br></code></pre></td></tr></table></figure><h3 id="shell-输入输出重定向和文件包含特别好用">Shell 输入/输出重定向和文件包含(特别好用！)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">echo <span class="hljs-string">&quot;菜鸟教程：www.runoob.com&quot;</span> &gt; users<br>cat users<br>echo <span class="hljs-string">&quot;菜鸟教程：www.runoob.com&quot;</span> &gt;&gt; users<br>cat users<br></code></pre></td></tr></table></figure><ul><li><p>test2.sh 中调用 test.sh：<code>source ./test.sh</code></p></li><li><p>管道运算符 <code>|</code>，是 unix 一个很强大的功能。</p><p>command 1 | command 2</p><p>把第一个命令 command 1 执行的结果作为 command 2 的输入，例如:</p><p><code>$ ls -s|sort -nr</code></p></li></ul><h2 id="获取文件拓展名"><a href="https://www.cnblogs.com/kuangsyx/p/12595888.html">获取文件拓展名</a></h2><h2 id="shell-通配符"><a href="https://www.ibm.com/docs/en/i/7.3?topic=expansions-parameter">Shell 通配符</a></h2><h3 id="linux-工具">Linux 工具</h3><ul><li><a href="https://www.runoob.com/linux/linux-remote-login.html">Linux 远程登录</a></li><li><a href="https://www.runoob.com/linux/linux-forget-password.html">Linux 忘记密码解决方法</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>准备工具</title>
    <link href="/tools/"/>
    <url>/tools/</url>
    
    <content type="html"><![CDATA[<h2 id="windows-工具软件">Windows 工具软件</h2><ul><li>Typora（用于一些复杂的 markdown 内容，例如表格）</li><li>VSCode（登录 Github 账号同步）</li><li>Go （为了使用 cf-tool）</li><li><del>MSYS2 （为了提供 C++17，gdb 和 python)</del></li><li>Git（将 cnblog 源码存到 github）</li><li>WSL（无法访问音视频设备，能力有限，但是依然很有意义），双系统还是必须的</li></ul><blockquote><p>不再推荐 MSYS2，推荐下载带 mingw 的 codeblocks 然后将 mingw 下的 bin 目录添加到环境变量</p></blockquote><h2 id="terminal-设置代理">terminal 设置代理</h2><p>一般 vpn 默认只是网页版本的，然后免费的 vpn 都不提供端口，所以做不了 terminal 的代理设置</p><h3 id="macunix-设置">Mac/Unix 设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export https_proxy=127.0.0.1:xxx<br>export http_proxy=127.0.0.1:xxx<br></code></pre></td></tr></table></figure><blockquote><p>其中 xxx 是看自己 vpn 软件的设置中 提供的 http(s) 端口号，例如我的 41091</p></blockquote><h3 id="win">Win</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">set https_proxy=127.0.0.1:xxx<br>set http_proxy=127.0.0.1:xxx<br></code></pre></td></tr></table></figure><h3 id="wsl-设置">WSL 设置</h3><p>首先在 windows cmd/powershell 中输入 ipconfig 查看 WSL 的 ipv4 值，例如我的 <code>127.17.176.1</code>，然后在 WSL 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export https_proxy=127.17.176.1:41091<br>export http_proxy=127.17.176.1:41091<br></code></pre></td></tr></table></figure><blockquote><p>对应的换成自己 WSL 的 ip 和 vpn 的端口号，注意 WSL 中的 ip 每次 windows 重启后可能就不一样了，需要再搞一次</p></blockquote><h2 id="wsl">WSL</h2><p>根据<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">官方教程</a> 开启 wsl 功能再去 MS store 下载 ubuntu，然后<a href="https://blog.csdn.net/john1337/article/details/111310445">配置阿里镜像源(在前面 + sudo)</a>，最后 <code>sudo apt update</code>，<code>sudo apt upgrade</code> 更新 apt 缓存</p><ul><li>安装 pip（自带 python3 却不带 pip）并配置 pip 清华镜像：<code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></li><li>安装 gcc</li><li>安装 SageMath：Ubuntu 的快乐就是 <code>apt install sagemath</code></li><li>安装 jupyter notebook</li></ul><h2 id="docker-使用">Docker 使用</h2><ul><li>docker search ubuntu</li><li>docker pull ubuntu</li><li>docker run -it --name izlyforever ubuntu bash</li><li>然后用 GUI 点击 terminal 开启，然后 换成 bash 打开</li><li>exit 或 ctrl + d 关闭。或者 ctrl + p 后 ctrl + q 暂时退出不关闭</li></ul><h2 id="编译器的一些参数">编译器的一些参数</h2><p>很多可以设置的，然后越严格越能检测出不少的错误，当然了版本越高的编译器，默认要求越严格，这也是为什么很多工程不能升级编译器的版本，不然会很麻烦。</p><h2 id="正则表达式">正则表达式</h2><p>在 VScode 中</p><ul><li>把单行 <code>&#123;</code> 风格去掉的正则表达式 <code>\n[ ]+\&#123;</code>（但是有注释就有点尴尬了）</li><li>强制让 <code>if</code> 的内容包起来: <code>[ ]+if .*[\)|;]$</code> (但是分成多行就尴尬了)</li></ul><blockquote><p>不要企图全局替换，format 全部代码是大忌！</p></blockquote><h2 id="git-常见命令">Git 常见命令</h2><h3 id="添加-ssh-并复制到剪切板">添加 SSH 并复制到剪切板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;<br><br>clip &lt; ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>然后把它粘贴到自己的 setting 的 SSH 中</p><h3 id="ssh-验证">SSH 验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">ssh-agent bash<br>ssh-add ~/.ssh/id_rsa<br>ssh -T git@github.com<br></code></pre></td></tr></table></figure><h3 id="unset">unset</h3><p>取消 config，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global --unset user.name<br>git config --global --unset user.email<br></code></pre></td></tr></table></figure><h3 id="多账号-git">多账号 git</h3><blockquote><p>可参考：<a href="https://cloud.tencent.com/developer/article/1774890">腾讯云社区</a></p></blockquote><p>但是更好的方式就是一个 ssh 多用，然后用 <code>ssh-add ~/.ssh/id_rsa</code> 后提交，然后后来提交失败，再 add 一次即可</p><h3 id="配置全局用户">配置全局用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;yourName&quot;<br>git config --global user.email &quot;yourName@example.com&quot;<br></code></pre></td></tr></table></figure><blockquote><p>这是不提倡的，应该每一个 git 仓库设置各自的 user.name 和 user.email</p></blockquote><p>根据需要配置 <code>.gitignore</code> 文件</p><h3 id="第一次提交">第一次提交</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">git init<br>git add .<br>git commit -m &quot;first commit&quot;<br>git remote add origin https://github.com/izlyforever/blog.git<br>git push -u origin master<br></code></pre></td></tr></table></figure><h3 id="利用-python-一键更新弃用这个习惯并不好">利用 Python 一键更新（弃用，这个习惯并不好）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#os.system(&#x27;git init&#x27;)</span><br><span class="hljs-comment">#os.system(&#x27;git remote rm origin&#x27;)</span><br><span class="hljs-comment">#os.system(&#x27;git remote add origin git@github.com:chachabai/blogSource.git&#x27;)</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &lt; <span class="hljs-number">2</span>:<br>  os.system(<span class="hljs-string">&#x27;git commit -a -m &quot;update&quot;&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>  os.system(<span class="hljs-string">&#x27;git commit -a -m &quot;&#x27;</span> + <span class="hljs-string">&#x27; &#x27;</span>.join(sys.argv[<span class="hljs-number">1</span>:]) + <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>os.system(<span class="hljs-string">&#x27;git push origin master&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="强制提交">强制提交</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git push -f -u origin master<br></code></pre></td></tr></table></figure><h3 id="使本地文件和远程一致">使本地文件和远程一致</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git fetch --all<br>git reset --hard origin/master<br></code></pre></td></tr></table></figure><h3 id="删除已经被跟踪但要放在-.gitignore-的文件">删除已经被跟踪但要放在 <code>.gitignore</code> 的文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git rm --cached FileName<br></code></pre></td></tr></table></figure><h3 id="删除-untracked-files">删除 untracked files</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git clean -f<br>git clean -fd<br>git clean -nfd<br></code></pre></td></tr></table></figure><h3 id="回档">回档</h3><p>三种方式：</p><ul><li>去 github 网站，查看版本号，然后执行 <code>git reset --hard &lt;版本号&gt;</code></li><li>git reflog 查看回档编号，然后 <code>git reset --hard HEAD@&#123;编号&#125;</code></li><li>git reset –-hard HEAD ^ ( ^ 表示回到上一个版本，^^ 表示回到上上个版本）</li></ul><p>最后记得强制提交</p><h3 id="找回-git-reset---hard-后的代码"><a href="https://www.cnblogs.com/zhiyuan-2011/p/9280819.html">找回 <code>git reset --hard</code> 后的代码</a></h3><h3 id="新建分支">新建分支</h3><ul><li>创建新分支：<code>git branch [branch name]</code></li><li>切换到新分支：<code>git checkout [branch name]</code></li><li>创建+切换分支：<code>git checkout -b [branch name]</code></li><li>删除本地分支：<code>git branch -d [branch name]</code></li><li>删除远程分支：<code>git push origin :[branch name]</code></li><li>分支提交：<code>git push origin [branch name]</code></li></ul><h3 id="扩大传输限制">扩大传输限制</h3><blockquote><p>fatal: 过早的文件结束符（EOF）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.postBuffer 524288000<br></code></pre></td></tr></table></figure><h3 id="cherry-pick">cherry-pick</h3><p>merge 进了某个版本 A，要在另一个版本 B cherry-pick 的做法</p><ul><li>进入 B 版本目录创建一个分支，然后在这个分支上 执行 <code>git cherry-pick [commit id]</code></li><li>然后把冲突修改一下，然后 <code>git add .</code>，再 <code>git cherry-pick --continue</code> 即可</li></ul><blockquote><p>如果 cherry-pick 报 bad object 可能是因为代码还没更新 git pull 一下即可，如果还不行可能是因为 repo 弄错了</p></blockquote><h3 id="patch">patch</h3><p>类似与 cherry-pick，我们把自己的修改丢给别人，可以建分支让他人 cherry-pick 也可以生成一个 <code>change.patch</code> 文件，让别人直接应用。</p><p>生成实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git diff &gt; change.patch<br>git diff fileName &gt; change.patch<br>git format-patch HEAD^<br></code></pre></td></tr></table></figure><blockquote><p><code>git format-patch --help</code> 可以看更详细的操作。<code>git format-patch</code> 的方式附带了 author 信息，git diff 自然没有，因为它还没有 commit 也就不可能有作者的信息</p></blockquote><p>应用实例（方式一）：</p><ul><li>检查 patch 文件是否合规：<code>git apply --stat xxx.patch</code></li><li>检查是否有冲突：<code>git apply --check xxx.patch</code></li><li>应用：<code>git apply xxx.patch</code></li></ul><p>结束后需要自己手动去 <code>add</code>, <code>commit</code></p><p>应用实例（方式二）：</p><p>对于 git format-patch 获取的 patch 文件，可以使用 <code>git am xxx.patch</code> 一步到位（此时的 author 和 commitMessage 的作者一致）</p><h2 id="杂类">杂类</h2><h3 id="unix-like-man-命令后面的数字含义及作用">Unix-like man 命令后面的数字含义及作用</h3><table><thead><tr class="header"><th>序号</th><th>意义</th><th>详解</th></tr></thead><tbody><tr class="odd"><td>1</td><td>commands</td><td>普通的命令</td></tr><tr class="even"><td>2</td><td>system calls</td><td>系统调用，如open, write之类的（通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)</td></tr><tr class="odd"><td>3</td><td>library calls</td><td>库函数，如 printf, fread</td></tr><tr class="even"><td>4</td><td>special files</td><td>特殊文件，也就是 <code>/dev</code> 下的各种设备文件</td></tr><tr class="odd"><td>5</td><td>file formats and convertions</td><td>文件的格式，比如 passwd，就会说明这个文件中各个字段的含义</td></tr><tr class="even"><td>6</td><td>games for linux</td><td>给游戏留的，由各个游戏自己定义</td></tr><tr class="odd"><td>7</td><td>macro packages and conventions</td><td>附件还有一些变量，比如向 environ 这种全局变量在这里就有说明</td></tr><tr class="even"><td>8</td><td>system management commands</td><td>系统管理用的命令，这些命令只能由 root 使用，如 ifconfig</td></tr><tr class="odd"><td>9</td><td>others</td><td></td></tr></tbody></table><blockquote><p>参考 <a href="https://blog.csdn.net/qq_21792169/article/details/50412417" class="uri">https://blog.csdn.net/qq_21792169/article/details/50412417</a></p></blockquote><h3 id="python-开服务器共享文件">Python 开服务器共享文件</h3><ul><li>python3: <code>python -m http.server 8000</code></li><li>python2: <code>python -m SimpleHTTPServer 8000</code></li></ul><h3 id="文件查找非-ascii-字符">文件查找非 ASCII 字符</h3><p>利用正则表达式搜索：<code>[^\x00-\x7f]</code></p><h3 id="windows-命令行复制到剪切板">Windows 命令行复制到剪切板</h3><ul><li><code>[命令] | clip</code></li><li><code>[命令] &gt; a.txt</code> 到文本后复制</li><li><strong>开启快速编辑，选中后＋右键复制，直接右键是粘贴</strong>(所有系统均适用)</li></ul><h3 id="linux-删除指定类型文件">Linux 删除指定类型文件</h3><p><code>find -name '文件名或目录名' | xargs rm -rf</code></p><h3 id="windows-批处理将-a-文件夹下所有文件全部复制移动对应修改-copy-为-move-即可到-b-文件夹中">Windows 批处理将 A 文件夹下所有文件全部复制（移动对应修改 copy 为 move 即可）到 B 文件夹中</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs BAT">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">set</span> target_path=D:\BaiduNetdiskDownload\<span class="hljs-number">1</span><br><span class="hljs-built_in">set</span> copy_target_path=D:\BaiduNetdiskDownload\<span class="hljs-number">2</span><br><span class="hljs-built_in">set</span> vcffile=*.vcf <span class="hljs-variable">%这里对应修改成别的后缀或者删除就是没有后缀了%</span><br><span class="hljs-function">C:</span><br><span class="hljs-function"><span class="hljs-title">cd</span> %<span class="hljs-title">target_path</span>%</span><br><span class="hljs-function"><span class="hljs-title">for</span> /<span class="hljs-title">f</span> &quot;<span class="hljs-title">delims</span>=&quot; %%<span class="hljs-title">s</span> <span class="hljs-title">in</span> (&#x27;<span class="hljs-title">dir</span> /<span class="hljs-title">b</span>/<span class="hljs-title">a</span>-<span class="hljs-title">d</span>/<span class="hljs-title">s</span> &quot;%<span class="hljs-title">target_path</span>%&quot;\&quot;%<span class="hljs-title">vcffile</span>%&quot;&#x27;) <span class="hljs-title">do</span> (</span><br><span class="hljs-function"><span class="hljs-title">echo</span> %%<span class="hljs-title">s</span></span><br><span class="hljs-function"><span class="hljs-title">copy</span> /<span class="hljs-title">y</span> &quot;%%<span class="hljs-title">s</span>&quot; %<span class="hljs-title">copy_target_path</span>%</span><br><span class="hljs-function">)</span><br><span class="hljs-function"><span class="hljs-title">pause</span></span><br></code></pre></td></tr></table></figure><h3 id="windows-批处理添加-zip-后缀">Windows 批处理添加 zip 后缀</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs BAT">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">setlocal</span> enabledelayedexpansion<br><span class="hljs-keyword">for</span> /f <span class="hljs-variable">%%i</span> <span class="hljs-keyword">in</span> (&#x27;<span class="hljs-built_in">dir</span> /b *&#x27;) <span class="hljs-keyword">do</span> (<br><span class="hljs-built_in">ren</span> &quot;<span class="hljs-variable">%%i</span>&quot;&quot;<span class="hljs-variable">%%i</span>&quot;.zip<br><span class="hljs-built_in">echo</span> 批量重命名完成！<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><h2 id="网站二维码欢迎扫码">网站二维码（欢迎扫码）</h2><figure><img src="../../img/izlyforever_qrcode.png" alt="网站二维码" /><figcaption aria-hidden="true">网站二维码</figcaption></figure><p>制作方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 运行下面命令（提前 pip install myqr）得到以 avatar为背景的二维码</span><br>myqr &quot;https://www.cnblogs.com/izlyforever/&quot; -c -p avatar.png<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公开警句</title>
    <link href="/openWords/"/>
    <url>/openWords/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li>Too young too simple，sometimes naive</li><li>常思己过，勿论人非；严于律己，宽以待人</li><li>苟余行之不迷，虽颠沛其何伤</li><li>会的越多，不会的边界越大</li><li>大道至简，慢即是快，少即是多</li><li>不谋万世者，不足谋一时；不谋全局者，不足谋一域</li><li>为某种事业英勇赴死，或者为某种事业苟且偷生</li><li>感恩群体，也要看清群体的弊端</li><li>一个人走的快，一群人走的远</li><li>君子爱财，取之有道</li><li>自信和细心相辅相<del>承</del>成</li><li>清晰的主线框架，才能让自己不在细节中迷茫</li><li>在穷困潦倒时，就别老想着为爱发电了</li><li>所有的成就都源于勤奋</li><li>你现在觉得是废话的东西，可能以后会看的时候就觉得是宝藏</li><li>脏话是用来表达强烈情感的</li><li>运动是一个独立思考的契机</li><li>智慧才是最高级别的性感</li><li>你所看到的美好，都是别人的劳动成果</li><li>认识到人类的有限，才会为人类突破中有限而震惊，鼓舞，觉得有趣</li><li>记忆很重要，不要老想着省略记忆</li><li>经验这种事情，你只有设身处地才能真正的感同身受</li><li>写作可以理清思路，与人讨论可以推成出新</li><li>决定要做的事，如果需要别人的协助，越早做越好，越拖越花在上面的时间越多</li><li>电子产品够用就好，谁不想要 i9 12900K (16-核, 30MB 缓存, 3.2GHz 至 5.2GHz 含Turbo Boost Max 3.0)，32GB 双 渠道 DDR5 (2x 16GB) at 4400MHz; 高达 128GB (附加内存单独销售)，1 TB, M.2, PCIe NVMe, 固态硬盘这种设备写 C++ 代码呢</li><li>Think twice, code once</li><li>More is different</li><li>There is no magic in computer systems</li><li>People who are really serious about software should make their own hardware</li><li>There are just two kinds of languages: the ones everybody complains about and the ones nobody uses. ———— Bjarne Stroustrup</li><li>A language that doesn't affect the way you think about programming, is not worth knowing. ———— Alan Perlis</li></ul><blockquote><p>真正的大师永远怀着一颗学徒的心</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可持久化算法</title>
    <link href="/persistableAlgorithm/"/>
    <url>/persistableAlgorithm/</url>
    
    <content type="html"><![CDATA[<p>可持久化数据结构 (Persistent data structure) 总是可以保留每一个历史版本，并且支持操作的不可变特性 (immutable)。(OI-wiki 原话)，然而实际上我们常见的可持久化数据结构都是依赖于可持续化线段树。</p><span id="more"></span><p>学习资料：<a href="https://zhuanlan.zhihu.com/p/250565583">知乎 Pecco 的文章</a> 和 <a href="https://oi-wiki.org/ds/persistent/">OI-wiki</a></p><h2 id="可持续化线段树入门">可持续化线段树（入门）</h2><p>（单点更新）可持续化线段树，区间修改版本也类似（同样需要打 tag 延迟更新，没有找到例题就不给了）</p><p>本质: 每一次建一个新的线段树，但是由于新的线段树和旧的线段树最多只有一条链不一致，因此我们可以共用很多节点。因此我们必须 <strong>动态开点</strong> 的方式建线段树，并且可以做到<strong>真正的在线</strong>。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P3919" class="uri">https://www.luogu.com.cn/problem/P3919</a> 的<a href="https://www.luogu.com.cn/record/50171248">解答</a></p><h2 id="权值线段树根据权值建的可持续化线段树">权值线段树（根据权值建的可持续化线段树）</h2><blockquote><p>权值线段树可以不离散化！！！可以动态开点，用多少使用开多少，离散化只是节省了空间。</p></blockquote><h3 id="权值线段树求静态区间-mex">权值线段树求静态区间 MEX</h3><blockquote><p>静态区间 MEX 可用<a href="https://www.luogu.com.cn/record/49961900">删除版本的回滚莫队 <span class="math inline">\(O(n \sqrt{n})\)</span> 解决</a>。</p></blockquote><p>我们对每一个右端点建一颗线段树，注意到我们关心的是每一个值出现的最后的位置。因此我们在线段树上存每个节点的右位置，然后区间存的是区间值的最小值。这样我们就可以利用线段树自带的二分得到 MEX。</p><blockquote><p>注意到此时不需要离散化（即真正的在线），因为根据 MEX 的性质，如果值大于 n，必然不能为 MEX 做贡献。</p></blockquote><p>例题：<a href="https://www.luogu.com.cn/problem/P4137" class="uri">https://www.luogu.com.cn/problem/P4137</a> 的<a href="https://www.luogu.com.cn/record/50213885">解答</a></p><blockquote><p>如果支持修改怎么做呢？</p></blockquote><h3 id="可持久化线段树求静态区间第-k-小主席树">可持久化线段树求静态区间第 k 小（主席树）</h3><blockquote><p>此方法由 黄嘉泰 发明，因为缩写 hjt 和当时主席名字缩写一致因此被戏称为 主席树。</p></blockquote><p>首先离散化，不相同的数的个数为线段树的总区间大小 <span class="math inline">\(m\)</span>，然后每个点存的值为当前每个数出现的次数。那么就可以对于区间 $[l, r] $ 的第 <span class="math inline">\(k\)</span> 小，我们判断第 k 小的数就是找 第 r 颗线段树 <span class="math inline">\([0, x]\)</span> 的和，减去第 l 颗线段树 <span class="math inline">\([0, x]\)</span> 的和大于等于 k 的最小的 <span class="math inline">\(x\)</span>。因为线段树自带二分，因此查询是 <span class="math inline">\(\log m\)</span> 的。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P3834" class="uri">https://www.luogu.com.cn/problem/P3834</a> 的<a href="https://www.luogu.com.cn/record/50185289">解答</a></p><p>小插曲：原始提交：<a href="https://www.luogu.com.cn/record/50179184" class="uri">https://www.luogu.com.cn/record/50179184</a> 中 <code>tree[q] = tree[p];</code> 移动到 update 的开头即可。但是一直没注意到，然后在 codeforces 群经过群友热心讨论，最后被 badcw 找到了问题。</p><h3 id="可持久化线段树求动态区间第-k-小这里动态表示内容可修改">可持久化线段树求动态区间第 k 小（这里动态表示内容可修改）</h3><p>动态区间第 k 小可以用树状数组维护前缀和，这样单次修改就只需修改 <span class="math inline">\(O(log)\)</span> 个 线段树。从而在 <span class="math inline">\(O(n \log^2 n)\)</span> 时空复杂度解决。注意到此时我们此时每颗线段树都只需保存自己最后的版本，因此不用多开点来修改从而节省内存。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P2617" class="uri">https://www.luogu.com.cn/problem/P2617</a> 的<a href="https://www.luogu.com.cn/record/50374069">解答</a>。</p><blockquote><p>此问题可以 <a href="../overallDichotomy">整体二分</a> 解决。</p></blockquote><h2 id="可持久化-trie"><a href="https://oi-wiki.org/ds/persistent-trie/">可持久化 Trie</a></h2><p>待补</p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整体二分</title>
    <link href="/overallDichotomy/"/>
    <url>/overallDichotomy/</url>
    
    <content type="html"><![CDATA[<p>整体二分是 由 许昊然 于 2013 年集训队论文《浅谈数据结构题的几个非经典解法》提出的一类<strong>离线算法</strong>。</p><p>学习资料：<a href="https://oi-wiki.org/misc/parallel-binsearch/">oi-wiki</a>，<a href="https://zhuanlan.zhihu.com/p/237500272">知乎</a></p><span id="more"></span><h2 id="不修改版本">不修改版本</h2><p>看了 OI-wiki 老半天，终于懂了，其它就是求一个区间 <span class="math inline">\([L, R]\)</span> 中小于某个数的个数，可以转化成，求 <span class="math inline">\([1, R]\)</span> 的答案减去 <span class="math inline">\([1, L - 1]\)</span> 的答案，而最合适的数据结构就是 树状数组了。然后我们对原始区间的所有数分到两边去，为了保留原始的位置，我们存一下位置和值。那么大于估计答案 m 的值放在右边，否则放在左边。注意到右边所有的数都是大于 m 的。因此我们就需要看一下这个区间里有多少个值放在了左边，我们需要把它减掉！就是这样结束了。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P3834" class="uri">https://www.luogu.com.cn/problem/P3834</a> 的<a href="https://www.luogu.com.cn/record/50387237">提交</a></p><blockquote><p>注意到我们可以把 <span class="math inline">\(a\)</span> 中数组的添加操作，当作修改操作！这样就通了！</p></blockquote><h2 id="单点更新版本">单点更新版本</h2><p>例题：<a href="https://www.luogu.com.cn/problem/P2617" class="uri">https://www.luogu.com.cn/problem/P2617</a> 的<a href="https://www.luogu.com.cn/record/50387288">提交</a> 比用真在线不离散化动态开点的做法要快不少</p><blockquote><p>用 <code>k = -1</code> 表示修改，可以节省内存，且更加优雅</p></blockquote><h2 id="区间更新版本">区间更新版本</h2><p><a href="https://www.luogu.com.cn/problem/P3332" class="uri">https://www.luogu.com.cn/problem/P3332</a> 求第 k 大，我们把所有的数取负数就是求第 k 小了 0.0。机智如我！另外我们可以用区间修改的树状数组替代线段树，nice，<a href="https://www.luogu.com.cn/record/50388333">提交</a></p><blockquote><p>这题如果强制在线，可以线段树套权值线段树也可以做就是写的比较恶心人</p></blockquote><h2 id="拓展应用">拓展应用</h2><p>待补</p><p><a href="https://atcoder.jp/contests/agc002/tasks/agc002_d?lang=en" class="uri">https://atcoder.jp/contests/agc002/tasks/agc002_d?lang=en</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫队算法</title>
    <link href="/mo/"/>
    <url>/mo/</url>
    
    <content type="html"><![CDATA[<p>首先莫队算法是一个离散算法，复杂度 <span class="math inline">\(O(n \sqrt{m})\)</span> 一般用于 <span class="math inline">\(m\)</span> 次长为 <span class="math inline">\(n\)</span> 的区间问题</p><span id="more"></span><h2 id="普通莫队"><a href="https://oi-wiki.org/misc/mo-algo/">普通莫队</a></h2><p>首先按照左端点所在的块为第一关键字，再按照右端点升序为第二关键字排序。优化：如果都是从小到大，那么由于这样两个指标都是上升的（就会来来回回好几次），因此我们可以奇偶交替排序，即奇数块从小到大排序，偶数快从大到小排序</p><blockquote><p>但是我们可以心中有分块，但是代码中不表现出来！（例如 OI-wiki 中示例代码），但是示例代码的做法不可避免的牵扯到除法，那还不如按照原始做法来，但是注意依然心中有块即可。</p></blockquote><p>注意四个循环的位置，遵寻先放大区间再缩小区间的策略即可，先动做还是先动右无区别。</p><blockquote><p>注意到 stl 排序中必须要保证 <span class="math inline">\(a &lt; b\)</span> 和 <span class="math inline">\(b &lt; a\)</span> 最多一个成立</p></blockquote><p>模板例题：<a href="https://www.luogu.com.cn/problem/P1494">LOJ 1494</a> 的优雅做法（这里 sn 可取 <span class="math inline">\(\frac{n}{\sqrt{m}}\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  <span class="hljs-keyword">int</span> l, r, id, b;<br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Node &amp; A) <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (b != A.b) <span class="hljs-keyword">return</span> l &lt; A.l;<br>    <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> r &lt; A.r;<br>    <span class="hljs-keyword">return</span> r &gt; A.r;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">int</span> n, m;<br>  std::cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  <span class="hljs-keyword">int</span> sn = n / std::<span class="hljs-built_in">sqrt</span>(m);<br>  <span class="hljs-function">std::vector&lt;Node&gt; <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    std::cin &gt;&gt; b[i].l &gt;&gt; b[i].r;<br>    --b[i].l; --b[i].r;<br>    b[i].b = b[i].l / sn;<br>    b[i].id = i;<br>  &#125;<br>  std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>  LL cur = <span class="hljs-number">0</span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>    cur += cnt[x];<br>    ++cnt[x];<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> del = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>    --cnt[x];<br>    cur -= cnt[x];<br>  &#125;;<br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span>, <span class="hljs-title">g</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (b[i].l == b[i].r) &#123;<br>      f[b[i].id] = <span class="hljs-number">0</span>, g[b[i].id] = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">while</span> (l &gt; b[i].l) <span class="hljs-built_in">add</span>(a[--l]);<br>      <span class="hljs-keyword">while</span> (r &lt; b[i].r) <span class="hljs-built_in">add</span>(a[++r]);<br>      <span class="hljs-keyword">while</span> (l &lt; b[i].l) <span class="hljs-built_in">del</span>(a[l++]);<br>      <span class="hljs-keyword">while</span> (r &gt; b[i].r) <span class="hljs-built_in">del</span>(a[r--]);<br>      f[b[i].id] = cur;<br>      g[b[i].id] = <span class="hljs-built_in">LL</span>(r - l + <span class="hljs-number">1</span>) * (r - l) / <span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (f[i]) &#123;<br>      LL d = std::__gcd(f[i], g[i]);<br>      f[i] /= d; g[i] /= d;<br>    &#125; <span class="hljs-keyword">else</span> g[i] = <span class="hljs-number">1</span>;<br>    std::cout &lt;&lt; f[i] &lt;&lt; <span class="hljs-string">&#x27;/&#x27;</span> &lt;&lt; g[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>带修改的莫队能做到 <span class="math inline">\(O(n^{\frac{5}{3}})\)</span>，没啥学的兴趣了。树上莫队就是把树结构转化成线性结构</p></blockquote><h2 id="回滚莫队"><a href="https://oi-wiki.org/misc/rollback-mo-algo/">回滚莫队</a></h2><p>例题：<a href="https://loj.ac/p/2874">LibreOJ-2874</a> 的<a href="https://vjudge.net/solution/30706159">提交</a>，如果用普通莫队的话，利用优先队列和 map 来加减操作会多加一个 log。因此我们这里使用回滚莫队。</p><p>回滚莫队的策略就是：如果需要考虑的左右端点在同一个块中，那么我们就直接暴力求解，这一类区间总复杂度不会超过 <span class="math inline">\(O(n \sqrt{n}\)</span>，这样分情况是为了能够做回滚，即让 l 在块的右端点，r 初始在块的右端点， l 在 r 右边挨着，然后始终保持 r 右移，l 左移动.</p><blockquote><p>这里不用上面的奇偶优化，是因为这里真的要分块解决。不得不说我的代码写的真的优雅</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">discrete</span><span class="hljs-params">(std::vector&lt;T&gt;&amp; a)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> b = a;<br>  std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>  b.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">unique</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>()), b.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">r</span><span class="hljs-params">(b.size())</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; x : a) &#123;<br>    <span class="hljs-keyword">int</span> id = std::<span class="hljs-built_in">lower_bound</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), x) - b.<span class="hljs-built_in">begin</span>();<br>    r[id] = x;<br>    x = id;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  <span class="hljs-keyword">int</span> l, r, id, b;<br>  <span class="hljs-comment">// 同一个块按照右端点排列，不同块按照左端点排列</span><br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Node &amp; A) <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (b != A.b) <span class="hljs-keyword">return</span> l &lt; A.l;<br>    <span class="hljs-keyword">return</span> r &lt; A.r;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">int</span> n, m;<br>  std::cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">discrete</span>(a); <span class="hljs-comment">// 数据范围需要离散化一下。</span><br>  <span class="hljs-keyword">int</span> sn = n / std::<span class="hljs-built_in">sqrt</span>(m) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 防止 sn 为 0，所以 + 1</span><br>  <span class="hljs-function">std::vector&lt;Node&gt; <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    std::cin &gt;&gt; b[i].l &gt;&gt; b[i].r;<br>    --b[i].l; --b[i].r;<br>    b[i].b = b[i].l / sn;<br>    b[i].id = i;<br>  &#125;<br>  std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(c.size())</span>, <span class="hljs-title">tmpcnt</span><span class="hljs-params">(c.size())</span></span>;<br>  <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-keyword">int</span> x, LL &amp;now) &#123;<br>    ++cnt[x];<br>    now = std::<span class="hljs-built_in">max</span>(now, <span class="hljs-built_in">LL</span>(c[x]) * cnt[x]);<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> del = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>    --cnt[x];<br>  &#125;;<br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<br>  LL cur = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>, lastB = <span class="hljs-number">-1</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (b[i].b != lastB) &#123;<br>      <span class="hljs-comment">// 对于新的块，初始化让 r 有这个块的右端点, l 是再右边一个</span><br>      <span class="hljs-keyword">int</span> BL = std::<span class="hljs-built_in">min</span>((b[i].b + <span class="hljs-number">1</span>) * sn, n) - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (r &lt; BL) <span class="hljs-built_in">add</span>(a[++r], cur);<br>      <span class="hljs-keyword">while</span> (r &gt; BL) <span class="hljs-built_in">del</span>(a[r--]);<br>      <span class="hljs-keyword">while</span> (l &lt;= BL) <span class="hljs-built_in">del</span>(a[l++]);<br>      cur = <span class="hljs-number">0</span>;<br>      lastB = b[i].b;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &gt; b[i].r) &#123; <span class="hljs-comment">// 左右端点在同一块的，直接暴力</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = b[i].l; j &lt;= b[i].r; ++j) ++tmpcnt[a[j]];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = b[i].l; j &lt;= b[i].r; ++j) &#123;<br>        ans[b[i].id] = std::<span class="hljs-built_in">max</span>(ans[b[i].id], <span class="hljs-built_in">LL</span>(c[a[j]]) * tmpcnt[a[j]]);<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = b[i].l; j &lt;= b[i].r; ++j) --tmpcnt[a[j]];<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 剩下要求得，b[i].r 必然不在这个块中，即必然较大</span><br>      <span class="hljs-keyword">while</span> (r &lt; b[i].r) <span class="hljs-built_in">add</span>(a[++r], cur);<br>      tmp = cur;<br>      <span class="hljs-keyword">int</span> nl = l;<br>      <span class="hljs-keyword">while</span> (nl &gt; b[i].l) <span class="hljs-built_in">add</span>(a[--nl], tmp);<br>      ans[b[i].id] = tmp;<br>      <span class="hljs-keyword">while</span> (nl &lt; l) <span class="hljs-built_in">del</span>(a[nl++]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>学完回滚莫队才感觉真的懂了莫队的思想</p></blockquote><h3 id="学习莫队的动力例题1514d">学习莫队的动力例题：<a href="https://codeforces.com/contest/1514/problem/D">1514D</a></h3><blockquote><p>只需找到区间众数即可。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  <span class="hljs-keyword">int</span> l, r, id, b;<br>  <span class="hljs-comment">// 同一个块按照右端点排列，不同块按照左端点排列</span><br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Node &amp; A) <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (b != A.b) <span class="hljs-keyword">return</span> l &lt; A.l;<br>    <span class="hljs-keyword">return</span> r &lt; A.r;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">int</span> n, m;<br>  std::cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  <span class="hljs-keyword">int</span> sn = n / std::<span class="hljs-built_in">sqrt</span>(m) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 防止 sn 为 0，所以 + 1</span><br>  <span class="hljs-function">std::vector&lt;Node&gt; <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    std::cin &gt;&gt; b[i].l &gt;&gt; b[i].r;<br>    --b[i].l; --b[i].r;<br>    b[i].b = b[i].l / sn;<br>    b[i].id = i;<br>  &#125;<br>  std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">tmpcnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> &amp;now) &#123;<br>    now = std::<span class="hljs-built_in">max</span>(now, ++cnt[x]);<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> del = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>    --cnt[x];<br>  &#125;;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<br>  <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>, lastB = <span class="hljs-number">-1</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (b[i].b != lastB) &#123;<br>      <span class="hljs-comment">// 对于新的块，初始化让 r 有这个块的右端点, l 是再右边一个</span><br>      <span class="hljs-keyword">int</span> BL = std::<span class="hljs-built_in">min</span>((b[i].b + <span class="hljs-number">1</span>) * sn, n) - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (r &lt; BL) <span class="hljs-built_in">add</span>(a[++r], cur);<br>      <span class="hljs-keyword">while</span> (r &gt; BL) <span class="hljs-built_in">del</span>(a[r--]);<br>      <span class="hljs-keyword">while</span> (l &lt;= BL) <span class="hljs-built_in">del</span>(a[l++]);<br>      cur = <span class="hljs-number">0</span>;<br>      lastB = b[i].b;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &gt; b[i].r) &#123; <span class="hljs-comment">// 左右端点在同一块的，直接暴力</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = b[i].l; j &lt;= b[i].r; ++j) &#123;<br>        ans[b[i].id] = std::<span class="hljs-built_in">max</span>(ans[b[i].id], ++tmpcnt[a[j]]);<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = b[i].l; j &lt;= b[i].r; ++j) --tmpcnt[a[j]];<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 剩下要求得，b[i].r 必然不在这个块中，即必然较大</span><br>      <span class="hljs-keyword">while</span> (r &lt; b[i].r) <span class="hljs-built_in">add</span>(a[++r], cur);<br>      <span class="hljs-keyword">int</span> tmp = cur, nl = l;<br>      <span class="hljs-keyword">while</span> (nl &gt; b[i].l) <span class="hljs-built_in">add</span>(a[--nl], tmp);<br>      ans[b[i].id] = tmp;<br>      <span class="hljs-keyword">while</span> (nl &lt; l) <span class="hljs-built_in">del</span>(a[nl++]);<br>    &#125;<br>    ans[b[i].id] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * ans[b[i].id] - (b[i].r - b[i].l + <span class="hljs-number">1</span>));<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="后来遇到的莫队问题">后来遇到的莫队问题</h2><ul><li><a href="https://www.luogu.com.cn/problem/P4137">P4137</a>：普通莫队会被特殊数据 gank，带 log 的普通莫队也会被随机数据卡掉。因此只能用回滚莫队啦，并且是<strong>删除版本</strong>的回滚莫队！这里删除版本不用分情况讨论。<a href="https://www.luogu.com.cn/record/49961900">提交记录</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串 cpp 模板</title>
    <link href="/string/"/>
    <url>/string/</url>
    
    <content type="html"><![CDATA[<p>本篇内容为 <a href="https://oi-wiki.org/string">oi-wiki 字符串篇</a> 的学习笔记</p><blockquote><p>以 <a href="https://github.com/izlyforever/cpplibforCP/blob/master/cpplib/string.hpp">代码更新汇总</a> 中的代码为主。</p></blockquote><span id="more"></span><h2 id="字典树trie">字典树（Trie）</h2><p>假设在一堆仅有大/小写字母的字符串中，需要快速检测某个字符串是否存在，那么 Trie 是个不错的选择。</p><h3 id="仅包含小写字母的-trie大写字母同理">仅包含小写字母的 Trie（大写字母同理）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br>  <span class="hljs-keyword">using</span> Node = std::array&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">26</span>&gt;;<br>  std::vector&lt;Node&gt; nxt;<br>  <span class="hljs-comment">// 0 表示没有，1 表示有且没被访问过，2 表示有且被访问过</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; tag;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    nxt[fa][c] = nxt.<span class="hljs-built_in">size</span>();<br>    nxt.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Node</span>());<br>    tag.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">nxt</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">tag</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>      <span class="hljs-keyword">int</span> c = x - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (nxt[p][c] == <span class="hljs-number">0</span>) <span class="hljs-built_in">addNode</span>(p, c);<br>      p = nxt[p][c];<br>    &#125;<br>    tag[p] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>      <span class="hljs-keyword">int</span> c = x - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (nxt[p][c] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      p = nxt[p][c];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tag[p] != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> tag[p];<br>    tag[p] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>模板例题：<a href="https://www.luogu.com.cn/problem/P2580">LOJ P2580</a></p><h3 id="trie-求异或最大值">01-Trie 求异或最大值</h3><p>做法：将数的二进制表示看成一个字符串，就可以建出字符集为 <code>&#123;0, 1&#125;</code> 的 Trie 树。把所有数字丢进去建好树之后， 对于这 n 个数中每个数，查找和它当前位不一致的位有没有。有就取，没有只能取自己，然后接着跑到底。</p><blockquote><p>注意这里可以，丢一个进去算一个，也就是说可以支持动态添加。因为要求异或最值，因此我们需要从最高位往最低位建 Trie，因此要统一高度。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br>  <span class="hljs-keyword">using</span> Node = std::array&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>&gt;;<br>  std::vector&lt;Node&gt; ch;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    ch[fa][c] = ch.<span class="hljs-built_in">size</span>();<br>    ch.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Node</span>());<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">ch</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>, p = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">int</span> c = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (ch[p][c] == <span class="hljs-number">0</span>) <span class="hljs-built_in">addNode</span>(p, c);<br>      p = ch[p][c];<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">30</span>, p = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">int</span> c = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (ch[p][c ^ <span class="hljs-number">1</span>]) &#123;<br>        p = ch[p][c ^ <span class="hljs-number">1</span>];<br>        r |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        p = ch[p][c];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAns</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<br>      <span class="hljs-built_in">insert</span>(x);<br>      r = std::<span class="hljs-built_in">max</span>(r, <span class="hljs-built_in">getMax</span>(x));<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>典型例题：<a href="https://www.luogu.com.cn/problem/P4551">LOJ P4551</a></p><p>此问题是树上问题，即树上两点路径上的异或和最大。任取一点为根可以将此问题转化成数列问题。</p><h3 id="trie-fusion-tree-求异或和支持修改全局加-1暂不支持合并">01-Trie (Fusion Tree) 求异或和（支持修改，全局加 1，暂不支持合并）</h3><blockquote><p>这里求异或和，可以从最低位往最高位建树节省空间。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br>  <span class="hljs-keyword">using</span> Node = std::array&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>&gt;;<br>  std::vector&lt;Node&gt; ch;<br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson ch[p][0]</span><br>  <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson ch[p][1]</span><br>  <span class="hljs-comment">// ch[p][2] 表示以 p 为根的子树的大小</span><br>  <span class="hljs-comment">// ch[p][3] 表示以 p 为根的子树的异或值</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    ch[p][c] = ch.<span class="hljs-built_in">size</span>();<br>    ch.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Node</span>());<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    ch[p][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (lson) ch[p][<span class="hljs-number">3</span>] ^= (ch[lson][<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (rson) ch[p][<span class="hljs-number">3</span>] ^= (ch[rson][<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">1</span>) | (ch[rson][<span class="hljs-number">2</span>] &amp; <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 注意这里 ch[lson][2] = ch[p][2] - ch[rson] 是延迟更新的。</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    ++ch[p][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!ch[p][x &amp; <span class="hljs-number">1</span>]) <span class="hljs-built_in">addNode</span>(p, x &amp; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">insert</span>(ch[p][x &amp; <span class="hljs-number">1</span>], x &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">pushUp</span>(p);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    --ch[p][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">erase</span>(ch[p][x &amp; <span class="hljs-number">1</span>], x &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">pushUp</span>(p);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!ch[p][<span class="hljs-number">2</span>]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (rson) <span class="hljs-built_in">addAll</span>(rson);<br>    <span class="hljs-comment">// 为了进位，先补 0，补 0 的时候记得更新 ch[lson][2]（它延迟更新了）</span><br>    <span class="hljs-keyword">if</span> (!lson) <span class="hljs-built_in">addNode</span>(p, <span class="hljs-number">0</span>);<br>    ch[lson][<span class="hljs-number">2</span>] = ch[p][<span class="hljs-number">2</span>] - (rson ? ch[rson][<span class="hljs-number">2</span>] : <span class="hljs-number">0</span>);<br>    std::<span class="hljs-built_in">swap</span>(lson, rson);<br>    <span class="hljs-built_in">pushUp</span>(p);<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">ch</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, x);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, x);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">addAll</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getVal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ch[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P6018">LOJ P6018</a></p><blockquote><p>注意数据必须保证任意时刻每个节点的矿泉水数非负。</p></blockquote><p><a href="https://www.luogu.com.cn/record/46497724">灵活变长版</a> 和 <a href="https://www.luogu.com.cn/record/46496796">定长版</a></p><h2 id="前缀函数">前缀函数</h2><p><span class="math display">\[\pi[i] = \max_{k = 0, \cdots, i} \{ k : s[0, \cdots, k - 1] = s[i - (k - 1), \cdots i] \}\]</span></p><p>即子串 <span class="math inline">\(s[0, \cdots, i]\)</span> 的最长相等<strong>真</strong>前缀与<strong>真</strong>后缀的长度。</p><p>注意到两个事实：由定义知 <span class="math inline">\(\pi[i + 1] \leq \pi[i] + 1\)</span>，因此若 <span class="math inline">\(s[i + 1] == s[\pi[i]]\)</span>，那 <span class="math inline">\(\pi[i + 1] = \pi[i] + 1\)</span>，反之，注意到我们始终有 <span class="math inline">\(s[0, \cdots, \pi[i] - 1] = s[i - \pi[i] + 1, \cdots, i]\)</span>，对于的第二大的长度 <span class="math inline">\(j\)</span>，我们有： <span class="math display">\[s[0, \cdots, j - 1] = s[i - j + 1, \cdots, i] = s[\pi[i] - j, \cdots, \pi[i] - 1]\]</span> 即 j 等价于字串 <span class="math inline">\(s[\pi[i] - 1]\)</span> 的前缀和函数值，即 <span class="math inline">\(j = \pi[\pi[i] - 1]\)</span>，然后依次这样进行下去即可。</p><p>复杂度：<span class="math inline">\(O(n)\)</span>，注意到 <span class="math inline">\(\pi[i + 1] \leq \pi[i] + 1\)</span>，若取等，我们称为上升（每步最多上升一次），反之我们称为下降，显然严格下降的次数不会超过上升的次数，因此整体上升下降次数不会超过 <span class="math inline">\(2n\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">prefixFunction</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> j = p[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) j = p[j - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (s[i] == s[j]) ++j;<br>    p[i] = j;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意上述算法是一个在线算法，即可以一个一个的字符添加。</p></blockquote><h3 id="kmp-算法knuth-morris-pratt-算法">KMP 算法（Knuth-Morris-Pratt 算法）</h3><p>给定文本 t 和 字符串 s，尝试找到并展示 s 在 t 中的所有出现。</p><p>我们可以构建一个字符串 <code>s + # + t</code>，然后求前缀函数即可， 并且注意</p><ol type="1"><li>函数值最大为 n</li><li>若值为 n 表示匹配成功，且 i - 2n 为出现位置</li><li>我们不需要保存 t 的信息。</li></ol><p>因此我们可以在 <span class="math inline">\(O(n + m)\)</span> 时间 <span class="math inline">\(O(n)\)</span> 空间利用前缀函数解决此问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回所有匹配在 t 的首位置</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">kmp</span><span class="hljs-params">(std::string s, std::string t)</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">if</span> (n &gt; m) <span class="hljs-keyword">return</span> ans;<br>  <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">prefixFunction</span>(s);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[j] != t[i]) j = p[j - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (s[j] == t[i] &amp;&amp; ++j == n) ans.<span class="hljs-built_in">emplace_back</span>(i - n + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题：<a href="https://codeforces.com/problemset/problem/126/B">126B</a>，找一个最长的既是前缀又是后缀又是中间的最长字符串。</p><p>做法：首先计算出前缀函数，然后，用 kmp 看 s[0, pi[n - 1]] 是否在 s[1, n - 2] 中出现，没出现就看就继续看 <span class="math inline">\(pi[pi[n - 1] - 1]\)</span> 直到 0 即可。当然了可以有很多细节上的优化（例如 kmp 的时候不用每次都求一次前缀函数，在跑 KMP 的时候也只需要跑一次即可），但是此题不需要，<a href="https://codeforces.com/contest/126/submission/107155685">我的代码</a> 也没优化，因为做题主要是测试代码正确性的。</p><h3 id="字符串的周期">字符串的周期</h3><p>显然 <span class="math inline">\(n - \pi[n - 1], n - \pi[pi[n - 1]], \cdots\)</span> 为全部字符串的周期。</p><h3 id="统计每个前缀出现的次数">统计每个前缀出现的次数</h3><p>首先以 i 为右端点有长度 <span class="math inline">\(\pi[i]\)</span> 的前缀，有长度 <span class="math inline">\(\pi[\pi[i] - 1]\)</span> 的前缀，等等知道长度为 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回 长度为 i 的前缀出现的次数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countPrefix</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">prefixFunction</span>(s);<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : p) ++ans[x];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) ans[p[i - <span class="hljs-number">1</span>]] += ans[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) ++ans[i];<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 返回 s 长度为 i 的前缀在 t 中出现的次数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countPrefix</span><span class="hljs-params">(std::string s, std::string t)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">prefixFunction</span>(s);<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; t[i] != s[j]) j = p[j - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (t[i] == s[j]) ++j;<br>    ++ans[j];<br>  &#125;<br>  ++ans[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">0</span>; --i) ans[p[i - <span class="hljs-number">1</span>]] += ans[i];<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题：<a href="https://codeforces.com/problemset/problem/432/D">432D</a> 的<a href="https://codeforces.com/contest/432/submission/107155940">代码</a></p><h2 id="bm-算法sunday-等一系列算法还是下次一定吧">BM 算法，Sunday 等一系列算法还是下次一定吧</h2><h2 id="z-函数也称拓展-kmp">Z-函数，也称拓展 KMP</h2><p>类似于前缀函数，Z-函数也可以用来求 KMP，也可以 <span class="math inline">\(O(n)\)</span> 给出 Z-函数，也当作另一种思路。</p><p><span class="math inline">\(z[i]\)</span> 表示 s 和 <span class="math inline">\(s[i, n - 1]\)</span> 的最长公共前缀，约定 <span class="math inline">\(z[0] = 0\)</span></p><p>我们称 <span class="math inline">\(i, i + z[i] - 1\)</span> 是 i 的匹配段，也称 z-Box。</p><p>维护右端点最大的匹配段，记作 <span class="math inline">\([l, r]\)</span>，即 <span class="math inline">\(s[l, r]\)</span> 是 s 的前缀。</p><p>首先初始化，<span class="math inline">\(l = r = 0, i = 1\)</span>（始终保证 <span class="math inline">\(l \leq i\)</span>）</p><ul><li>若 <span class="math inline">\(i \leq r\)</span>，根据定义 <span class="math inline">\(s[i, r] = s[i - l, r - l]\)</span>，若 <span class="math inline">\(s[i - l] &lt; r - i + 1\)</span>，则 <span class="math inline">\(z[i] = z[i - l]\)</span>，反之，令 <code>z[i] = r - i + 1</code> 然后暴力拓展直到不能拓展为止</li><li>若 <span class="math inline">\(i &gt; r\)</span>，那我们直接暴力求出 <span class="math inline">\(z[i]\)</span>，</li></ul><p>无论那种情况都要更新 r。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">zFunction</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="hljs-number">1</span>) &#123;<br>      z[i] = z[i - l];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">int</span> j = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r - i + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">while</span> (i + j &lt; n &amp;&amp; s[j] == s[i + j]) ++j;<br>      z[i] = j;<br>      <span class="hljs-keyword">if</span> (i + j - <span class="hljs-number">1</span> &gt; r) &#123;<br>        l = i;<br>        r = i + j - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> z;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度，每次拓展 r 增加 1，因此总拓展次数小于 n，所以整体复杂度 <span class="math inline">\(O(n)\)</span>。</p><p>类似于前缀函数，我们也可以求 KMP</p><h3 id="kmp">KMP</h3><p>构造 <code>s + # + t</code> 的串，那么我们可以通过计算 s 的 Z-函数，然后，在 t 中也类似的做，然后如果 t 中找到了长度为 s 长度的 z 值，那么就相当于匹配到了，并且注意到我们在这里不会再更新 r 值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回所有匹配在 t 的首位置</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">kmp</span><span class="hljs-params">(std::string s, std::string t)</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">if</span> (n &gt; m) <span class="hljs-keyword">return</span> ans;<br>  <span class="hljs-keyword">auto</span> z = <span class="hljs-built_in">zFunction</span>(s);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; r || z[i - l] &gt;= r - i + <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">int</span> j = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r - i + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; i + j &lt; m &amp;&amp; s[j] == t[i + j]) ++j;<br>      <span class="hljs-keyword">if</span> (j == n) ans.<span class="hljs-built_in">emplace_back</span>(i);<br>      <span class="hljs-keyword">if</span> (i + j - <span class="hljs-number">1</span> &gt; r) &#123;<br>        l = i;<br>        r = i + j - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自动机多模式串匹配">自动机（多模式串匹配）</h2><p><a href="https://oi-wiki.org/string/automaton/">OI-wiki</a> 上讲的是真的好，就不赘述了。</p><p>主要用途，多串匹配。</p><h3 id="ac-自动机automaton">AC 自动机（Automaton）</h3><p>以 Trie 机构为基础，结合 KMP 的思想建立的。</p><ul><li>将所有模式串构成一颗 Trie</li><li>对 Trie 树上的所有节点构造失配（fail）指针（利用 KMP 思想）。</li></ul><p>上面是原始思想，一般都会做两个优化：路径压缩（也称建 Trie 图），后缀链接（也称 last 优化）</p><p>路径压缩会改变 Trie 的结构，即改变了状态转移，但是并没有改变最终状态点。它压缩了 fail 指针，一步到位。后缀链接压缩的模式匹配的时候不计入答案的直接跳过。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P3808">LOJ P3808</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automaton</span> &#123;</span><br>  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> CHAR = <span class="hljs-number">26</span>;<br>  <span class="hljs-keyword">using</span> Node = std::array&lt;<span class="hljs-keyword">int</span>, CHAR&gt;;<br>  std::vector&lt;Node&gt; nxt;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; cnt, fail, last;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">charToInt</span><span class="hljs-params">(<span class="hljs-keyword">char</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x - <span class="hljs-string">&#x27;a&#x27;</span>;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    nxt[fa][c] = nxt.<span class="hljs-built_in">size</span>();<br>    nxt.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Node</span>());<br>    cnt.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>    fail.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>    last.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Automaton</span>() : <span class="hljs-built_in">nxt</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">cnt</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">fail</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">last</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>      <span class="hljs-keyword">int</span> c = <span class="hljs-built_in">charToInt</span>(x);<br>      <span class="hljs-keyword">if</span> (nxt[p][c] == <span class="hljs-number">0</span>) <span class="hljs-built_in">addNode</span>(p, c);<br>      p = nxt[p][c];<br>    &#125;<br>    ++cnt[p];<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; CHAR; ++c) &#123;<br>      <span class="hljs-keyword">if</span> (nxt[<span class="hljs-number">0</span>][c]) Q.<span class="hljs-built_in">push</span>(nxt[<span class="hljs-number">0</span>][c]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> p = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; CHAR; ++c) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">int</span> &amp;q = nxt[p][c]; q != <span class="hljs-number">0</span>) &#123;<br>          fail[q] = nxt[fail[p]][c];<br>          Q.<span class="hljs-built_in">push</span>(q);<br>          <span class="hljs-comment">// 用作模式匹配时计数的优化</span><br>          last[q] = cnt[fail[q]] ? fail[q] : last[fail[q]];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          q = nxt[fail[p]][c];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 具体写法见题目要求</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-keyword">int</span> &amp; x) &#123;<br>      r += x; x = <span class="hljs-number">0</span>;<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>      <span class="hljs-keyword">int</span> c = <span class="hljs-built_in">charToInt</span>(x);<br>      p = nxt[p][c];<br>      <span class="hljs-keyword">if</span> (cnt[p]) <span class="hljs-built_in">add</span>(cnt[p]);<br>      <span class="hljs-keyword">int</span> q = p;<br>      <span class="hljs-keyword">while</span> (last[q]) &#123;<br>        q = last[q];<br>        <span class="hljs-keyword">if</span> (cnt[q]) <span class="hljs-built_in">add</span>(cnt[q]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  Automaton A;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    std::string s;<br>    std::cin &gt;&gt; s;<br>    A.<span class="hljs-built_in">insert</span>(s);<br>  &#125;<br>  A.<span class="hljs-built_in">build</span>();<br>  std::string t;<br>  std::cin &gt;&gt; t;<br>  std::cout &lt;&lt; A.<span class="hljs-built_in">query</span>(t) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外加强版例题：<a href="https://www.luogu.com.cn/problem/P3796">LOJ P3796</a></p><p>我直接骚气的来一波节点存字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automaton</span> &#123;</span><br>  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> CHAR = <span class="hljs-number">26</span>;<br>  <span class="hljs-keyword">using</span> Node = std::array&lt;<span class="hljs-keyword">int</span>, CHAR&gt;;<br>  std::vector&lt;Node&gt; nxt;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; fail, last;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">charToInt</span><span class="hljs-params">(<span class="hljs-keyword">char</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x - <span class="hljs-string">&#x27;a&#x27;</span>;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    nxt[fa][c] = nxt.<span class="hljs-built_in">size</span>();<br>    nxt.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Node</span>());<br>    fail.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>    last.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>    str.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">string</span>());<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Automaton</span>() : <span class="hljs-built_in">nxt</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">fail</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">last</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>  std::vector&lt;std::string&gt; str;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>      <span class="hljs-keyword">int</span> c = <span class="hljs-built_in">charToInt</span>(x);<br>      <span class="hljs-keyword">if</span> (nxt[p][c] == <span class="hljs-number">0</span>) <span class="hljs-built_in">addNode</span>(p, c);<br>      p = nxt[p][c];<br>    &#125;<br>    str[p] = s;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; CHAR; ++c) &#123;<br>      <span class="hljs-keyword">if</span> (nxt[<span class="hljs-number">0</span>][c]) Q.<span class="hljs-built_in">push</span>(nxt[<span class="hljs-number">0</span>][c]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> p = Q.<span class="hljs-built_in">front</span>(); Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; CHAR; ++c) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">int</span> &amp;q = nxt[p][c]; q != <span class="hljs-number">0</span>) &#123;<br>          fail[q] = nxt[fail[p]][c];<br>          Q.<span class="hljs-built_in">push</span>(q);<br>          <span class="hljs-comment">// 用作模式匹配时计数的优化</span><br>          last[q] = str[fail[q]].<span class="hljs-built_in">size</span>() ? fail[q] : last[fail[q]];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          q = nxt[fail[p]][c];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 具体写法见题目要求</span><br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">query</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(str.size())</span></span>;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>      <span class="hljs-keyword">int</span> c = <span class="hljs-built_in">charToInt</span>(x);<br>      p = nxt[p][c];<br>      <span class="hljs-keyword">if</span> (str[p].<span class="hljs-built_in">size</span>()) ++r[p];<br>      <span class="hljs-keyword">int</span> q = p;<br>      <span class="hljs-keyword">while</span> (last[q]) &#123;<br>        q = last[q];<br>        ++r[q];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-keyword">while</span> (std::cin &gt;&gt; n) &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    Automaton A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      std::string s;<br>      std::cin &gt;&gt; s;<br>      A.<span class="hljs-built_in">insert</span>(s);<br>    &#125;<br>    A.<span class="hljs-built_in">build</span>();<br>    std::string t;<br>    std::cin &gt;&gt; t;<br>    <span class="hljs-keyword">auto</span> r = A.<span class="hljs-built_in">query</span>(t);<br>    <span class="hljs-keyword">int</span> x = *std::<span class="hljs-built_in">max_element</span>(r.<span class="hljs-built_in">begin</span>(), r.<span class="hljs-built_in">end</span>());<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r.<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-keyword">if</span> (r[i] == x) &#123;<br>        std::cout &lt;&lt; A.str[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="后缀数组-sa也称后缀排序">后缀数组 SA（也称后缀排序)</h2><p>学习资料：<a href="https://riteme.site/blog/2016-6-19/sais.html">诱导排序和 SA-IS</a>，该博文还提供了原论文链接。逐字快速阅读，然后思考，再模拟，再逐字慢阅读掌握（最后还是没完全懂）然后读<a href="LinearSuffixArrayConstructionbyAlmostPureInduced-Sorting.pdf">原始论文</a> 才终于理解了。</p><p>流程：首先确定类型 L 和 S，然后 S 中确定 <em>型，然后每一个后缀 <span class="math inline">\(suf(S, i)\)</span> 的排序改成 它到 <span class="math inline">\(pre(S, i)\)</span>（第一个</em> 型的这一段）的排序，那么初始所有字符相同的 * 型都是一样大的，所以可以任意排列（丢进桶中），然后用诱导排序，第一步将 L 型的都排好序了，然后根据 L 把所有 S 型 <span class="math inline">\(suf(S, i)\)</span> 排序（此时做了微小的改变，个人理解）。那么这就给出了 LMS-substring 的排序，那么相同的 LMS-substring 只可能出现在相邻的情况。如果这些 LMS-substring 两两不同，那么它们就直接被排好序，否则 LMS-substring 就递归的进行排序即可。最后 根据 LMS-substring 的排序诱导整体的排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 请确保最后一个元素为 0，且 a 中其它元素都是正整数，且最大值较小。</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">SAIS</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; a)</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TYPE</span> &#123;</span>L, S&#125;;<br>  <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, mx = *std::<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">SA</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">bucket</span><span class="hljs-params">(mx)</span>, <span class="hljs-title">lbucket</span><span class="hljs-params">(mx)</span>, <span class="hljs-title">sbucket</span><span class="hljs-params">(mx)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) ++bucket[x];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mx; ++i) &#123;<br>    bucket[i] += bucket[i - <span class="hljs-number">1</span>];<br>    lbucket[i] = bucket[i - <span class="hljs-number">1</span>];<br>    sbucket[i] = bucket[i] - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 确定 L, S 类型以及 * 型的位置</span><br>  <span class="hljs-function">std::vector&lt;TYPE&gt; <span class="hljs-title">type</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  type[n] = S;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    type[i] = (a[i] &lt; a[i + <span class="hljs-number">1</span>] ? S : (a[i] &gt; a[i + <span class="hljs-number">1</span>] ? L : type[i + <span class="hljs-number">1</span>]));<br>  &#125;<br>  <span class="hljs-comment">// 诱导排序(从 * 型诱导到 L 型、从 L 型诱导到 S 型)</span><br>  <span class="hljs-keyword">auto</span> inducedSort = [&amp;]() &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (SA[i] &gt; <span class="hljs-number">0</span> &amp;&amp; type[SA[i] - <span class="hljs-number">1</span>] == L) &#123;<br>        SA[lbucket[a[SA[i] - <span class="hljs-number">1</span>]]++] = SA[i] - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mx; ++i) &#123;<br>      sbucket[i] = bucket[i] - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">if</span> (SA[i] &gt; <span class="hljs-number">0</span> &amp;&amp; type[SA[i] - <span class="hljs-number">1</span>] == S) &#123;<br>        SA[sbucket[a[SA[i] - <span class="hljs-number">1</span>]]--] = SA[i] - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>  &#125;;<br>  <span class="hljs-comment">// 首先根据诱导排序给出 LMS-prefix 的排序</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; pos;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (type[i] == S &amp;&amp; type[i - <span class="hljs-number">1</span>] == L) &#123;<br>      pos.<span class="hljs-built_in">emplace_back</span>(i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : pos) SA[sbucket[a[x]]--] = x;<br>  <span class="hljs-built_in">inducedSort</span>();<br>  <span class="hljs-comment">// 根据 LMS-prefix 的排序给出 LMS-substring 的命名，即得到 S1</span><br>  <span class="hljs-keyword">auto</span> isLMSchar = [&amp;](<span class="hljs-keyword">int</span> i) &#123;<br>    <span class="hljs-keyword">return</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; type[i] == S &amp;&amp; type[i - <span class="hljs-number">1</span>] == L;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> equalSubstring = [&amp;](<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-keyword">if</span> (a[x] != a[y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      ++x; ++y;<br>    &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isLMSchar</span>(x) &amp;&amp; !<span class="hljs-built_in">isLMSchar</span>(y));<br>    <span class="hljs-keyword">return</span> a[x] == a[y];<br>  &#125;;<br>  <span class="hljs-comment">// 注意到因为 LMS-prefix 排序会导致仅有相邻的 LMS-substring 才可能相等</span><br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">name</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>  <span class="hljs-keyword">int</span> lx = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示无相同的 LMS-substring</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : SA) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isLMSchar</span>(x)) &#123;<br>    <span class="hljs-keyword">if</span> (lx &gt;= <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-built_in">equalSubstring</span>(lx, x)) ++cnt;<br>    <span class="hljs-keyword">if</span> (lx &gt;= <span class="hljs-number">0</span> &amp;&amp; cnt == name[lx]) flag = <span class="hljs-literal">false</span>;<br>    name[x] = cnt;<br>    lx = x;<br>  &#125;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; S1;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : name) <span class="hljs-keyword">if</span> (x != <span class="hljs-number">-1</span>) S1.<span class="hljs-built_in">emplace_back</span>(x);<br>  <span class="hljs-keyword">auto</span> getSA1 = [&amp;]() &#123;<br>    <span class="hljs-keyword">int</span> n1 = S1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">SA1</span><span class="hljs-params">(n1)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; ++i) SA1[S1[i]] = i;<br>    <span class="hljs-keyword">return</span> SA1;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> SA1 = flag ? <span class="hljs-built_in">getSA1</span>() : <span class="hljs-built_in">SAIS</span>(S1);<br>  <span class="hljs-comment">// 再次诱导排序，根据 S1 的排序得到 SA</span><br>  lbucket[<span class="hljs-number">0</span>] = sbucket[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; mx; ++i) &#123;<br>    lbucket[i] = bucket[i - <span class="hljs-number">1</span>];<br>    sbucket[i] = bucket[i] - <span class="hljs-number">1</span>;<br>  &#125;<br>  std::<span class="hljs-built_in">fill</span>(SA.<span class="hljs-built_in">begin</span>(), SA.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);<br>  <span class="hljs-comment">// 这里是逆序扫描 SA1，因为 SA 中 S 型桶是倒序的</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = SA1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    SA[sbucket[a[pos[SA1[i]]]]--] = pos[SA1[i]];<br>  &#125;<br>  <span class="hljs-built_in">inducedSort</span>();<br>  <span class="hljs-keyword">return</span> SA;<br>&#125;<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">SAIS</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;s)</span> </span>&#123;<br>  <span class="hljs-comment">// s 的字符集为小写字，则可使用下面函数。</span><br>  <span class="hljs-comment">// auto f = [](char x) -&gt; int &#123; return int(x - &#x27;a&#x27;) + 1;&#125;;</span><br>  <span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">char</span> x) -&gt; <span class="hljs-keyword">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(x) + <span class="hljs-number">1</span>;&#125;;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">f</span>(c));<br>  a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">auto</span> sa = <span class="hljs-built_in">SAIS</span>(a);<br>  <span class="hljs-keyword">return</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt;(sa.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, sa.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="找在-t-中子串-s">找在 T 中子串 S</h3><blockquote><p>注意这里可以先给定 T，再一个个给 S。而 KMP，AC 自动机都是先给 S 再给 T。</p></blockquote><p>若 S 是 T 的子串，那么 S 必然是 T 的后缀的前缀。因为后缀已经被排序了，因此我们可以二分解决。因此复杂度为 <span class="math inline">\(O(|S| \log|T|)\)</span>，出现次数也可以通过二分得到，并且输出位置也很轻松哈哈。</p><h3 id="从字符串首尾取字符最小化字典序">从字符串首尾取字符最小化字典序</h3><p>例题：<a href="https://www.luogu.com.cn/problem/P2870">LOJ P2870</a></p><p>给一个正串和反串，每次取一个字典序更小的串中的首字符。那么我们可以把这两个串拼起来，然后求后缀数组比较即可。</p><h3 id="height-数组-和-最长公共前缀-lcp">height 数组 和 最长公共前缀 LCP</h3><p>我们定义 <span class="math inline">\(ht[i] = lcp(sa[i], sa[i - 1])\)</span> 即第 i 名的后缀和它前一名的后缀的最长公共前缀，约定 <span class="math inline">\(ht[0] = 0\)</span>。</p><p>我们断言：<span class="math inline">\(ht[rk[i]] \geq ht[rk[i - 1]] - 1\)</span>。</p><p>证明：若 <span class="math inline">\(ht[rk[i - 1]] &gt; 1\)</span>，设后缀 i - 1 为 aAD（其中 <span class="math inline">\(|A| = ht[rk[i - 1]] - 1\)</span>）则后缀 i 就是 AD，<span class="math inline">\(sa[rk[i - 1]]\)</span> 的后缀为 aAB，且 <span class="math inline">\(B &lt; D\)</span>，所以 <span class="math inline">\(sa[rk[i - 1]] + 1\)</span> 的后缀为 AB 必然在 i 的前面，因此 <span class="math inline">\(sa[rk[i] - 1]\)</span> 的前缀必然包含 A（存在一个比我小的跟我有相同的后缀 A，那么必然我的上一个必然也有相同的前缀 A)，证毕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string s;<br>std::cin &gt;&gt; s;<br><span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">auto</span> sa = <span class="hljs-built_in">SAIS</span>(s);<br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rk</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) rk[sa[i]] = i;<br><span class="hljs-comment">// 可能从 1 开始编号会方便点，但是我不喜欢。</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ht</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>  <span class="hljs-keyword">if</span> (k) --k;<br>  <span class="hljs-keyword">if</span> (rk[i] == <span class="hljs-number">0</span>) k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 字符串不必担心越界，否则最好添加一个唯一的最小元素。</span><br>    <span class="hljs-keyword">while</span> (s[i + k] == s[sa[rk[i] - <span class="hljs-number">1</span>] + k]) ++k;<br>    ht[rk[i]] = k;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="math inline">\(lcp(sa[i], sa[j]] = \min(ht[i + 1, \cdots, j])\)</span>，所以可以用线段树解决。</p><h3 id="不同子串的数量">不同子串的数量</h3><p><span class="math inline">\(\frac{n(n + 1)}{2} - \sum_{i = 1}^{n - 1} ht[i]\)</span></p><h3 id="第-k-小的子串">第 k 小的子串</h3><p>例题：<a href="https://vjudge.net/problem/LibreOJ-2102">TJOI2015</a> 的<a href="https://www.luogu.com.cn/record/46658646">提交答案</a></p><p>如果不同位置的相同子串算作一个，那么直接利用 ht 数组就可以轻松的 <span class="math inline">\(O(n)\)</span> 构造，每次 <span class="math inline">\(\log(n)\)</span> 查询。</p><p>如果不同位置的相同子串算作多个，那么 ht 数组就没用了，我们可以一个个的查找 <span class="math inline">\(O(n)\)</span> 构造，<span class="math inline">\(O(n \log n)\)</span> 查询。</p><h2 id="后缀自动机-sam">后缀自动机 SAM</h2><p>字符串 s 的 SAM 是一个接受 s 的所有后缀的最小 DFA（确定性有限自动机或确定性有限状态自动机）。</p><h2 id="广义后缀自动机trie-sam">广义后缀自动机(Trie + SAM)</h2><p>后缀自动机 (suffix automaton, SAM) 是用于处理单个字符串的子串问题的强力工具 广义后缀自动机 (General Suffix Automaton) 则是将后缀自动机整合到字典树中来解决对于多个字符串的子串问题。</p><h2 id="序列自动机">序列自动机</h2><p>仅接受一个字符串的子序列的自动机。</p><p>例题：<a href="https://vjudge.net/problem/LibreOJ-2123">HEOI2015</a></p><h2 id="最小表示法">最小表示法</h2><p>我们称两个字符串 S 和 T <strong>循环同构</strong>，如果它们各自首尾相接得到一个有向环是相同的。</p><p>最小表示：与 S 循环同构的字典序最小的字符串。</p><p>我们记 <span class="math inline">\(S_i\)</span> 表示以 S 的第 i 个字符开头与 S 循环同构的字符串。</p><p>直接暴力是 <span class="math inline">\(O(n^2)\)</span> 的，但是观察到，若 <span class="math inline">\(s[i, \cdots, i +k - 1] = s[j \cdot, j + k - 1]\)</span>，那么我们就要开始比较 s[i + k] 和 s[j + k]，不妨设 <span class="math inline">\(s[i + k] &gt; s[j + k]\)</span>，那么显然 <span class="math inline">\(S_{i + p} &lt; S_{j + p} (p \leq k)\)</span> 若 <span class="math inline">\(l \in [i, i + k]\)</span>，则 <span class="math inline">\(S_l\)</span> 不可能成为最小表示。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P1368">LOJ P1368</a> 和 <a href="https://vjudge.net/problem/UVA-719">UVA 719</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPresent</span><span class="hljs-params">(std::vector&lt;T&gt;&amp; a)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>, n = a.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">while</span> (k &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) &#123;<br>    <span class="hljs-keyword">if</span> (a[(i + k) % n] == a[(j + k) % n]) &#123;<br>      ++k;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      a[(i + k) % n] &gt; a[(j + k) % n] ? i += k + <span class="hljs-number">1</span> : j += k + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (i == j) ++i;<br>      k = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">min</span>(i, j);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lyndon-分解">Lyndon 分解</h2><p>Lyndon word：我们称 <span class="math inline">\(s\)</span> 是 Lyndon word，如果 s 的字典序严格小于它所有真后缀的字典序。这等价于说它是自己的循环同构中最小的。</p><p>Lyndon 分解：<span class="math inline">\(s = w_1 \cdots, w_k\)</span>，其中 <span class="math inline">\(w_i\)</span> 是 Lyndon word，且 <span class="math inline">\(w_1 \geq w_2 \geq \cdots, w_k\)</span>。可以证明分解存在且唯一。</p><p>Duval 算法：在 <span class="math inline">\(O(n)\)</span> 时间给出一个串的 Lyndon 分解。</p><blockquote><p>根据 Shirshov 分解：<span class="math inline">\(s = s_L s_R\)</span>，其中 <span class="math inline">\(s_R\)</span> 是字典序最小的后缀（从而是 Lyndon word），若 <span class="math inline">\(s_R = s\)</span> 结束；否则，我们对剩下的 <span class="math inline">\(s_L\)</span> 做同样的操作。但是因为后缀数组算法本身太复杂（太长），所以还是推荐 Duval 算法。</p></blockquote><p>这个算法具体说就是让 <span class="math inline">\(s = w \cdots w \hat{w} x\)</span>，其中 w 是 Lyndon word，<span class="math inline">\(\hat{w}\)</span> 是 w 的前缀，<span class="math inline">\(x\)</span> 是还未考虑到的剩余部分。注意到此时我们还不能说 w 是 s 的 Lyndon 分解的一部分，因为如果 <span class="math inline">\(\hat{w} x[0] &gt; w\)</span>（此时就不是了，此时就变成了一个新的 Lyndon word）。而如果 <span class="math inline">\(\hat{w} x[0]\)</span> 还是 w 的前缀，那就把它吸收进去，继续考虑。如果 <span class="math inline">\(\hat{w} x[0] &lt; w\)</span>，那么此时 w 确实是 Lyndon 分解的一部分，把这些 w 全踢出去即可。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P6114">LOJ P6114</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Lyndon decomposition using Duval algorithm</span><br><span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">duval</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;s)</span> </span>&#123;<br>  std::vector&lt;std::string&gt; r;<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(), i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>    <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>, k = i;<br>    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; s[k] &lt;= s[j]) &#123;<br>      <span class="hljs-keyword">if</span> (s[k] &lt; s[j]) k = i;<br>      <span class="hljs-keyword">else</span> ++k;<br>      ++j;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= k) &#123;<br>      r.<span class="hljs-built_in">emplace_back</span>(s.<span class="hljs-built_in">substr</span>(i, j - k));<br>      i += j - k;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个用途：双拼 s 可求最小表示。（但是最小表示本身代码比较简单所以意义也不是很大）</p><h2 id="回文子串的-manacher-算法">回文子串的 Manacher 算法</h2><p>问题：给定字符串 s，求所有回文子串。</p><p>首先注意到以一个位置为中心的最长回文串的子串都是回文子串，因此我们直到对每个位置 i，求它们的半径 <span class="math inline">\(d_i\)</span> 即可。而 Manacher 给出了一个 <span class="math inline">\(O(|s|)\)</span> 时空的算法。由于回文串长度的奇偶性使得要分两种情况讨论，但是我们其实也可以在其中插入 <code>#</code> 来统一成奇数的形式。</p><p>模板例题：<a href="https://vjudge.net/problem/UVA-11475">UVA-11475</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-comment">// 仅仅处理奇数长回文串，这个实现像极了 Z-函数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Manacher</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> k = i &gt; r ? <span class="hljs-number">1</span> : std::<span class="hljs-built_in">min</span>(d[l + r - i], r - i);<br>    <span class="hljs-keyword">while</span> (k &lt;= i &amp;&amp; i + k &lt; n &amp;&amp; s[i - k] == s[i + k]) ++k;<br>    d[i] = k--;<br>    <span class="hljs-keyword">if</span> (i + k &gt; r) &#123;<br>      l = i - k;<br>      r = i + k;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  std::string s;<br>  <span class="hljs-keyword">while</span> (std::cin &gt;&gt; s) &#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">ss</span><span class="hljs-params">(<span class="hljs-string">&quot;#&quot;</span>)</span></span>;<br>    std::<span class="hljs-built_in">swap</span>(ss, s);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ss) &#123;<br>      s += x; s += <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> d = <span class="hljs-built_in">Manacher</span>(s);<br>    <span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (now &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; now + d[now] != s.<span class="hljs-built_in">size</span>()) ++now;<br>    std::cout &lt;&lt; ss;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = now - d[now]; i &gt;= <span class="hljs-number">0</span>; --i) <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;#&#x27;</span>) std::cout &lt;&lt; s[i];<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其它例题：<a href="https://www.luogu.com.cn/problem/P4555">LOJ P4555</a>，求最长双回文子串（即可以拆成两个回文子串）</p><p>我们定义 <span class="math inline">\(l[i], r[i]\)</span> 分别表示以 i 开头和以 i 结尾的回文长度。则 <span class="math display">\[l[i] = \max(l[i], l[i + 2] - 2), r[i] = \max(r[i], r[i - 2] - 2)\]</span> 枚举每一个 <code>#</code> 为断点，更新答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-comment">// 仅仅处理奇数长回文串</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Manacher</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> k = i &gt; r ? <span class="hljs-number">1</span> : std::<span class="hljs-built_in">min</span>(d[l + r - i], r - i);<br>    <span class="hljs-keyword">while</span> (k &lt;= i &amp;&amp; i + k &lt; n &amp;&amp; s[i - k] == s[i + k]) ++k;<br>    d[i] = k--;<br>    <span class="hljs-keyword">if</span> (i + k &gt; r) &#123;<br>      l = i - k;<br>      r = i + k;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  std::string s;<br>  std::cin &gt;&gt; s;<br>  <span class="hljs-function">std::string <span class="hljs-title">ss</span><span class="hljs-params">(<span class="hljs-string">&quot;#&quot;</span>)</span></span>;<br>  std::<span class="hljs-built_in">swap</span>(ss, s);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ss) &#123;<br>    s += x; s += <span class="hljs-string">&#x27;#&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> d = <span class="hljs-built_in">Manacher</span>(s);<br>  <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(n)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">auto</span> cmax = [](<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> y) &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; y) x = y;<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-built_in">cmax</span>(l[i + d[i] - <span class="hljs-number">1</span>], d[i] - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">cmax</span>(r[i - d[i] + <span class="hljs-number">1</span>], d[i] - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">2</span>)  <span class="hljs-built_in">cmax</span>(l[i], l[i + <span class="hljs-number">2</span>] - <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i += <span class="hljs-number">2</span>) <span class="hljs-built_in">cmax</span>(r[i], r[i - <span class="hljs-number">2</span>] - <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i += <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> (l[i] &amp;&amp; r[i]) <span class="hljs-built_in">cmax</span>(ans, l[i] + r[i]);<br>  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回文自动机">回文自动机</h2><p>用于存储一个串中所有回文子串的高效数据结构。</p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论 cpp 模板</title>
    <link href="/graph/"/>
    <url>/graph/</url>
    
    <content type="html"><![CDATA[<p>图论还是一个特别强的工具。 为什么没有图论的 STL？</p><blockquote><p>以 <a href="https://github.com/izlyforever/cpplibforCP/blob/master/cpplib/graph.hpp">代码更新汇总</a> 中的代码为主</p></blockquote><span id="more"></span><h2 id="其他人的图论模板可做参考其实我自己的够用了目前看">其他人的图论模板可做参考（其实我自己的够用了目前看）</h2><ul><li><a href="https://uoj.ac/submission/160478">Nisiyama_Suzune</a> 的图论模板</li><li><a href="https://github.com/DQ9911/icpc_template_2020">DQ9911</a> 的模板</li><li><a href="HDU_ACM-ICPC_Templates.pdf">HDU 模板</a> 也可以作为参考</li></ul><h2 id="存边方式">存边方式</h2><ul><li>不涉及删边和反边（最简单常用的情况），可以直接用 vector 邻接表 <code>std::vector&lt;std::vector&lt;std::pair&lt;int, T&gt;&gt;&gt;</code></li><li>仅涉及反向边，不涉及删边（如网络流问题），可以使用 vector 版本的链式前向星（写法特别简洁）</li><li>不涉及重边（即使涉及重边也可以！其它操作随意，无向图其实也可以操作），都可以使用 vector 邻接表 <code>std::vector&lt;std::unordered_map&lt;int, int&gt;&gt;</code>（更快）或<code>std::vector&lt;std::map&lt;int, T&gt;&gt;</code>，当然了各种操作都要带个 log</li><li>如果涉及重边（逻辑上没法合并的那种），就不存在反边的概念了。此时可以用链式前向星，也可以使用 最简单情况的 vector 邻接表（也支持删边，只是比较慢）无论怎么，即使不用链式前向星，这种思想还是值得学习的。</li></ul><h3 id="链式前向星-弃用">链式前向星 （弃用）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkStar</span> &#123;</span><br> <span class="hljs-keyword">public</span>:<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; head, nxt, to;<br>  std::vector&lt;LL&gt; w;<br>  <span class="hljs-built_in">LinkStar</span>(<span class="hljs-keyword">int</span> n) &#123;<br>    nxt.<span class="hljs-built_in">clear</span>();<br>    to.<span class="hljs-built_in">clear</span>();<br>    head = std::vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, LL val)</span> </span>&#123;<br>    nxt.<span class="hljs-built_in">emplace_back</span>(head[u]);<br>    head[u] = to.<span class="hljs-built_in">size</span>();<br>    to.<span class="hljs-built_in">emplace_back</span>(v);<br>    w.<span class="hljs-built_in">emplace_back</span>(val);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵存边太简单就不写了">邻接矩阵存边（太简单就不写了）</h3><h3 id="邻接-map-or-unorder_map-存边同上">邻接 map or unorder_map 存边（同上）</h3><h3 id="vector-版本链式前向星见后面网络流的做法">vector 版本链式前向星（见后面网络流的做法）</h3><h2 id="树上问题转化成序列问题">树上问题转化成序列问题</h2><h3 id="无根树的-prufer-序列"><a href="https://baike.baidu.com/item/prufer数列/2182091?fr=aladdin">无根树的 Prufer 序列</a></h3><blockquote><p>A.Cayley 在 1889 年首先公布并证明 <span class="math inline">\(n\)</span> 个节点的无根树和长度为 <span class="math inline">\(n-2\)</span>，数值在 <span class="math inline">\(1 \to n\)</span> 的序列有一一对应</p><p>构造方式：删除编号最小的叶子节点，并记录它的父节点。</p></blockquote><p><span class="math inline">\(n\)</span> 个节点的无根树（也就是简单无向图），可以唯一的给出一个长度为 <span class="math inline">\(n-2\)</span> 的编码，同样每一个长为 <span class="math inline">\(n-2\)</span> 的编码都可以唯一的产生一棵 <span class="math inline">\(n\)</span> 个节点的无根树 （这就证明了上面结论）</p><p>给定一颗 <span class="math inline">\(n&gt;2\)</span> 个节点的无根树，每次找出无根树中，度数为 <span class="math inline">\(1\)</span> 的节点中编号最小的节点 <span class="math inline">\(A\)</span>，记录节点 <span class="math inline">\(A\)</span> 的邻接点，然后删除节点 <span class="math inline">\(A\)</span> 和它的边。这样一直继续下去，直到只剩下两个节点。</p><blockquote><p>度数为 <span class="math inline">\(i\)</span> 的节点恰好在 Prufer 编码中出现 <span class="math inline">\(i-1\)</span> 次</p></blockquote><p>给你一个长度为 <span class="math inline">\(n-2\)</span> 的 Prufer 编码，我们只要找出 <strong>没有在当前编码中最小的</strong> 跟编码中第一个节点相连即可。重复下去即可得到无根树。</p><p><a href="https://cp-algorithms.com/graph/pruefer_code.html">CP-algorithm</a> 中有详细的讲解和代码 无根树 和 Prufer 序列 互转的 <span class="math inline">\(O(n \log n)\)</span> 和 <span class="math inline">\(O(n)\)</span> 两类代码。</p><h3 id="有根树的-dfs-序">有根树的 <strong>dfs 序</strong></h3><blockquote><p>本质作用： 将树上问题转化成序列问题，dfs 序是基础，Euler 序可以认为是推广。</p></blockquote><p>树节点按 dfs 过程中的访问顺序排序（进入记录一次，出去记录一次），称为 dfs 序。处理子树的问题很有用。</p><p><a href="https://www.cnblogs.com/bytebull/p/5929137.html">这里</a> 给出了 dfs 序的一些应用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DfsTour</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n, cnt;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; l, r;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; e;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">DfsTour</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">e</span>(n), <span class="hljs-built_in">l</span>(n), <span class="hljs-built_in">r</span>(n), <span class="hljs-built_in">cnt</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>    e[v].<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span> </span>&#123;<br>    l[u] = ++cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) &#123;<br>      <span class="hljs-built_in">dfs</span>(v, u);<br>    &#125;<br>    r[u] = cnt;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>其中 u 的子树的编号正好是区间 <span class="math inline">\([l_u, r_u]\)</span>，注意不可能有交叉的情况！</p></blockquote><p>关于子树的问题，可以考虑一下 dfs 序。</p><ol type="1"><li><p>在节点权值可修改的情况下，查询某个子树里的所有点权和。</p><blockquote><p>由于在上述 dfs 序中子树 x 是连续的一段 <span class="math inline">\([l_x, r_x]\)</span>，所以用树状数组：单点更新，区间查询。</p></blockquote></li><li><p>节点 X 到 Y 的最短路上所有点权都加上一个数 W，查询某个子树里的所有点权和。 可以理解为更新 4 段区间，根节点到 X，根节点到 Y，根节点到 lca(X, Y)，根节点到 fa[lca(X, Y)]，可以用 线段树 或 带区间更新的树状数组。</p></li></ol><h3 id="有根树的-euler-序列长度为-2n---1">有根树的 Euler 序列（长度为 2n - 1）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 以 rt 为根的树，只记录进入的 Euler 序（长度为 2n - 1)</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">EulerTour</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; e, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; r;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; <span class="hljs-keyword">void</span> &#123;<br>    r.<span class="hljs-built_in">emplace_back</span>(u);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) &#123;<br>      <span class="hljs-built_in">dfs</span>(v, u);<br>      r.<span class="hljs-built_in">emplace_back</span>(u);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-built_in">dfs</span>(rt, rt);<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先观察到这个树的 Euler 序列首尾都是根的编号，如果把首尾连接起来，就会发现：<strong>这个序列中元素出现的次数正好是它的度</strong>。并且我们可以轻松的<strong>换根节点</strong>!!!，以谁为根就以谁开始转圈！并且如果删除某个节点，那么就会形成<strong>以这个节点为度的个数的连通分支</strong>。</p><p>问题 1：求 最近公共祖先（LCA）</p><p>求完 Euler 序列后，求 <code>lca(u, v)</code> 那就是 <span class="math inline">\(E[pos[u], \cdots, pos[v]]\)</span> 的最小值，其中 <code>pos[u]</code> 为 u 首次出现在 E 中的标号。那么显然我们可以用线段树 <span class="math inline">\(O(n)\)</span> 预处理，单步 <span class="math inline">\(O(\log n)\)</span> 在线查询 lca。</p><p>问题 2：求树上任意两点的距离</p><p>求完 Euler 序列的同时，我们先求出根节点和其它点的距离，由上述步骤我们能求 lca，那么树上任意两点 <span class="math inline">\(u, v\)</span> 的距离就是 <code>d[u] + d[v] - d[lca(u, v)]</code></p><blockquote><p>如果求树上任意两点距离之和：只需统计每条边经过多少次就行，显然等价于每条边左右两边节点个数，就不用上述做法了。</p></blockquote><p>问题 3：求树上节点到根节点的最短路径点权和</p><h3 id="树链剖分-heavy-light-decomposition"><a href="https://oi-wiki.org/graph/hld/">树链剖分 Heavy-Light decomposition</a></h3><p>重链剖分可以理解为 dfs 序和 Euler 序的增强优化拓展版本。</p><h4 id="重链剖分求-lca-的模板例题loj-3379我的实现">重链剖分求 LCA 的模板例题：<a href="https://www.luogu.com.cn/problem/P3379">LOJ 3379</a>，<a href="https://www.luogu.com.cn/record/45492112">我的实现</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 为了代码简洁，树的编号以 1 开始</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LCA</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; fa, dep, sz, son, top;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LCA</span>(std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;e, <span class="hljs-keyword">int</span> rt = <span class="hljs-number">1</span>) : <span class="hljs-built_in">n</span>(e.<span class="hljs-built_in">size</span>()) &#123;<br>    fa.<span class="hljs-built_in">resize</span>(n);<br>    dep.<span class="hljs-built_in">resize</span>(n);<br>    sz.<span class="hljs-built_in">resize</span>(n);<br>    son.<span class="hljs-built_in">resize</span>(n);<br>    fa[rt] = rt;<br>    dep[rt] = <span class="hljs-number">0</span>;<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; pdfs = [&amp;](<span class="hljs-keyword">int</span> u) -&gt; <span class="hljs-keyword">int</span> &#123;<br>      sz[u] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa[u]) &#123;<br>        dep[v] = dep[u] + <span class="hljs-number">1</span>;<br>        fa[v] = u;<br>        sz[u] += <span class="hljs-built_in">pdfs</span>(v);<br>        <span class="hljs-keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sz[u];<br>    &#125;;<br>    top.<span class="hljs-built_in">resize</span>(n);<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> t) -&gt; <span class="hljs-keyword">void</span> &#123;<br>      top[u] = t;<br>      <span class="hljs-keyword">if</span> (son[u] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-built_in">dfs</span>(son[u], t);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) <span class="hljs-built_in">dfs</span>(v, v);<br>    &#125;;<br>    <span class="hljs-built_in">pdfs</span>(rt);<br>    <span class="hljs-built_in">dfs</span>(rt, rt);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;<br>      <span class="hljs-keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;<br>        u = fa[top[u]];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        v = fa[top[v]];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dep[u] &lt; dep[v] ? u : v;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n, m, rt;<br>  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> u, v;<br>    std::cin &gt;&gt; u &gt;&gt; v;<br>    e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>    e[v].<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-function">LCA <span class="hljs-title">g</span><span class="hljs-params">(e, rt)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">int</span> x, y;<br>    std::cin &gt;&gt; x &gt;&gt; y;<br>    std::cout &lt;&lt; g.<span class="hljs-built_in">lca</span>(x, y) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重链剖分求任意两点路径上所有节点的点权和求子树的点权和利用-dfs-编号和-sz-直接区间查询或区间修改">重链剖分求任意两点路径上所有节点的点权和，求子树的点权和（利用 dfs 编号和 sz 直接区间查询或区间修改）</h4><p>例题：<a href="https://www.luogu.com.cn/problem/P3384">LOJ 3384</a>，参考：<a href="https://www.cnblogs.com/chinhhh/p/7965433.html">ChinHhh's blog</a>，用加强版树状数组而非线段树算的：<a href="https://www.luogu.com.cn/record/45509401">提交记录</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br>LL M;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeArray</span> &#123;</span><br>  std::vector&lt;LL&gt; s;<br>  <span class="hljs-built_in">TreeArray</span>() &#123;&#125;<br>  <span class="hljs-built_in">TreeArray</span>(<span class="hljs-keyword">int</span> n) : <span class="hljs-built_in">s</span>(n + <span class="hljs-number">1</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &amp; (-n);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (id &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>      (s[id] += p) %= M;<br>      id += <span class="hljs-built_in">lowbit</span>(id);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">LL <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    LL r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (id) &#123;<br>      (r += s[id]) %= M;<br>      id -= <span class="hljs-built_in">lowbit</span>(id);<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeArrayPlus</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-comment">// c[i] = a[i] - a[i - 1], b_i = (i - 1) * c_i</span><br>  TreeArray B, C;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    C.<span class="hljs-built_in">add</span>(id, p);<br>    B.<span class="hljs-built_in">add</span>(id, (id - <span class="hljs-number">1</span>) * p % M);<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TreeArrayPlus</span>() &#123;&#125;<br>  <span class="hljs-built_in">TreeArrayPlus</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">B</span>(n), <span class="hljs-built_in">C</span>(n) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-built_in">add</span>(l, p);<br>    <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -p);<br>  &#125;<br>  <span class="hljs-function">LL <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (id * C.<span class="hljs-built_in">sum</span>(id) + M - B.<span class="hljs-built_in">sum</span>(id)) % M;<br>  &#125;<br>  <span class="hljs-function">LL <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>)) % M + M) % M;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 为了代码简洁，树的编号以 1 开始</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HLD</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; fa, dep, sz, son, top, dfn;<br>  TreeArrayPlus Tree;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HLD</span>(std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;e, std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, <span class="hljs-keyword">int</span> rt = <span class="hljs-number">1</span>) : <span class="hljs-built_in">n</span>(e.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">Tree</span>(n + <span class="hljs-number">1</span>) &#123;<br>    fa.<span class="hljs-built_in">resize</span>(n);<br>    dep.<span class="hljs-built_in">resize</span>(n);<br>    sz.<span class="hljs-built_in">resize</span>(n);<br>    son.<span class="hljs-built_in">resize</span>(n);<br>    fa[rt] = dep[rt] = <span class="hljs-number">0</span>;<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; pdfs = [&amp;](<span class="hljs-keyword">int</span> u) -&gt; <span class="hljs-keyword">int</span> &#123;<br>      sz[u] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa[u]) &#123;<br>        dep[v] = dep[u] + <span class="hljs-number">1</span>;<br>        fa[v] = u;<br>        sz[u] += <span class="hljs-built_in">pdfs</span>(v);<br>        <span class="hljs-keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sz[u];<br>    &#125;;<br>    top.<span class="hljs-built_in">resize</span>(n);<br>    dfn.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> t) -&gt; <span class="hljs-keyword">void</span> &#123;<br>      top[u] = t;<br>      dfn[u] = ++cnt;<br>      <span class="hljs-keyword">if</span> (son[u] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-built_in">dfs</span>(son[u], t);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) <span class="hljs-built_in">dfs</span>(v, v);<br>    &#125;;<br>    <span class="hljs-built_in">pdfs</span>(rt);<br>    <span class="hljs-built_in">dfs</span>(rt, rt);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) Tree.<span class="hljs-built_in">add</span>(dfn[i], dfn[i], a[i]);<br>  &#125;<br>  <span class="hljs-comment">// u 到根的最短路径上所有边权值加 c</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (u) &#123;<br>      Tree.<span class="hljs-built_in">add</span>(dfn[top[u]], dfn[u], c);<br>      u = fa[top[u]];<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// u 到根的最短路径上所有边权值之和</span><br>  <span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    LL r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (u) &#123;<br>      r += Tree.<span class="hljs-built_in">sum</span>(dfn[top[u]], dfn[u]);<br>      u = fa[top[u]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> r % M;<br>  &#125;<br>  <span class="hljs-comment">// u, v 的最短路径上所有边权值加 c（可以通过 lca 和根来搞，但是会很慢）</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;<br>      <span class="hljs-keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;<br>        Tree.<span class="hljs-built_in">add</span>(dfn[top[u]], dfn[u], c);<br>        u = fa[top[u]];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        Tree.<span class="hljs-built_in">add</span>(dfn[top[v]], dfn[v], c);<br>        v = fa[top[v]];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) &#123;<br>      Tree.<span class="hljs-built_in">add</span>(dfn[u], dfn[v], c);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Tree.<span class="hljs-built_in">add</span>(dfn[v], dfn[u], c);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// u, v 的最短路径上所有边权值之和（可以通过 lca 和根来搞，但是会很慢）</span><br>  <span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    LL r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;<br>      <span class="hljs-keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;<br>        r += Tree.<span class="hljs-built_in">sum</span>(dfn[top[u]], dfn[u]);<br>        u = fa[top[u]];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        r += Tree.<span class="hljs-built_in">sum</span>(dfn[top[v]], dfn[v]);<br>        v = fa[top[v]];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) &#123;<br>      r += Tree.<span class="hljs-built_in">sum</span>(dfn[u], dfn[v]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      r += Tree.<span class="hljs-built_in">sum</span>(dfn[v], dfn[u]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> r % M;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addSon</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    Tree.<span class="hljs-built_in">add</span>(dfn[u], dfn[u] + sz[u] - <span class="hljs-number">1</span>, c);<br>  &#125;<br>  <span class="hljs-function">LL <span class="hljs-title">querySon</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Tree.<span class="hljs-built_in">sum</span>(dfn[u], dfn[u] + sz[u] - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (top[u] != top[v]) &#123;<br>      <span class="hljs-keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;<br>        u = fa[top[u]];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        v = fa[top[v]];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dep[u] &lt; dep[v] ? u : v;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n, m, rt;<br>  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; rt &gt;&gt; M;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) std::cin &gt;&gt; a[i];<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> u, v;<br>    std::cin &gt;&gt; u &gt;&gt; v;<br>    e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>    e[v].<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-function">HLD <span class="hljs-title">g</span><span class="hljs-params">(e, a, rt)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">int</span> op, x, y, z;<br>    std::cin &gt;&gt; op;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>      std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>      g.<span class="hljs-built_in">add</span>(x, y, z);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>      std::cin &gt;&gt; x &gt;&gt; y;<br>      std::cout &lt;&lt; g.<span class="hljs-built_in">query</span>(x, y) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<br>      std::cin &gt;&gt; x &gt;&gt; z;<br>      g.<span class="hljs-built_in">addSon</span>(x, z);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      std::cin &gt;&gt; x;<br>      std::cout &lt;&lt; g.<span class="hljs-built_in">querySon</span>(x) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// auto start = std::clock();</span><br>  <span class="hljs-comment">// std::cout &lt;&lt; &quot;Time used: &quot; &lt;&lt; (std::clock() - start) &lt;&lt; &quot;ms&quot; &lt;&lt; std::endl;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="长链剖分优化-dp例题1009f">长链剖分优化 DP，例题：<a href="https://codeforces.com/contest/1009/problem/F">1009F</a></h4><p>这个题显然可以用重链剖分来做，或者说下面的 dsu on tree 来做（<span class="math inline">\(O(n \log n)\)</span>），但是<a href="https://codeforces.com/blog/entry/60630">官方题解</a> 用长链剖分可以优化到 <span class="math inline">\(O(n)\)</span>！太强了。主要原因是因为，每个轻儿子节点最多被合并一次（它第一次合并之后，它的信息就被和他同深度的重兄弟节点给吸收了），后面再合并的时候就不算它被合并而算当前重儿子节点的合并了（妙不可言）。但是父节点占据儿子节点的时候有个问题就是用 std::map 或 std::unordered_map 本质上都会带一个 log，因此我们需要用 vector 保存信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-comment">// 为了代码简洁，树的编号以 1 开始。</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dsuOnTree</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;e, <span class="hljs-keyword">int</span> rt = <span class="hljs-number">1</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = e.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-comment">// 预处理出重儿子</span><br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n)</span>, <span class="hljs-title">son</span><span class="hljs-params">(n)</span></span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; pdfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) &#123;<br>      <span class="hljs-built_in">pdfs</span>(v, u);<br>      <span class="hljs-keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;<br>    &#125;<br>    sz[u] = sz[son[u]] + <span class="hljs-number">1</span>;<br>  &#125;;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>  std::function&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; std::vector&lt;<span class="hljs-keyword">int</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> (son[u] == <span class="hljs-number">0</span>) &#123;<br>      ans[u] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">dfs</span>(son[u], u);<br>    ans[u] = ans[son[u]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;<br>      <span class="hljs-keyword">auto</span> tmp = <span class="hljs-built_in">dfs</span>(v, u);<br>      <span class="hljs-comment">// 这里需要对齐</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ai = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, ti = tmp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ti &gt;= <span class="hljs-number">0</span>; --ti, --ai) &#123;<br>        a[ai] += tmp[ti];<br>        <span class="hljs-keyword">if</span> (a[ai] &gt; a[ans[u]] || (a[ai] == a[ans[u]] &amp;&amp; ai &gt; ans[u])) &#123;<br>          ans[u] = ai;<br>        &#125;<br>      &#125;<br>    &#125;<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[ans[u]] == <span class="hljs-number">1</span>) ans[u] = sz[u] - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;;<br>  <span class="hljs-built_in">pdfs</span>(rt, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">dfs</span>(rt, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) ans[i] = sz[i] - <span class="hljs-number">1</span> - ans[i];<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> u, v;<br>    std::cin &gt;&gt; u &gt;&gt; v;<br>    e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>    e[v].<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">dsuOnTree</span>(e);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) std::cout &lt;&lt; r[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树上启发式算法dsu-on-tree"><a href="https://oi-wiki.org/graph/dsu-on-tree/">树上启发式算法（dsu on tree）</a></h3><p>先处理轻儿子，但是不保留影响，再处理重儿子保留，再暴力处理所有其它情况，再看次节点是否需要保留。</p><p>复杂度分析真的太妙了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 为了代码简洁，树的编号以 1 开始，参考：https://www.cnblogs.com/zwfymqz/p/9683124.html</span><br><span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">dsuOnTree</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;e, std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, <span class="hljs-keyword">int</span> rt = <span class="hljs-number">1</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-comment">// 预处理出重儿子</span><br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sz</span><span class="hljs-params">(n)</span>, <span class="hljs-title">son</span><span class="hljs-params">(n)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n)</span></span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; pdfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; <span class="hljs-keyword">int</span> &#123;<br>    sz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) &#123;<br>      sz[u] += <span class="hljs-built_in">pdfs</span>(v, u);<br>      <span class="hljs-keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sz[u];<br>  &#125;;<br>  <span class="hljs-comment">// 这个函数具体问题具体分析</span><br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>, Son = <span class="hljs-number">0</span>;<br>  LL sm = <span class="hljs-number">0</span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; deal = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; <span class="hljs-keyword">void</span> &#123;<br>    ++cnt[a[u]];<br>    <span class="hljs-keyword">if</span> (cnt[a[u]] &gt; mx) &#123;<br>      mx = cnt[a[u]];<br>      sm = a[u];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt[a[u]] == mx) &#123;<br>      sm += a[u];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa &amp;&amp; v != Son) &#123;<br>      <span class="hljs-built_in">deal</span>(v, u);<br>    &#125;<br>  &#125;;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; del = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; <span class="hljs-keyword">void</span> &#123;<br>    --cnt[a[u]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) <span class="hljs-built_in">del</span>(v, u);<br>  &#125;;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">bool</span> save) -&gt; <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa &amp;&amp; v != son[u]) &#123;<br>      <span class="hljs-built_in">dfs</span>(v, u, <span class="hljs-number">0</span>); <span class="hljs-comment">// 先计算轻边贡献，但最终要消除影响，防止轻边互相干扰</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (son[u]) <span class="hljs-built_in">dfs</span>(son[u], u, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 统计重儿子的贡献，但不消除影响</span><br>    Son = son[u];<br>    <span class="hljs-built_in">deal</span>(u, fa); <span class="hljs-comment">// 暴力处理除重儿子外的贡献</span><br>    Son = <span class="hljs-number">0</span>;<br>    ans[u] = sm;<br>    <span class="hljs-keyword">if</span> (!save) &#123;<br>      <span class="hljs-built_in">del</span>(u, fa);<br>      sm = <span class="hljs-number">0</span>;<br>      mx = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;;<br>  <span class="hljs-built_in">pdfs</span>(rt, rt);<br>  <span class="hljs-built_in">dfs</span>(rt, rt, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>思想是这样的，到时候具体问题灵活运用，不必死套模板，例如 <a href="https://codeforces.com/gym/102832/problem/F">gym 102832F</a> 我的另样做法 <a href="https://codeforces.com/gym/102832/submission/105273241">submission 105273241</a> 更加优秀，快速。</p></blockquote><h2 id="树上问题">树上问题</h2><h3 id="树的直径先从任意点开始寻找最远距离点bfs-遍历一下然后再找一次就是了易证">树的直径：先从任意点开始寻找最远距离点（bfs 遍历一下），然后再找一次就是了（易证）</h3><p>例题：<a href="https://codeforces.com/contest/1405/problem/D">1405D</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">auto</span> bfs = [&amp;](<span class="hljs-keyword">int</span> x) -&gt; <span class="hljs-keyword">int</span> &#123;<br>  std::<span class="hljs-built_in">fill</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);<br>  std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>  d[x] = <span class="hljs-number">0</span>;<br>  Q.<span class="hljs-built_in">push</span>(x);<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>    Q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (d[v] == <span class="hljs-number">-1</span>) &#123;<br>      d[v] = d[u] + <span class="hljs-number">1</span>;<br>      Q.<span class="hljs-built_in">push</span>(v);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max_element</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>()) - d.<span class="hljs-built_in">begin</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="树的中心所有点到该点的最大值最小直径的中点">[树的中心]：所有点到该点的最大值最小（直径的中点）</h3><h3 id="树的重心去掉这个点后连通分支的节点数量的最大值最小"><a href="https://oi-wiki.org/graph/tree-centroid/">树的重心</a>：去掉这个点后连通分支的节点数量的最大值最小</h3><p>根据 DFS 子树的大小和“向上”的子树大小就可以知道所有子树中最大的子树节点数。：<a href="https://codeforces.com/contest/1406/problem/C">例题 1406C</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 其中 e 表示树的边，n 为数的数量</span><br>std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; degree = [&amp;](<span class="hljs-keyword">int</span> u) -&gt; <span class="hljs-keyword">int</span> &#123;<br>  d[u] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (d[v] == <span class="hljs-number">-1</span>) &#123;<br>    d[u] += <span class="hljs-built_in">degree</span>(v);<br>  &#125;<br>  <span class="hljs-keyword">return</span> d[u];<br>&#125;;<br><span class="hljs-keyword">auto</span> barycenter = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>  std::<span class="hljs-built_in">fill</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);<br>  <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">degree</span>(x);<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">w</span><span class="hljs-params">(n, n)</span></span>;<br>  std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>  Q.<span class="hljs-built_in">push</span>(x);<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>    Q.<span class="hljs-built_in">pop</span>();<br>    w[u] = cnt - d[u];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (w[v] == n) &#123;<br>      w[u] = std::<span class="hljs-built_in">max</span>(w[u], d[v]);<br>      Q.<span class="hljs-built_in">push</span>(v);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">int</span> r = std::<span class="hljs-built_in">min_element</span>(w.<span class="hljs-built_in">begin</span>(), w.<span class="hljs-built_in">end</span>()) - w.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_pair</span>(r, w[r]);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最近公共祖先简称-lcalowest-common-ancestor">最近公共祖先简称 LCA（Lowest Common Ancestor）</h3><ul><li>策略 1：其中一个节点一直往上标记父辈到根，然后另一个节点往上找父辈，直到找到首次被标记过的节点</li><li>策略 2：标记没个节点的深度，深度高的往上到同一层，然后一起一步步上去，直到是公共节点</li><li>策略 3：做一次 DFS 得到 Euler 序列，然后就变成找区间最小值问题了（可以使用线段树）</li><li>策略 4：树链剖分（见下面做法，目前我的做法）</li><li>其他：倍增（记录 <code>fa[u][i]</code>：表示 <code>u</code> 的第<span class="math inline">\(2^i\)</span>祖先），Tarjan 算法，动态树 <a href="https://oi-wiki.org/graph/lca/">OI-wiki</a> 给了很多做法，竟然有标准 <span class="math inline">\(O(N)\)</span> 时空复杂度的 RMQ 做法还支持在线，太强了，太强了，mark 一下，有模板，但是并不想学。</li></ul><h3 id="有向无环图的拓扑排序之-kahn-算法"><a href="https://oi-wiki.org/graph/topo/">有向无环图的拓扑排序之 Kahn 算法</a></h3><p>给定有向图，然后把节点按照顺序排列，使得任意有向边的起点在终点前。</p><p>做法：维护一个入度为 0 的节点队列，丢出队列时它连接的所有点入度减 1，为 0 就加入节点集合。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/U107394">LOJ U107394</a>。</p><blockquote><p>一个有向图是无环图，当且仅当它存在拓扑排序（有重边就用 set 存边自动去重，否则直接用 vector 即可）。</p></blockquote><h3 id="可达性统计问题">可达性统计问题</h3><p>这个问题貌似没有很好的做法。 有向无环图的情况：<a href="https://www.acwing.com/problem/content/description/166/">ACWing 164 可达性统计</a> 利用 bitset 做到 <span class="math inline">\(\frac{N^2}{64}\)</span></p><blockquote><p>一般的图可以通过先缩点变成有向无环图处理</p></blockquote><h3 id="无向图的-euler-路-的-hierholzer-算法">无向图的 Euler 路 的 Hierholzer 算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 求字典序最小的 Euler 路，没有的话输出 空（允许重边，不允许就修改成 set）</span><br><span class="hljs-function">std::stack&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">EulerPathS</span><span class="hljs-params">(std::vector&lt;std::multiset&lt;<span class="hljs-keyword">int</span>&gt;&gt; e)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> cnt = std::<span class="hljs-built_in">count_if</span>(e.<span class="hljs-built_in">begin</span>(), e.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> x) &#123;<br>    <span class="hljs-keyword">return</span> x.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;<br>  &#125;);<br>  <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> std::stack&lt;<span class="hljs-keyword">int</span>&gt;();<br>  std::stack&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; Hierholzer = [&amp;](<span class="hljs-keyword">int</span> u) &#123;<br>    <span class="hljs-keyword">while</span> (!e[u].<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> v = *e[u].<span class="hljs-built_in">begin</span>();<br>      e[u].<span class="hljs-built_in">erase</span>(e[u].<span class="hljs-built_in">begin</span>());<br>      e[v].<span class="hljs-built_in">erase</span>(e[v].<span class="hljs-built_in">find</span>(u));<br>      <span class="hljs-built_in">Hierholzer</span>(v);<br>    &#125;<br>    ans.<span class="hljs-built_in">push</span>(u);<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; e.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!e[i].<span class="hljs-built_in">empty</span>() &amp;&amp; ((e[i].<span class="hljs-built_in">size</span>() &amp; <span class="hljs-number">1</span>) || (cnt == <span class="hljs-number">0</span>))) &#123;<br>      <span class="hljs-built_in">Hierholzer</span>(i);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 求 rt 开头的字典序 Euler 路（保证存在且不允许重边，允许重边就修改成 multiset 即可）</span><br><span class="hljs-function">std::stack&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">EulerPath</span><span class="hljs-params">(std::vector&lt;std::set&lt;<span class="hljs-keyword">int</span>&gt;&gt; e, <span class="hljs-keyword">int</span> rt)</span> </span>&#123;<br>  std::stack&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; Hierholzer = [&amp;](<span class="hljs-keyword">int</span> u) &#123;<br>    <span class="hljs-keyword">while</span> (!e[u].<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> v = *e[u].<span class="hljs-built_in">begin</span>();<br>      e[u].<span class="hljs-built_in">erase</span>(e[u].<span class="hljs-built_in">begin</span>());<br>      e[v].<span class="hljs-built_in">erase</span>(e[v].<span class="hljs-built_in">find</span>(u));<br>      <span class="hljs-built_in">Hierholzer</span>(v);<br>    &#125;<br>    ans.<span class="hljs-built_in">push</span>(u);<br>  &#125;;<br>  <span class="hljs-built_in">Hierholzer</span>(rt);<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有向图的-hamiltonian-路的启发式算法"><a href="https://codeforces.com/blog/entry/90513">有向图的 Hamiltonian 路的启发式算法</a></h3><h3 id="笛卡尔树-我去竟然是-on-复杂度的建树弃用没必要直接学单调栈即可"><a href="https://oi-wiki.org/ds/cartesian-tree/">笛卡尔树</a> ：我去，竟然是 <span class="math inline">\(O(n)\)</span> 复杂度的建树（弃用没必要直接学单调栈即可）</h3><blockquote><p>从<a href="https://oi-wiki.org/ds/cartesian-tree/">OI - wiki</a> 中看到的讲解和复杂度分析!，注意到右链是从尾巴往上查找的。 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506">hdu 1506</a> 这就给出了一个 <span class="math inline">\(O(n)\)</span> 复杂度求出包含 <code>i</code>且以 <code>a[i]</code> 为最大值的区间的方法（最小值保存的时候取负数即可），太强了！ 求上述对应的最大值区间，需要修改 0 节点的值，以及 build 的大于号改成小于号。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  <span class="hljs-keyword">int</span> id, val, par, ch[<span class="hljs-number">2</span>];<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _id, <span class="hljs-keyword">int</span> _val, <span class="hljs-keyword">int</span> _par)</span> </span>&#123;<br>    id = _id, val = _val, par = _par, ch[<span class="hljs-number">0</span>] = ch[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cartesian_build</span><span class="hljs-params">(std::vector&lt;Node&gt; &amp;tree, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> k = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (tree[k].val &lt; tree[i].val) k = tree[k].par;<br>    tree[i].ch[<span class="hljs-number">0</span>] = tree[k].ch[<span class="hljs-number">1</span>];<br>    tree[k].ch[<span class="hljs-number">1</span>] = i;<br>    tree[i].par = k;<br>    tree[tree[i].ch[<span class="hljs-number">0</span>]].par = i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> tree[<span class="hljs-number">0</span>].ch[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-keyword">while</span> (std::cin &gt;&gt; n &amp;&amp; n) &#123;<br>    <span class="hljs-function">std::vector&lt;Node&gt; <span class="hljs-title">tree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    tree[<span class="hljs-number">0</span>].<span class="hljs-built_in">init</span>(<span class="hljs-number">0</span>, INT_MAX, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; ++i) &#123;<br>      std::cin &gt;&gt; x;<br>      tree[i].<span class="hljs-built_in">init</span>(i, x, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> root = <span class="hljs-built_in">cartesian_build</span>(tree, n);<br>    LL ans = <span class="hljs-number">0</span>;<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> x) -&gt; <span class="hljs-keyword">int</span> &#123;<br>      <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">int</span> sz = <span class="hljs-built_in">dfs</span>(tree[x].ch[<span class="hljs-number">0</span>]);<br>      sz += <span class="hljs-built_in">dfs</span>(tree[x].ch[<span class="hljs-number">1</span>]);<br>      ans = std::<span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">LL</span>(sz + <span class="hljs-number">1</span>) * tree[x].val);<br>      <span class="hljs-keyword">return</span> sz + <span class="hljs-number">1</span>;<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(root);<br>    std::cout &lt;&lt; ans &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 下面是求以 a[i] 为最大值且包含 i 的最大区间</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; getinterval = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>      <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">if</span> (tree[tree[x].par].ch[<span class="hljs-number">0</span>] == x) &#123;<br>        r[x] = tree[x].par - <span class="hljs-number">1</span>;<br>        l[x] = l[tree[x].par];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        l[x] = tree[x].par + <span class="hljs-number">1</span>;<br>        r[x] = r[tree[x].par];<br>      &#125;<br>      <span class="hljs-built_in">getinterval</span>(tree[x].ch[<span class="hljs-number">0</span>]);<br>      <span class="hljs-built_in">getinterval</span>(tree[x].ch[<span class="hljs-number">1</span>]);<br>    &#125;;<br>    l[root] = <span class="hljs-number">1</span>;<br>    r[root] = n;<br>    <span class="hljs-built_in">getinterval</span>(tree[root].ch[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">getinterval</span>(tree[root].ch[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 要考虑有相同值的情形，必须要分两次搞，不然有bug</span><br>    std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; updateinterval = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>      <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">if</span> (tree[tree[x].par].ch[<span class="hljs-number">0</span>] == x) &#123;<br>        <span class="hljs-keyword">if</span> (tree[x].val == tree[tree[x].par].val) r[x] = r[tree[x].par];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (tree[x].val == tree[tree[x].par].val) l[x] = l[tree[x].par];<br>      &#125;<br>      <span class="hljs-built_in">updateinterval</span>(tree[x].ch[<span class="hljs-number">0</span>]);<br>      <span class="hljs-built_in">updateinterval</span>(tree[x].ch[<span class="hljs-number">1</span>]);<br>    &#125;;<br>    <span class="hljs-built_in">updateinterval</span>(tree[root].ch[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">updateinterval</span>(tree[root].ch[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>      std::cout &lt;&lt; l[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r[i] &lt;&lt; std::endl;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>洛谷 T126268 「SWTR-05」Subsequence 有一个典型的应用</p></blockquote><h3 id="最小生成树-prim-算法">最小生成树 prim 算法</h3><p>任取一个节点，然后开始找相邻边中边最小的节点加入，然后继续。<a href="https://baike.baidu.com/item/Prim/10242166">百度百科</a>里的图解一看就懂，怎么明确证明正确性呢？（在保证连通的前提下每次删除图中最大的边，不会影响最终结果，而我们每步得到的是当前节点构成的子图的最小生成树）当然了堆优化常规操作，另外不连通输出 <code>INT64_MAX</code>, 例题：<a href="https://www.luogu.com.cn/problem/P3366">LOJ3366</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> edge = std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt;;<br><span class="hljs-function">LL <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-keyword">const</span> edge &amp;e)</span> </span>&#123;<br>  LL r = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> n = e.<span class="hljs-built_in">size</span>(), cnt = <span class="hljs-number">0</span>;<br>  std::priority_queue&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; Q;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n)</span></span>;<br>  Q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> [w, u] = Q.<span class="hljs-built_in">top</span>();<br>    Q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">continue</span>;<br>    ++cnt;<br>    r -= w;<br>    vis[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, c] : e[u]) <span class="hljs-keyword">if</span> (!vis[v]) &#123;<br>      Q.<span class="hljs-built_in">push</span>(&#123;-c, v&#125;);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt == n ? r : INT64_MAX;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小生成树的-kruskal-法">最小生成树的 kruskal 法</h3><p>每次选权值最小的边，然后用 DSU 维护，次方法可推广到 有限个乘积图的最小生成树（<a href="https://codeforces.com/gym/103098/problem/C" class="uri">https://codeforces.com/gym/103098/problem/C</a>）</p><h3 id="最小树形图的-onm-刘朱算法">最小树形图的 <span class="math inline">\(O(nm)\)</span> <a href="https://www.luogu.com.cn/blog/i207M/shu-xing-tu-shu-liu-suan-fa-xue-xi-bi-ji-xie-ti-bao-gao-p4716-post">刘朱算法</a></h3><ol type="1"><li>对每个点，找入边权值最小的边构成集合。</li><li>如果这些边构成有向环，缩点后进入 1，否则结束，找到了。</li></ol><p>例题：<a href="https://www.luogu.com.cn/problem/P4716">LOJ4716</a></p><p><strong>问题变形</strong>：如果不指定根节点，那么可以建一个根节点，然后它和所有其它点连特别大的边即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Edge = std::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;;<br><span class="hljs-function">LL <span class="hljs-title">LiuZhu</span><span class="hljs-params">(std::vector&lt;Edge&gt; e, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> rt)</span> </span>&#123; <span class="hljs-comment">// e 中无自环</span><br>  LL ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 寻找入边权值最小的边</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">in</span><span class="hljs-params">(n, INT_MAX)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [u, v, w] : e) <span class="hljs-keyword">if</span> (u != v &amp;&amp; in[v] &gt; w) &#123;<br>      in[v] = w;<br>      pre[v] = u;<br>    &#125;<br>    <span class="hljs-comment">// 判定是否无解</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i != rt &amp;&amp; pre[i] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判定是否有环</span><br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span>, <span class="hljs-title">id</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (i != rt) &#123;<br>      ans += in[i];<br>      <span class="hljs-keyword">int</span> v = i;<br>      <span class="hljs-comment">// 注意到可能出现 6 型的路径，所以两个指标很必要</span><br>      <span class="hljs-keyword">while</span> (vis[v] != i &amp;&amp; id[v] == <span class="hljs-number">-1</span> &amp;&amp; v != rt) &#123;<br>        vis[v] = i;<br>        v = pre[v];<br>      &#125;<br>      <span class="hljs-keyword">if</span> (id[v] == <span class="hljs-number">-1</span> &amp;&amp; v != rt) &#123;<br>        <span class="hljs-keyword">int</span> u = v;<br>        <span class="hljs-keyword">do</span> &#123;<br>          id[u] = cnt;<br>          u = pre[u];<br>        &#125; <span class="hljs-keyword">while</span> (u != v);<br>        ++cnt;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// 更新节点和边，也可以重开一个 vector，然后 swap 一下</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (id[i] == <span class="hljs-number">-1</span>) id[i] = cnt++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[u, v, w] : e) &#123;<br>      <span class="hljs-keyword">if</span> (id[u] != id[v]) w -= in[v];<br>      u = id[u];<br>      v = id[v];<br>    &#125;<br>    rt = id[rt];<br>    n = cnt;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短路">最短路</h2><h3 id="知乎上看到-yyyylll-关于-floyd-算法的解释挺好的再次记录稍加修改">知乎上看到 <a href="https://www.zhihu.com/people/yyyylll-37">YYYYLLL</a> 关于 Floyd 算法的解释挺好的，再次记录(稍加修改）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">DP[<span class="hljs-string">k</span>][<span class="hljs-symbol">i</span>][<span class="hljs-string">j</span>] 表示只经过 1～k 号节点优化，i 点到 j 点的最短路径长度。<br>则 DP[<span class="hljs-string">k</span>][<span class="hljs-symbol">i</span>][<span class="hljs-string">j</span>] = min( DP[<span class="hljs-string">k-1</span>][<span class="hljs-symbol">i</span>][<span class="hljs-string">j</span>], DP[<span class="hljs-string">k-1</span>][<span class="hljs-symbol">i</span>][<span class="hljs-string">k</span>]+DP[<span class="hljs-string">k-1</span>][<span class="hljs-symbol">k</span>][<span class="hljs-string">j</span>] )<br>= min( DP[<span class="hljs-string">k-1</span>][<span class="hljs-symbol">i</span>][<span class="hljs-string">j</span>], DP[<span class="hljs-string">k</span>][<span class="hljs-symbol">i</span>][<span class="hljs-string">k</span>]+DP[<span class="hljs-string">k</span>][<span class="hljs-symbol">k</span>][<span class="hljs-string">j</span>] )<br>DP[<span class="hljs-string">0</span>][<span class="hljs-symbol"></span>][<span class="hljs-string"></span>] 是初始图的邻接矩阵，DP[<span class="hljs-string">n</span>][<span class="hljs-symbol"></span>][<span class="hljs-string"></span>] 就是最终求得的最短路长度矩阵了<br></code></pre></td></tr></table></figure><p>本来一开始是没法做空间优化的， 但是第二个等式， 就保证了可以做空间优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1003</span>;<br>LL dp[N][N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> cmin = [](<span class="hljs-keyword">auto</span> &amp;x, <span class="hljs-keyword">auto</span> y) &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; y) x = y;<br>  &#125;;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k != n; ++k)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != n; ++i)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j != n; ++j)<br>        <span class="hljs-built_in">cmin</span>(dp[i][j], dp[i][k] + dp[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floyd-带路径-----未测试">Floyd 带路径 --- 未测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1003</span>;<br>LL dp[N][N], path[N][N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-built_in">memset</span>(path, <span class="hljs-number">-1</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(path));<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k != n; ++k)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != n; ++i)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j != n; ++j) <span class="hljs-keyword">if</span> (dp[i][j] &gt; dp[i][k] + dp[k][j]) &#123;<br>        path[i][j] = k;<br>      &#125;<br>&#125;<br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (path[x][y] == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;x&#125;;<br>    <span class="hljs-keyword">return</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;x, y&#125;;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">getPath</span>(x, path[x][y]);<br>  <span class="hljs-keyword">auto</span> now = <span class="hljs-built_in">getPath</span>(path[x][y], y);<br>  left.<span class="hljs-built_in">insert</span>(left.<span class="hljs-built_in">end</span>(), now.<span class="hljs-built_in">begin</span>(), now.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>Floyd 算法其它用途：</p><ul><li>找最小环（至少三个节点）考虑环上最大节点 <span class="math inline">\(u\)</span>，<span class="math inline">\(f[u - 1][x][y]\)</span> 和 <span class="math inline">\((y, u), (u, x)\)</span> 构成最小环（值小于 INF 才是真的有环）</li><li>传递闭包：跟最短路完全类似，只是这里加法改成 或运算，可用 bitset 优化成 <span class="math inline">\(O(\frac{n^3}{w})\)</span>，其中 <span class="math inline">\(w = 32, 64\)</span>。</li></ul><h3 id="堆优化-dijkstra">堆优化 Dijkstra</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> edge = std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt;;<br><span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> edge &amp;e)</span> </span>&#123;<br>  std::priority_queue&lt;std::pair&lt;LL, <span class="hljs-keyword">int</span>&gt;&gt; Q;<br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">d</span><span class="hljs-params">(e.size(), INT64_MAX)</span></span>;<br>  d[s] = <span class="hljs-number">0</span>;<br>  Q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> [du, u] = Q.<span class="hljs-built_in">top</span>();<br>    Q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (d[u] != -du) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, w] : e[u]) <span class="hljs-keyword">if</span> (d[v] &gt; d[u] + w) &#123;<br>      d[v] = d[u] + w;<br>      Q.<span class="hljs-built_in">emplace</span>(-d[v], v);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化-dijkstra-弃用">堆优化 Dijkstra (弃用)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> edge = std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt;;<br><span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> edge &amp;e)</span> </span>&#123;<br>  std::priority_queue&lt;std::pair&lt;LL, <span class="hljs-keyword">int</span>&gt;&gt; h;<br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">dist</span><span class="hljs-params">(e.size(), INT64_MAX)</span></span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(e.size())</span></span>;<br>  dist[s] = <span class="hljs-number">0</span>;<br>  h.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>  <span class="hljs-keyword">while</span> (!h.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> [d, u] = h.<span class="hljs-built_in">top</span>();<br>    h.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (vis[u]) <span class="hljs-keyword">continue</span>;<br>    vis[u] = <span class="hljs-number">1</span>;<br>    dist[u] = -d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, w] : e[u]) h.<span class="hljs-built_in">emplace</span>(d - w, v);<br>  &#125;<br>  <span class="hljs-keyword">return</span> dist;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bellman-ford">Bellman-Ford</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> edge = std::vector&lt;std::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BellmanFord</span><span class="hljs-params">(edge &amp;e, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>)</span> </span>&#123;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>  dist[x] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">bool</span> judge = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [u, v, w] : e) <span class="hljs-keyword">if</span> (dist[u] != INT_MAX) &#123;<br>      <span class="hljs-keyword">if</span> (dist[v] &gt; dist[u] + w) &#123;<br>        dist[v] = dist[u] + w;<br>        judge = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!judge) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa">spfa</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> edge = std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt;;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(edge &amp;e, <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = e.<span class="hljs-built_in">size</span>();<br>  std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, INT_MAX)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n)</span>, <span class="hljs-title">inQ</span><span class="hljs-params">(n)</span></span>;<br>  Q.<span class="hljs-built_in">push</span>(x);<br>  inQ[x] = <span class="hljs-number">1</span>;<br>  dist[x] = <span class="hljs-number">0</span>;<br>  ++cnt[x];<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>    Q.<span class="hljs-built_in">pop</span>();<br>    inQ[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, w]: e[u]) &#123;<br>      <span class="hljs-keyword">if</span> (dist[v] &gt; dist[u] + w) &#123;<br>        dist[v] = dist[u] + w;<br>        <span class="hljs-keyword">if</span> (!inQ[v]) &#123;<br>          Q.<span class="hljs-built_in">push</span>(v);<br>          inQ[v] = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (++cnt[v] == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无向图染色问题">无向图染色问题</h2><h3 id="color">2-color</h3><blockquote><p>仅用两种颜色给无向图染色，使得相邻节点不同色，每个连通块考虑即可，每个连通块要么是 2，要么是 0（判断依据有无奇圈）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> LL M = <span class="hljs-number">998244353</span>;<br><span class="hljs-comment">// 图以 0 开始编号</span><br><span class="hljs-function">LL <span class="hljs-title">color2</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; e)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = e.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">auto</span> bfs = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>    std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    Q.<span class="hljs-built_in">push</span>(x);<br>    val[x] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (val[v]) &#123;<br>          <span class="hljs-keyword">if</span> (val[v] != -val[u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          val[v] = -val[u];<br>          Q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;;<br>  LL r = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (val[i] == <span class="hljs-number">0</span>) &#123;<br>    r = r * <span class="hljs-built_in">bfs</span>(i) % M;<br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="the-chromatic-polynomial"><a href="https://www.whitman.edu/mathematics/cgt_online/book/section05.09.html">The Chromatic Polynomial</a></h3><blockquote><p>对于一般的 <span class="math inline">\(n\)</span>-color 问题对应的 <a href="https://www.whitman.edu/mathematics/cgt_online/book/section05.09.html">The Chromatic Polynomial</a> 可在书 <a href="https://www.whitman.edu/mathematics/cgt_online/book/">Combinatorics and Graph Theory</a> 中找到。思想就是破圈和缩点的做法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> BINT = boost::multiprecision::cpp_int;<br><br><span class="hljs-comment">// chromaticPoly of a tree with n node</span><br><span class="hljs-function">std::vector&lt;BINT&gt; <span class="hljs-title">chromaticPoly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-function">std::vector&lt;BINT&gt; <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  BINT now&#123;n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    r[i + <span class="hljs-number">1</span>] = now;<br>    now = -now * (n - <span class="hljs-number">1</span> - i) / (i + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function">std::vector&lt;BINT&gt; <span class="hljs-title">colorConnect</span><span class="hljs-params">(std::vector&lt;std::set&lt;<span class="hljs-keyword">int</span>&gt;&gt; e)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = e.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(n)</span>, <span class="hljs-title">v2</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">chromaticPoly</span>(n); <span class="hljs-comment">// 可以先预处理出来</span><br>  <span class="hljs-keyword">auto</span> subtract = [](std::vector&lt;BINT&gt; &amp;a, std::vector&lt;BINT&gt; b) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != b.<span class="hljs-built_in">size</span>(); ++i) a[i] -= b[i];<br>  &#125;;<br>  std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>  Q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>  v1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">auto</span> enow = e;<br>  <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>    v2[u] = <span class="hljs-number">1</span>;<br>    Q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (!v2[v]) &#123;<br>      <span class="hljs-keyword">if</span> (v1[v]) &#123;<br>        std::vector&lt;std::set&lt;<span class="hljs-keyword">int</span>&gt;&gt; ed;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, now = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>          <span class="hljs-keyword">if</span> (i != u &amp;&amp; i != v) &#123;<br>            p[i] = now++;<br>          &#125; <span class="hljs-keyword">else</span> p[i] = n - <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (i != u &amp;&amp; i != v) &#123;<br>          std::set&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : enow[i]) tmp.<span class="hljs-built_in">insert</span>(p[x]);<br>          ed.<span class="hljs-built_in">emplace_back</span>(tmp);<br>        &#125;<br>        enow[u].<span class="hljs-built_in">erase</span>(v);<br>        enow[v].<span class="hljs-built_in">erase</span>(u);<br>        std::set&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : enow[u]) tmp.<span class="hljs-built_in">insert</span>(p[x]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : enow[v]) tmp.<span class="hljs-built_in">insert</span>(p[x]);<br>        ed.<span class="hljs-built_in">emplace_back</span>(tmp);<br>        <span class="hljs-built_in">subtract</span>(r, <span class="hljs-built_in">colorConnect</span>(ed));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        Q.<span class="hljs-built_in">push</span>(v);<br>        v1[v] = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    e = enow;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function">std::vector&lt;BINT&gt; <span class="hljs-title">color</span><span class="hljs-params">(std::vector&lt;std::set&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;e)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = e.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">auto</span> connect = [&amp;](<span class="hljs-keyword">int</span> x) &#123;<br>    std::vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-built_in">visc</span>(n);<br>    std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    Q.<span class="hljs-built_in">push</span>(x);<br>    visc[x] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (!visc[v]) &#123;<br>        visc[v] = <span class="hljs-number">1</span>;<br>        Q.<span class="hljs-built_in">push</span>(v);<br>      &#125;<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, now = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (visc[i]) &#123;<br>      p[i] = now++;<br>    &#125;<br>    std::vector&lt;std::set&lt;<span class="hljs-keyword">int</span>&gt;&gt; ec;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (visc[i]) &#123;<br>      std::set&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : e[i]) tmp.<span class="hljs-built_in">insert</span>(p[x]);<br>      ec.<span class="hljs-built_in">emplace_back</span>(tmp);<br>      vis[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ec;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> mul = [](std::vector&lt;BINT&gt; &amp;a, std::vector&lt;BINT&gt; b) &#123;<br>    std::vector&lt;BINT&gt; <span class="hljs-built_in">c</span>(a.<span class="hljs-built_in">size</span>() + b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != a.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j != b.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>        c[i + j] += a[i] * b[j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>  &#125;;<br>  <span class="hljs-function">std::vector&lt;BINT&gt; <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>    r = <span class="hljs-built_in">mul</span>(r, <span class="hljs-built_in">colorConnect</span>(<span class="hljs-built_in">connect</span>(i)));<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> cas = <span class="hljs-number">1</span>;<br>  std::cin &gt;&gt; cas;<br>  <span class="hljs-keyword">while</span> (cas--) &#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    std::vector&lt;std::set&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>      <span class="hljs-keyword">int</span> u, v;<br>      std::cin &gt;&gt; u &gt;&gt; v;<br>      --u; --v;<br>      e[u].<span class="hljs-built_in">insert</span>(v);<br>      e[v].<span class="hljs-built_in">insert</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : <span class="hljs-built_in">color</span>(e)) std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    std::cout &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="连通性问题">连通性问题</h2><h3 id="kosaraju-缩点算法">Kosaraju 缩点算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Scc</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n, nScc;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; vis, color, order;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; e, e2;<br>  <span class="hljs-built_in">Scc</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n * <span class="hljs-number">2</span>) &#123;<br>    nScc = <span class="hljs-number">0</span>;<br>    e.<span class="hljs-built_in">resize</span>(n);<br>    e2.<span class="hljs-built_in">resize</span>(n);<br>    vis.<span class="hljs-built_in">resize</span>(n);<br>    color.<span class="hljs-built_in">resize</span>(n);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>    e2[v].<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (!vis[v]) <span class="hljs-built_in">dfs</span>(v);<br>    order.<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    color[u] = nScc;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e2[u]) <span class="hljs-keyword">if</span> (!color[v]) <span class="hljs-built_in">dfs2</span>(v);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kosaraju</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!vis[i]) <span class="hljs-built_in">dfs</span>(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = order.<span class="hljs-built_in">rbegin</span>(); it != order.<span class="hljs-built_in">rend</span>(); ++it) <span class="hljs-keyword">if</span> (!color[*it]) &#123;<br>      ++nScc;<br>      <span class="hljs-built_in">dfs2</span>(*it);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="sat">2-SAT</h3><p>Kosaraju 算法通过两次 dfs，给强连通分量进行染色，染色数就是强联通分量数，最后缩点后得到的就是一个有向无环图(DAG)，如果有相邻（仅取一个）节点在同一个强连通分量中，那么显然不存在解，否则我们取颜色编号大的连通分量（一定有解！）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// n / 2 对 (2i, 2i + 1)，每对选出一个元素，使得无矛盾</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">twoSAT</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n, nScc;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; vis, color, order;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; e, e2;<br>  <span class="hljs-built_in">twoSAT</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n * <span class="hljs-number">2</span>) &#123;<br>    nScc = <span class="hljs-number">0</span>;<br>    e.<span class="hljs-built_in">resize</span>(n);<br>    e2.<span class="hljs-built_in">resize</span>(n);<br>    vis.<span class="hljs-built_in">resize</span>(n);<br>    color.<span class="hljs-built_in">resize</span>(n);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>    e2[v].<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (!vis[v]) <span class="hljs-built_in">dfs</span>(v);<br>    order.<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>    color[u] = nScc;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e2[u]) <span class="hljs-keyword">if</span> (!color[v]) <span class="hljs-built_in">dfs2</span>(v);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kosaraju</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!vis[i]) <span class="hljs-built_in">dfs</span>(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = order.<span class="hljs-built_in">rbegin</span>(); it != order.<span class="hljs-built_in">rend</span>(); ++it) <span class="hljs-keyword">if</span> (!color[*it]) &#123;<br>      ++nScc;<br>      <span class="hljs-built_in">dfs2</span>(*it);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Kosaraju</span>();<br>    <span class="hljs-comment">// 选择颜色编号大的强连通分量</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">choose</span><span class="hljs-params">(nScc + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">int</span> c1 = color[i], c2 = color[i + <span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">if</span> (c1 == c2) <span class="hljs-keyword">return</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt;();<br>      <span class="hljs-keyword">if</span> (choose[c1] || choose[c2]) <span class="hljs-keyword">continue</span>;<br>      choose[std::<span class="hljs-built_in">max</span>(c1, c2)] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n / <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i * <span class="hljs-number">2</span> &lt; n; ++i) r[i] = (choose[color[i * <span class="hljs-number">2</span>]] ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>此内容包含 <a href="https://oi-wiki.org/graph/scc/">强连通分量</a>，采用其中的 Kosaraju 算法缩点。参考 <a href="https://oi-wiki.org/graph/2-sat/">OI-wiki</a> 和 <a href="https://wenku.baidu.com/view/31fd7200bed5b9f3f90f1ce2.html">百度文库</a>。<a href="https://codeforces.com/contest/1239/problem/D">例题 1</a>：<a href="https://codeforces.com/contest/1239/submission/98425115">答案</a>，<a href="https://codeforces.com/gym/101987">例题 2: K-TV Show Game</a>：<a href="https://codeforces.com/gym/101987/submission/98427737">答案</a>，有些特殊的 2-SAT 可以用奇偶性解决，例如: <a href="https://codeforces.com/contest/1438/problem/C">1438C</a></p></blockquote><p><a href="https://oi-wiki.org/graph/cut/">OI-wiki 割点割边讲解</a></p><h3 id="割点无向图中删除该点使得连通分量数量增多的节点">割点（无向图中删除该点使得连通分量数量增多的节点）</h3><p>首先 dfs 序给出每个节点的编号记作 <code>dfs[i]</code>，再来一个数组 low，表示不经过父节点能够到达的编号最小的点。显然如果至少有一个儿子满足的 low 值不超过它的 dfs 值，那么此节点就是割点（但是根节点除外，根节点始终满足，如果根节点有大于一个真儿子，那么必然是割点）。不难看出这是割点的冲要条件，因此问题就转化成求 dfs 和 low 了。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P3388">LOJ3388</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cutVertex</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; e)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = e.<span class="hljs-built_in">size</span>(), cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(n)</span>, <span class="hljs-title">low</span><span class="hljs-params">(n)</span>, <span class="hljs-title">flag</span><span class="hljs-params">(n)</span>, r</span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; Tarjan = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; <span class="hljs-keyword">void</span> &#123;<br>    low[u] = dfs[u] = ++cnt;<br>    <span class="hljs-keyword">int</span> ch = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>      <span class="hljs-keyword">if</span> (dfs[v] == <span class="hljs-number">0</span>) &#123;<br>        ++ch;<br>        <span class="hljs-built_in">Tarjan</span>(v, u);<br>        low[u] = std::<span class="hljs-built_in">min</span>(low[u], low[v]);<br>        <span class="hljs-keyword">if</span> (u != fa &amp;&amp; low[v] &gt;= dfs[u]) flag[u] = <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v != fa) &#123;<br>        low[u] = std::<span class="hljs-built_in">min</span>(low[u], dfs[v]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (u == fa &amp;&amp; ch &gt; <span class="hljs-number">1</span>) flag[u] = <span class="hljs-number">1</span>;<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (dfs[i] == <span class="hljs-number">0</span>) <span class="hljs-built_in">Tarjan</span>(i, i);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (flag[i]) r.<span class="hljs-built_in">emplace_back</span>(i);<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="割边无向图中删除该边使得连通分量数量增多的边">割边（无向图中删除该边使得连通分量数量增多的边）</h3><p>与割点处理同理，只是不用特判根节点。注意到做一次 dfs 后，<strong>不在 dfs 路径上的边不可能为割边</strong>！但是为了处理重边的情况，没办法只能用 vector 版链式前向星存边了。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/T103481">LOJ T103481</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CutEdge</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n, cnt;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; g;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; e, flag, dfs, low;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> inEdgeNum)</span> </span>&#123;<br>    low[u] = dfs[u] = ++cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : g[u]) &#123;<br>      <span class="hljs-keyword">int</span> v = e[i];<br>      <span class="hljs-keyword">if</span> (dfs[v] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">Tarjan</span>(v, i);<br>        low[u] = std::<span class="hljs-built_in">min</span>(low[u], low[v]);<br>        <span class="hljs-keyword">if</span> (low[v] &gt; dfs[u]) flag[i] = flag[i ^ <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((i ^ <span class="hljs-number">1</span>) != inEdgeNum) &#123;<br>        low[u] = std::<span class="hljs-built_in">min</span>(low[u], dfs[v]);<br>      &#125;<br>    &#125;<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">CutEdge</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">g</span>(_n), <span class="hljs-built_in">dfs</span>(n), <span class="hljs-built_in">low</span>(n), <span class="hljs-built_in">cnt</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    g[u].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(v);<br>    flag.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>    g[v].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(u);<br>    flag.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (dfs[i] == <span class="hljs-number">0</span>) <span class="hljs-built_in">Tarjan</span>(i, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : flag) r += x;<br>    <span class="hljs-keyword">return</span> r / <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="图的匹配算法"><a href="https://oi-wiki.org/topic/graph-matching/graph-match/">图的匹配算法</a></h2><p>OI-wiki 上有专题专门讲这个的，分最大匹配和最大权匹配，对于特殊的图（例如二分图）有<a href="https://oi-wiki.org/topic/graph-matching/bigraph-match/">特殊的算法</a>，例如可以增加源点和汇点转化成网络流问题，用下面 Dinic 算法在 <span class="math inline">\(O(\sqrt{n} m)\)</span> 解决。</p><blockquote><p>其中一般图的最大匹配可以参考 <a href="https://uoj.ac/submission/221981">Min_25 的模板</a></p></blockquote><h2 id="网络流">网络流</h2><h3 id="有向图-s-t-最大流-dinic-算法-on2-m对偶问题s-t-最大流等于-s-t-最小割">有向图 S-T 最大流 Dinic 算法 <span class="math inline">\(O(n^2 m)\)</span>（对偶问题：S-T 最大流等于 S-T 最小割）</h3><p>参考资料：<a href="https://oi-wiki.org/graph/flow/max-flow/">OI-wiki</a> 和 <a href="https://www.cnblogs.com/owenyu/p/6852664.html">最大流算法-ISAP</a>，<a href="https://blog.csdn.net/lym940928/article/details/90209172?tdsourcetag=s_pcqq_aiomsg">需要反向边的原因的例子说明</a>，下面代码借鉴于 jiangly。注意代码本质上是支持动态更新的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dinic</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span><br>  <span class="hljs-comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span><br>  std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; e;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; g;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; cur, h;<br>  <span class="hljs-comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    h.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">-1</span>);<br>    std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    h[s] = <span class="hljs-number">0</span>;<br>    Q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : g[u]) &#123;<br>        <span class="hljs-keyword">auto</span> [v, c] = e[i];<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == <span class="hljs-number">-1</span>) &#123;<br>          h[v] = h[u] + <span class="hljs-number">1</span>;<br>          Q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h[t] != <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span><br>  <span class="hljs-function">LL <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> t, LL f)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == t || f == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> f;<br>    LL r = f;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;i = cur[u]; i &lt; g[u].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>      <span class="hljs-keyword">int</span> j = g[u][i];<br>      <span class="hljs-keyword">auto</span> [v, c] = e[j];<br>      <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == h[u] + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-built_in">dfs</span>(v, t, std::<span class="hljs-built_in">min</span>(r, <span class="hljs-built_in">LL</span>(c)));<br>        e[j].second -= a;<br>        e[j ^ <span class="hljs-number">1</span>].second += a;<br>        r -= a;<br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> f;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f - r;<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Dinic</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">g</span>(n) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    g[u].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(v, c);<br>    g[v].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(u, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-function">LL <span class="hljs-title">maxFlow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    LL r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(s, t)) &#123;<br>      cur.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>      r += <span class="hljs-built_in">dfs</span>(s, t, INT64_MAX);<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用-unordered_map-直接存边的-dinic-算法注意结果是否超-int">使用 unordered_map 直接存边的 Dinic 算法（注意结果是否超 int）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dinic</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;<br>  std::vector&lt;std::unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; g;<br>  std::vector&lt;std::unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator&gt; cur;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; h;<br>  <span class="hljs-comment">// h[i] 表示 bfs 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路。</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    h.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">-1</span>);<br>    std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    h[s] = <span class="hljs-number">0</span>;<br>    Q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, c] : g[u]) &#123;<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == <span class="hljs-number">-1</span>) &#123;<br>          h[v] = h[u] + <span class="hljs-number">1</span>;<br>          Q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h[t] != <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// f 表示从 u 点出发拥有的最大流量，输出的是 u 到 t 的最大流量</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> f)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == t || f == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> f;<br>    <span class="hljs-keyword">int</span> r = f;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it = cur[u]; it != g[u].<span class="hljs-built_in">end</span>(); ++it) &#123;<br>      <span class="hljs-keyword">int</span> v = it-&gt;first;<br>      <span class="hljs-keyword">if</span> (it-&gt;second &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == h[u] + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-built_in">dfs</span>(v, t, std::<span class="hljs-built_in">min</span>(r, it-&gt;second));<br>        it-&gt;second -= a;<br>        g[v][u] += a;<br>        r -= a;<br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> f;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f - r;<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Dinic</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">g</span>(n), <span class="hljs-built_in">cur</span>(n) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-comment">// 注意这里一定要这样！</span><br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    g[u][v] += c;<br>    g[v][u] += <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxFlow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>(s, t)) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cur[i] = g[i].<span class="hljs-built_in">begin</span>();<br>      r += <span class="hljs-built_in">dfs</span>(s, t, INT_MAX);<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="有向图-s-t-最大流-isap-算法-弃用">有向图 S-T 最大流 ISAP 算法 (弃用)</h3><p>核心就是一句话，Dinic 算法中，每一轮需要进行一次 BFS，可以被优化，并且还有许多细节上的优化。</p><blockquote><p>折腾了半天发现并没有比 Dinic 快，本质原因是计算 dfs 完之后更新 <code>d</code>，按照上面的做法会极大的增加 <code>aug(s, INT_MAX)</code> 次数。但是确实比 <a href="https://codeforces.com/contest/1473/submission/104862713">直接更新 d</a> 更快（可能时因为直接更新高度代码会写的很绕，因为可能变换的高度不止自己一个，父节点的高度也可能要更新），而在下面 HLPP 中用这这技巧又会特别慢，可惜~</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 结合 https://www.cnblogs.com/owenyu/p/6852664.html 在实现上进行了相应的修改</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ISAP</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n, s, t;<br>  <span class="hljs-comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span><br>  <span class="hljs-comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span><br>  std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; e;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; g;<br>  <span class="hljs-comment">// cur[u] 表示以 u 为起点当前没被增广过的边</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; cur, d, gap;<br>  <span class="hljs-comment">// d[u] 表示残余网络中 从 u 到 t 的最短距离，注意到可以把 d[u] 理解成连续变化的（否则很难正确的更新 d)。</span><br>  <span class="hljs-comment">// gap[x] 表示 d[u] = x 的节点个数, 用于优化</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _s, <span class="hljs-keyword">int</span> <span class="hljs-keyword">_t</span>)</span> </span>&#123;<br>    s = _s;<br>    t = <span class="hljs-keyword">_t</span>;<br>    d.<span class="hljs-built_in">assign</span>(n, n);<br>    std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    d[t] = <span class="hljs-number">0</span>;<br>    Q.<span class="hljs-built_in">push</span>(t);<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : g[u]) &#123;<br>        <span class="hljs-keyword">int</span> v = e[i].first, c = e[i ^ <span class="hljs-number">1</span>].second;<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; d[v] == n) &#123;<br>          d[v] = d[u] + <span class="hljs-number">1</span>;<br>          Q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>      &#125;<br>    &#125;<br>    gap.<span class="hljs-built_in">assign</span>(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : d) ++gap[x];<br>    cur.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-comment">// 从 u 开始到汇点 t 不超过 f 的最大流，如果取到了 f 说明后面还有增广的可能</span><br>  <span class="hljs-function">LL <span class="hljs-title">aug</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, LL f)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == t) <span class="hljs-keyword">return</span> f;<br>    LL r = f;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;i = cur[u]; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(g[u].<span class="hljs-built_in">size</span>()); ++i) &#123;<br>      <span class="hljs-keyword">int</span> j = g[u][i];<br>      <span class="hljs-keyword">auto</span> [v, c] = e[j];<br>      <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; d[u] == d[v] + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-built_in">aug</span>(v, std::<span class="hljs-built_in">min</span>(r, <span class="hljs-built_in">LL</span>(c)));<br>        e[j].second -= a;<br>        e[j ^ <span class="hljs-number">1</span>].second += a;<br>        r -= a;<br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> f;<br>      &#125;<br>    &#125;<br>    cur[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (--gap[d[u]] == <span class="hljs-number">0</span>) d[s] = n;<br>    ++gap[++d[u]];<br>    <span class="hljs-keyword">return</span> f - r;<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ISAP</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">g</span>(_n) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    g[u].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(v, c);<br>    g[v].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(u, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-function">LL <span class="hljs-title">maxFlow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _s, <span class="hljs-keyword">int</span> <span class="hljs-keyword">_t</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(_s, <span class="hljs-keyword">_t</span>);<br>    LL r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (d[s] &lt; n) r += <span class="hljs-built_in">aug</span>(s, INT64_MAX);<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="有向图-s-t-最大流的最高标号预流推进算法hlpp-on2-sqrtm-算法">有向图 S-T 最大流的最高标号预流推进算法（HLPP） <span class="math inline">\(O(n^2 \sqrt{m})\)</span> 算法</h3><p>1988 年 <a href="https://www.cs.princeton.edu/courses/archive/fall07/cos521/handouts/p921-goldberg.pdf">Tarjan, Goldberg</a> 提出次方法，1989 年 <a href="https://www.sciencedirect.com/science/article/pii/S0020019099000198">Joseph Cheriyan, Kurt Mehlhorn</a> 证明了该方法时间复杂度为 <span class="math inline">\(O(n^2 \sqrt{m})\)</span>，直接看 <a href="https://oi-wiki.org/graph/flow/max-flow/">OI-wiki</a> 最后一张图（下载下来放大）还是很好理解的，Push-Relabel 那段没讲清楚，跳过的看就行，再结合 <a href="(https://www.cnblogs.com/owenyu/p/6858123.html)">cnblog</a> 理解一下优化（不要看代码）就掌握了。然后自己写代码即可。</p><p>个人理解其实此算法 ISAP 的优化，Dinic 和 ISAP 都要递归找可行流，但是此算法，先给了再说，多了的再取出来即可，这样不用递归了。</p><p>模板例题：<a href="https://vjudge.net/problem/LibreOJ-127">LibreOJ-127</a>，跑的太慢，有待提升。</p><p>注意到每次推流的时候，当前节点时有水的（且高度小于 n 的，高度为 n 说明水是积水）里面高度最高的，因此更新高度的时候就不会出现问题！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HLPP</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span><br>  <span class="hljs-comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span><br>  std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; e;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; g;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; h;<br>  std::vector&lt;LL&gt; ex;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addFlow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    ex[e[i ^ <span class="hljs-number">1</span>].first] -= a;<br>    ex[e[i].first] += a;<br>    e[i].second -= a;<br>    e[i ^ <span class="hljs-number">1</span>].second += a;<br>  &#125;;<br>  <span class="hljs-comment">// 首先初始化 u 到 t 的距离得到 d[u]</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>    Q.<span class="hljs-built_in">push</span>(t);<br>    h[t] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> u = Q.<span class="hljs-built_in">front</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : g[u]) &#123;<br>        <span class="hljs-keyword">int</span> v = e[i].first;<br>        <span class="hljs-keyword">if</span> (e[i ^ <span class="hljs-number">1</span>].second &gt; <span class="hljs-number">0</span> &amp;&amp; h[v] == n) &#123;<br>          h[v] = h[u] + <span class="hljs-number">1</span>;<br>          Q.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h[t] == n;<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HLPP</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">ex</span>(n), <span class="hljs-built_in">h</span>(n, n), <span class="hljs-built_in">g</span>(n) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    g[u].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(v, c);<br>    g[v].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(u, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-function">LL <span class="hljs-title">maxFlow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">init</span>(s, t)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">gap</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : h) ++gap[x];<br>    std::priority_queue&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; pq;<br>    <span class="hljs-comment">// push 之后 ex[u] 还大于 0 就说明当前超载了，需要提升高度</span><br>    <span class="hljs-keyword">auto</span> push = [&amp;](<span class="hljs-keyword">int</span> u) -&gt; <span class="hljs-keyword">bool</span> &#123;<br>      <span class="hljs-keyword">if</span> (ex[u] == <span class="hljs-number">0</span> || h[u] == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : g[u]) &#123;<br>        <span class="hljs-keyword">auto</span> [v, c] = e[i];<br>        <span class="hljs-comment">// 注意 push(s) 的时候不用管高度的问题</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span> || (h[u] != h[v] + <span class="hljs-number">1</span> &amp;&amp; u != s)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">int</span> a = std::<span class="hljs-built_in">min</span>(ex[u], <span class="hljs-built_in">LL</span>(c));<br>        <span class="hljs-built_in">addFlow</span>(i, a);<br>        <span class="hljs-keyword">if</span> (!vis[v]) &#123;<br>          pq.<span class="hljs-built_in">push</span>(&#123;h[v], v&#125;);<br>          vis[v] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ex[u] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;;<br>    ex[s] = INT64_MAX;<br>    <span class="hljs-built_in">push</span>(s);<br>    h[s] = n;<br>    vis[s] = vis[t] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 起点和终点不会丢进队列中</span><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">int</span> u = pq.<span class="hljs-built_in">top</span>().second;<br>      pq.<span class="hljs-built_in">pop</span>();<br>      vis[u] = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-built_in">push</span>(u)) &#123;<br>        <span class="hljs-keyword">if</span> (--gap[h[u]] == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (h[i] &gt; h[u]) h[i] = n;<br>        &#125;<br>        h[u] = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : g[u]) &#123;<br>          <span class="hljs-keyword">auto</span> [v, c] = e[i];<br>          <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; h[u] &gt; h[v]) h[u] = h[v];<br>        &#125;<br>        ++gap[++h[u]];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ex[t];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="无向图全局最小割-stoer-wagner-算法"><a href="https://www.cs.dartmouth.edu/~ac/Teach/CS105-Winter05/Handouts/stoerwagner-mincut.pdf">无向图全局最小割 Stoer-Wagner 算法</a></h3><p>无向图的 S-T 最小割可以通过 S-T 最大流来做（在 addEdge(u, v, c) 中两个边的权值都是 c 即可！）。 对任意给定的 S 和 T，全局最小割必然是 S-T 最小割或者 S-T 结合成一个节点后得到新图的最小割。Stoer-Wagner 的论文给了一种简单的方式给出某两个点的 S-T 最小割的办法，那么这个最小割的答案存下来，之后再合并这两个点再继续搞即可。而这个方式叫做 cut-of-the-phase，具体说就是，任取一个点，然后每次往这个点中丢 most tightly connected 点，论文中证明了这种方式得到的图，每一步都是最后两个节点的当前图最小割，所以所有点丢进来之后，最后两个节点的割就是原图的这个两个点的最小割。（直接图原论文很好理解，而且有例子说明）</p><p>例题：<a href="https://www.luogu.com.cn/problem/P5632">LOJ5632</a></p><h3 id="无向图全局最小割-stoer-wagner-算法邻接矩阵-on3-实现">无向图全局最小割 Stoer-Wagner 算法，邻接矩阵 <span class="math inline">\(O(n^3)\)</span> 实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 做完 minCut 之后原图就毁了</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoerWagner</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; g;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; del;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    del[s] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      g[i][t] = (g[t][i] += g[s][i]);<br>    &#125;<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">StoerWagner</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">del</span>(n), <span class="hljs-built_in">g</span>(n, std::vector&lt;<span class="hljs-keyword">int</span>&gt;(n)) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    g[u][v] += c;<br>    g[v][u] += c;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-keyword">int</span> cnt, <span class="hljs-keyword">int</span> &amp;s, <span class="hljs-keyword">int</span> &amp;t) -&gt; <span class="hljs-keyword">int</span> &#123;<br>      std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">vis</span>(n), <span class="hljs-built_in">d</span>(n);<br>      <span class="hljs-keyword">auto</span> push = [&amp;](<span class="hljs-keyword">int</span> x)&#123;<br>        vis[x] = <span class="hljs-number">1</span>;<br>        d[x] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!del[i] &amp;&amp; !vis[i]) d[i] += g[x][i];<br>      &#125;;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br>        <span class="hljs-built_in">push</span>(t);<br>        s = t;<br>        t = std::<span class="hljs-built_in">max_element</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>()) - d.<span class="hljs-built_in">begin</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> d[t];<br>    &#125;;<br>    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>, r = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>      r = std::<span class="hljs-built_in">min</span>(r, <span class="hljs-built_in">f</span>(i, s, t));<br>      <span class="hljs-built_in">merge</span>(s, t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> r == INT_MAX ? <span class="hljs-number">0</span> : r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="无向图全局最小割-stoer-wagner-算法邻接-unorded_map-优先队列-onm-n2-log-n-实现仅稀疏图跑的快-稠密图还不如-on3-的算法">无向图全局最小割 Stoer-Wagner 算法，邻接 unorded_map + 优先队列 <span class="math inline">\(O(nm + n^2 log n)\)</span> 实现（仅稀疏图跑的快, 稠密图还不如 <span class="math inline">\(O(n^3)\)</span> 的算法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 做完 minCut 之后原图就毁了</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoerWagner</span> &#123;</span><br>  <span class="hljs-keyword">int</span> n;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; d, del;<br>  std::unordered_map&lt;<span class="hljs-keyword">int</span>, std::unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; g;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;s, <span class="hljs-keyword">int</span> &amp;t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (g[s].<span class="hljs-built_in">size</span>() &gt; g[t].<span class="hljs-built_in">size</span>()) std::<span class="hljs-built_in">swap</span>(s, t);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, c] : g[s]) &#123;<br>      g[x][t] = (g[t][x] += c);<br>      g[x].<span class="hljs-built_in">erase</span>(s);<br>    &#125;<br>    g.<span class="hljs-built_in">erase</span>(s);<br>    g[t].<span class="hljs-built_in">erase</span>(t);<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">StoerWagner</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">d</span>(n), <span class="hljs-built_in">del</span>(n) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    g[u][v] += c;<br>    g[v][u] += c;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-keyword">int</span> &amp;s, <span class="hljs-keyword">int</span> &amp;t) -&gt; <span class="hljs-keyword">int</span> &#123;<br>      std::priority_queue&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; Q;<br>      std::<span class="hljs-built_in">fill</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>      std::<span class="hljs-built_in">fill</span>(del.<span class="hljs-built_in">begin</span>(), del.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">auto</span> push = [&amp;](<span class="hljs-keyword">int</span> x)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [i, c] : g[x]) <span class="hljs-keyword">if</span> (!del[i]) &#123;<br>          Q.<span class="hljs-built_in">push</span>(&#123;d[i] += c, i&#125;);<br>        &#125;<br>        del[x] = <span class="hljs-number">1</span>;<br>      &#125;;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">push</span>(t);<br>        s = t;<br>        <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>          t = Q.<span class="hljs-built_in">top</span>().second;<br>          <span class="hljs-keyword">if</span> (!del[t]) <span class="hljs-keyword">break</span>;<br>          Q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> d[t];<br>    &#125;;<br>    <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>, r = INT_MAX;<br>    <span class="hljs-keyword">while</span>(--n) &#123;<br>      r = std::<span class="hljs-built_in">min</span>(r, <span class="hljs-built_in">f</span>(s, t));<br>      <span class="hljs-built_in">merge</span>(s, t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> r == INT_MAX ? <span class="hljs-number">0</span> : r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="无向图全局最小割-stoer-wagner-算法邻接表-优先队列-onm-n2-log-n-实现仅稀疏图跑的快-稠密图还不如-on3-的算法还是-tle-属实可惜">无向图全局最小割 Stoer-Wagner 算法，邻接表 + 优先队列 <span class="math inline">\(O(nm + n^2 log n)\)</span> 实现（仅稀疏图跑的快, 稠密图还不如 <span class="math inline">\(O(n^3)\)</span> 的算法还是 TLE 属实可惜）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Edge = std::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;;<br><span class="hljs-function">LL <span class="hljs-title">StoerWagner</span><span class="hljs-params">(std::vector&lt;Edge&gt; e, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> f = [&amp;]() -&gt; std::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &#123;<br>    std::priority_queue&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; Q;<br>    std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-built_in">in</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [u, v, w] : e) <span class="hljs-keyword">if</span> (u != v) in[v].<span class="hljs-built_in">emplace_back</span>(u, w);<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">del</span><span class="hljs-params">(n)</span>, <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">auto</span> push = [&amp;](<span class="hljs-keyword">int</span> x)&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [i, c] : in[x]) <span class="hljs-keyword">if</span> (!del[i]) &#123;<br>        Q.<span class="hljs-built_in">push</span>(&#123;d[i] += c, i&#125;);<br>      &#125;<br>      del[x] = <span class="hljs-number">1</span>;<br>    &#125;;<br>    <span class="hljs-keyword">int</span> s, t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-built_in">push</span>(t);<br>      s = t;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (Q.<span class="hljs-built_in">empty</span>()) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!del[i]) Q.<span class="hljs-built_in">push</span>(&#123;d[i], i&#125;);<br>        &#125;<br>        t = Q.<span class="hljs-built_in">top</span>().second;<br>        Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (!del[t]) <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;d[t], s, t&#125;;<br>  &#125;;<br>  <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>, r = INT_MAX;<br>  <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">1</span> &amp;&amp; r &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">auto</span> [dt, s, t] = <span class="hljs-built_in">f</span>();<br>    r = std::<span class="hljs-built_in">min</span>(r, dt);<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (i != s &amp;&amp; i != t) id[i] = ++cnt;<br>    id[s] = id[t] = ++cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[u, v, w] : e) &#123;<br>      u = id[u];<br>      v = id[v];<br>    &#125;<br>    --n;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r == INT_MAX ? <span class="hljs-number">0</span> : r;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小费用最大流">最小费用最大流</h3><p>在最大流的前提下，追求费用最小。一般通用的做法：每次找一条费用最小的可行流。 反向边的费用是原边的相反数，这样就会出现负边，但是因此初始反向边容量为 0，所以初始情况可以理解为图中没有负边。从源点到汇点的费用必然是非负的（因为我们每次走最小费用，所以每次的费用都是非降的，而初始没有负边。）当然这并不代表途中没有经过负边。至于为什么可以用 Dijkstra，很多博客都有介绍。下面代码中 h 为真实的距离，注意到 <code>h[s]</code>始终为 0，对于同一个点，每次的真实距离不减，它将作为下一次求最短路的势。这种思想也称为 Johnson 最短路径算法算法。可以 <span class="math inline">\(O(n m \log m)\)</span> 解决全源最短路问题。</p><p>我们这样再看一次：每次我们找一条最短路径，取流了之后，相当于给这条路径加了反向边，其它的都没有变化，如果我们把当前距离当作势，那么加的这些反向边，其实都可以看作加入了长度为 0 的边。那么我们一直这样搞，就相当于一直没有加入负边！搞定。</p><p>由于一般费用最小的路径只有一条，所以我们不妨在求最小费用的时候把前缀边找到，这样就可以直接求路径的最大流了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flow</span> &#123;</span><br>  <span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">1e9</span>;<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-comment">// e[i] 表示第 i 条边的终点和容量，注意存边的时候 e[i ^ 1] 是 e[i] 的反向边。</span><br>  <span class="hljs-comment">// g[u] 存的是所有以 u 为起点的边，这就很像链式前向星的做法</span><br>  std::vector&lt;std::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; e;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; g;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; h, path;<br>  <span class="hljs-comment">// h[i] 表示 从 s 到 i 的距离，如果找到了 t，那么就说明找到了增广路，作为下一次求距离的势。</span><br>  <span class="hljs-comment">// path[v] 表示从 s 到 v 的最短路中，path[v] 的终点指向 v</span><br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    std::priority_queue&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; Q;<br>    std::<span class="hljs-built_in">fill</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n, INF)</span></span>;<br>    d[s] = <span class="hljs-number">0</span>;<br>    Q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>      <span class="hljs-keyword">auto</span> [du, u] = Q.<span class="hljs-built_in">top</span>();<br>      Q.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">if</span> (d[u] != -du) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : g[u]) &#123;<br>        <span class="hljs-keyword">auto</span> [v, c, w] = e[i];<br>        w += h[u] - h[v];<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span> &amp;&amp; d[v] &gt; d[u] + w) &#123;<br>          d[v] = d[u] + w;<br>          path[v] = i;<br>          Q.<span class="hljs-built_in">push</span>(&#123;-d[v], v&#125;);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> ((h[i] += d[i]) &gt; INF) h[i] = INF;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h[t] != INF;<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Flow</span>(<span class="hljs-keyword">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">h</span>(n), <span class="hljs-built_in">path</span>(n), <span class="hljs-built_in">g</span>(n) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span>;<br>    g[u].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(v, c, w);<br>    g[v].<span class="hljs-built_in">emplace_back</span>(e.<span class="hljs-built_in">size</span>());<br>    e.<span class="hljs-built_in">emplace_back</span>(u, <span class="hljs-number">0</span>, -w);<br>  &#125;<br>  <span class="hljs-function">std::pair&lt;LL, LL&gt; <span class="hljs-title">maxFlow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>    LL flow = <span class="hljs-number">0</span>, cost = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Dijkstra</span>(s, t)) &#123;<br>      <span class="hljs-keyword">int</span> f = INT_MAX, now = t;<br>      std::vector&lt;<span class="hljs-keyword">int</span>&gt; r;<br>      <span class="hljs-keyword">while</span> (now != s) &#123;<br>        r.<span class="hljs-built_in">emplace_back</span>(path[now]);<br>        f = std::<span class="hljs-built_in">min</span>(f, std::get&lt;<span class="hljs-number">1</span>&gt;(e[path[now]]));<br>        now = std::get&lt;<span class="hljs-number">0</span>&gt;(e[path[now] ^ <span class="hljs-number">1</span>]);<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : r) &#123;<br>        std::get&lt;<span class="hljs-number">1</span>&gt;(e[i]) -= f;<br>        std::get&lt;<span class="hljs-number">1</span>&gt;(e[i ^ <span class="hljs-number">1</span>]) += f;<br>      &#125;<br>      flow += f;<br>      cost += <span class="hljs-built_in">LL</span>(f) * h[t];<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;flow, cost&#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="上下界网络流"><a href="https://zhuanlan.zhihu.com/p/324507636">上下界网络流</a></h3><h4 id="无源汇上下界可行流">无源汇上下界可行流</h4><p>首先每条边先满足下界，那么对应两个节点的入流都要改变，那么为了让每个节点平衡，我们可以起源点和汇点。比如入流多了，那我们可以把它从源点给它连这么多流的边，求最大流的时候，自然就会有出的跟他中和。</p><p>这样只需在差网络中求一下最大流得到的必然是可行流</p><h4 id="有源汇上下界可行流">有源汇上下界可行流</h4><p>从汇点到源点建一个 下界为 0，上界无穷大的边，就变成了无源汇情形</p><h4 id="有源汇上下界最大流">有源汇上下界最大流</h4><p>求完可行流之后，再根据原始的源汇求一次最大流即可。</p><h4 id="有源汇上下界最小流">有源汇上下界最小流</h4><p>求完可行流之后，再根据原始的源汇（源汇互换）求一次最大流即可。</p><h4 id="有无源汇上下界最小费流">（有/无）源汇上下界最小费流</h4><p>附加边费用为 0，然后按照最小费用最大流跑一次就可以了。</p><h4 id="有无源汇上下界最小费用最大流">（有/无）源汇上下界最小费用最大流</h4><p>附加边费用为 0，然后按照最小费用最大流跑一次就可以了。然后再根据原始的源汇跑一次最大流即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性规划之单纯形法</title>
    <link href="/simplex/"/>
    <url>/simplex/</url>
    
    <content type="html"><![CDATA[<p>在 Codeforces 有人问了我两个优化问题，一个是非线性规划（具体说是凸优化问题）。一般来说非线性规划没有什么具体的算法，但是凸优化，可以转化成凸包，然后转换成线段（如果是二维的）上的最值问题就搞定了。另一个是线性规划（所有线性规划其实也是特殊的凸优化），线性规划有著名的单纯形算法，7 年前就学过，但一直没写过代码。趁这次机会重新学习一下单纯形算法，并给出代码。<a href="../spookywooky">英文版解答</a></p><blockquote><p>参考教材：<a href="运筹学.pdf">运筹学 第三版 清华大学出版社</a>，另外 <a href="https://oi-wiki.org/math/simplex/">OI-wiki</a> 上讲的简洁清晰但是不够全面。</p></blockquote><h2 id="gauss-消元法">Gauss 消元法</h2><blockquote><p>之前一直不写这个模板的原因：可能无解，可能唯一解，可能无穷多个解，double 有判断，很烦。</p></blockquote><p>求解 <span class="math inline">\(Ax = b\)</span>，如果无解就输出空向量，否则输出（某一个）答案向量，无穷解的话随便输出一个。</p><h3 id="浮点数版">浮点数版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">using</span> pii = std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;;<br><span class="hljs-keyword">using</span> pll = std::pair&lt;LL, LL&gt;;<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">Gauss</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-keyword">double</span>&gt;&gt; A, std::vector&lt;<span class="hljs-keyword">double</span>&gt; b)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = A.<span class="hljs-built_in">size</span>(), m = A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(m)</span></span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(m)</span></span>;<br>  std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-12</span>;<br>  <span class="hljs-keyword">auto</span> findNonZero = [&amp;](<span class="hljs-keyword">int</span> i) &#123; <span class="hljs-comment">// 实际上找最大的比较好</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = i; row &lt; n; ++row) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(A[row][i]) &gt; eps) <span class="hljs-keyword">return</span> row;<br>    <span class="hljs-keyword">return</span> n;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> triangleGauss = [&amp;](<span class="hljs-keyword">int</span> sz) &#123; <span class="hljs-comment">// A[i][i] = 1</span><br>    std::vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">x</span>(sz);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sz - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; --i) &#123;<br>      x[i] = b[i];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; i; ++row) b[row] -= A[row][i] * x[i];<br>    &#125;<br>    x.<span class="hljs-built_in">resize</span>(A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;;<br>  <span class="hljs-keyword">int</span> sz = n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, row; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">while</span> (i &lt; m) &#123;<br>      row = <span class="hljs-built_in">findNonZero</span>(i);<br>      <span class="hljs-keyword">if</span> (row != n) <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="hljs-number">1</span>];<br>      std::<span class="hljs-built_in">swap</span>(p[i], p[--m]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == m) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = m; row &lt; n; ++row) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(b[row])) &#123;<br>        <span class="hljs-comment">// std::cout &lt;&lt; &quot;\nNo answer\n&quot;;</span><br>        <span class="hljs-keyword">return</span> std::vector&lt;<span class="hljs-keyword">double</span>&gt;();<br>      &#125;<br>      sz = i;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (row != i) &#123;<br>      std::<span class="hljs-built_in">swap</span>(A[row], A[i]);<br>      std::<span class="hljs-built_in">swap</span>(b[row], b[i]);<br>    &#125;<br>    b[i] /= A[i][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= i; --j) A[i][j] /= A[i][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = i + <span class="hljs-number">1</span>; row &lt; n; ++row) &#123;<br>      b[row] -= A[row][i] * b[i];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= i; --j) &#123;<br>        A[row][j] -= A[row][i] * A[i][j];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// if (sz != A[0].size()) std::cout &lt;&lt; &quot;\nInfinite answer\n&quot;;</span><br>  <span class="hljs-keyword">auto</span> xt = <span class="hljs-built_in">triangleGauss</span>(sz);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>; t &lt; A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++t) x[p[t]] = xt[t];<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> cas = <span class="hljs-number">1</span>;<br>  std::cin &gt;&gt; cas;<br>  <span class="hljs-keyword">while</span> (cas--) &#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    std::vector&lt;std::vector&lt;<span class="hljs-keyword">double</span>&gt;&gt; <span class="hljs-built_in">a</span>(n, std::vector&lt;<span class="hljs-keyword">double</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : x) std::cin &gt;&gt; i;<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : b) std::cin &gt;&gt; x;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">Gauss</span>(a, b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> t : x) std::cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有限域版">有限域版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">using</span> pii = std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;;<br><span class="hljs-keyword">using</span> pll = std::pair&lt;LL, LL&gt;;<br><br><span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">Gauss</span><span class="hljs-params">(std::vector&lt;std::vector&lt;LL&gt;&gt; A, std::vector&lt;LL&gt; b)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = A.<span class="hljs-built_in">size</span>(), m = A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">x</span><span class="hljs-params">(m)</span></span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(m)</span></span>;<br>  std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> LL M = <span class="hljs-number">998244353</span>;<br>  std::function&lt;<span class="hljs-built_in">LL</span>(LL)&gt; inv = [&amp;](LL a) -&gt; LL &#123;<br>    <span class="hljs-keyword">return</span> a == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : (M - M / a) * <span class="hljs-built_in">inv</span>(M % a) % M;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> sub = [](LL &amp;x, LL y) &#123;<br>    (x -= y) &lt; <span class="hljs-number">0</span> &amp;&amp; (x += M);<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> triangleGauss = [&amp;](<span class="hljs-keyword">int</span> sz) &#123; <span class="hljs-comment">// A[i][i] = 1</span><br>    std::vector&lt;LL&gt; <span class="hljs-built_in">x</span>(sz);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sz - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>; --i) &#123;<br>      x[i] = (b[i] + M) % M;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; i; ++row) <span class="hljs-built_in">sub</span>(b[row], A[row][i] * x[i] % M);<br>    &#125;<br>    x.<span class="hljs-built_in">resize</span>(A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> findNonZero = [&amp;](<span class="hljs-keyword">int</span> i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = i; row &lt; n; ++row) <span class="hljs-keyword">if</span> (A[row][i]) <span class="hljs-keyword">return</span> row;<br>    <span class="hljs-keyword">return</span> n;<br>  &#125;;<br>  <span class="hljs-keyword">int</span> sz = n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, row; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">while</span> (i &lt; m) &#123;<br>      row = <span class="hljs-built_in">findNonZero</span>(i);<br>      <span class="hljs-keyword">if</span> (row != n) <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) A[j][i] = A[j][m - <span class="hljs-number">1</span>];<br>      std::<span class="hljs-built_in">swap</span>(p[i], p[--m]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == m) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = m; row &lt; n; ++row) <span class="hljs-keyword">if</span> (b[row]) &#123;<br>        <span class="hljs-comment">// std::cout &lt;&lt; &quot;\nNo answer\n&quot;;</span><br>        <span class="hljs-keyword">return</span> std::vector&lt;LL&gt;();<br>      &#125;<br>      sz = i;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (row != i) &#123;<br>      std::<span class="hljs-built_in">swap</span>(A[i], A[row]);<br>      std::<span class="hljs-built_in">swap</span>(b[i], b[row]);<br>    &#125;<br>    LL inva = <span class="hljs-built_in">inv</span>(A[i][i]);<br>    (b[i] *= inva) %= M;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= i; --j) (A[i][j] *= inva) %= M;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = i + <span class="hljs-number">1</span>; row &lt; n; ++row) &#123;<br>      <span class="hljs-built_in">sub</span>(b[row], A[row][i] * b[i] % M);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m - <span class="hljs-number">1</span>; j &gt;= i; --j) &#123;<br>        <span class="hljs-built_in">sub</span>(A[row][j], A[row][i] * A[i][j] % M);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// if (sz != A[0].size()) std::cout &lt;&lt; &quot;\nInfinite answer\n&quot;;</span><br>  <span class="hljs-keyword">auto</span> xt = <span class="hljs-built_in">triangleGauss</span>(sz);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>; t &lt; A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++t) x[p[t]] = xt[t];<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> cas = <span class="hljs-number">1</span>;<br>  std::cin &gt;&gt; cas;<br>  <span class="hljs-keyword">while</span> (cas--) &#123;<br>    <span class="hljs-keyword">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    std::vector&lt;std::vector&lt;LL&gt;&gt; <span class="hljs-built_in">a</span>(n, std::vector&lt;LL&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : x) std::cin &gt;&gt; i;<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : b) std::cin &gt;&gt; x;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">Gauss</span>(a, b);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> t : x) std::cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面做法是先化成上三角再求，其实也可以先直接化成对角的，两种都挺好，就不过不改了。</p></blockquote><h2 id="单纯形法">单纯形法</h2><p>首先无论是什么样的线性规划问题，都先化成标准形式：<span class="math inline">\(\max z = \sum c_i x_i\)</span>，其中 <span class="math inline">\(Ax = b, x_i \geq 0\)</span>（这里输入的 <span class="math inline">\(b\)</span> 必然都是非负，否则显然无可行解），并且保证 <span class="math inline">\(A\)</span> 的左边是一个单位阵。简单的说通过 “大 M 法” 使得 (<span class="math inline">\(b_1, \cdots, b_n, 0, \cdots, 0\)</span>) 是可以可行解。</p><ul><li>求极小值通过 <span class="math inline">\(c\)</span> 取负号解决</li><li><span class="math inline">\(\geq b\)</span> 通过加一个变量变成等号</li><li><span class="math inline">\(\leq b\)</span> 通过减一个变量变成等号</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">using</span> pii = std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;;<br><span class="hljs-keyword">using</span> pll = std::pair&lt;LL, LL&gt;;<br><br><span class="hljs-keyword">using</span> VD = std::vector&lt;<span class="hljs-keyword">double</span>&gt;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> inf = <span class="hljs-number">1e10</span>;<br><span class="hljs-comment">// make sure that A = (I, A&#x27;) and b &gt;= 0, compute max cx</span><br><span class="hljs-function">VD <span class="hljs-title">simplexCore</span><span class="hljs-params">(VD c, std::vector&lt;VD&gt; A, VD b)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = A.<span class="hljs-built_in">size</span>(), m = c.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(m)</span></span>;<br>  std::<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) A[i].<span class="hljs-built_in">emplace_back</span>(b[i]);<br>  c.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>  A.<span class="hljs-built_in">emplace_back</span>(c);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &lt;= m; ++j) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      A[n][j] -= A[n][i] * A[i][j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> check = [&amp;]() -&gt; <span class="hljs-keyword">bool</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &lt; m; ++j) <span class="hljs-keyword">if</span> (A[n][j] &gt; eps) &#123;<br>      <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (A[i][j] &gt; eps) &#123;<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">int</span> ch = std::<span class="hljs-built_in">max_element</span>(A[n].<span class="hljs-built_in">begin</span>() + n, A[n].<span class="hljs-built_in">begin</span>() + m) - A[n].<span class="hljs-built_in">begin</span>(), hc;<br>    <span class="hljs-keyword">if</span> (A[n][ch] &lt; eps) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">check</span>()); <span class="hljs-comment">// otherwise unbounded, no max solution</span><br>    <span class="hljs-keyword">double</span> theta = DBL_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (A[i][ch] &gt; eps &amp;&amp; A[i].<span class="hljs-built_in">back</span>() / A[i][ch] &lt; theta) &#123;<br>      theta = A[i].<span class="hljs-built_in">back</span>() / A[i][ch];<br>      hc = i;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(p[ch], p[hc]);<br>    <span class="hljs-keyword">double</span> tmp = <span class="hljs-number">1</span> / A[hc][ch];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &lt;= m; ++j) A[hc][j] *= tmp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) <span class="hljs-keyword">if</span> (i != hc) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &lt;= m; ++j) <span class="hljs-keyword">if</span> (j != ch) &#123;<br>        A[i][j] -= A[i][ch] * A[hc][j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) A[i][ch] *= -tmp;<br>    A[hc][ch] = tmp;<br>  &#125;<br>  <span class="hljs-function">VD <span class="hljs-title">x</span><span class="hljs-params">(m)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) x[p[i]] = A[i].<span class="hljs-built_in">back</span>();<br>  <span class="hljs-built_in">watch</span>(-A.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>()); <span class="hljs-comment">// max_val</span><br>  <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// point Corresponds to max_val</span><br>&#125;<br><span class="hljs-comment">// compute max cx, with Aqx = bq and Alq x &lt;= blq, end of 0 can be ommit in A and Aq</span><br><span class="hljs-function">VD <span class="hljs-title">simplex</span><span class="hljs-params">(VD c, std::vector&lt;VD&gt; Aq, VD bq, std::vector&lt;VD&gt; Alq, VD blq)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(Aq.<span class="hljs-built_in">size</span>() == bq.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-built_in">assert</span>(Alq.<span class="hljs-built_in">size</span>() == blq.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">int</span> n = Aq.<span class="hljs-built_in">size</span>() + Alq.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">int</span> m = c.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bq.<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-keyword">if</span> (bq[i] &lt; -eps) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : Aq[i]) x = -x;<br>    bq[i] = -bq[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; blq.<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-keyword">if</span> (blq[i] &lt; -eps) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : Alq[i]) x = -x;<br>    ++m;<br>  &#125;<br>  <span class="hljs-function">std::vector&lt;VD&gt; <span class="hljs-title">A</span><span class="hljs-params">(n, VD(n + m))</span></span>;<br>  <span class="hljs-function">VD <span class="hljs-title">f</span><span class="hljs-params">(n + m)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">int</span> now = n + c.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) A[i][i] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Aq.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; Aq[i].<span class="hljs-built_in">size</span>(); ++j) A[i][n + j] = Aq[i][j];<br>    b[i] = bq[i];<br>    f[i] = -inf;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Alq.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; Alq[i].<span class="hljs-built_in">size</span>(); ++j) A[i + Aq.<span class="hljs-built_in">size</span>()][n + j] = Alq[i][j];<br>    <span class="hljs-keyword">if</span> (blq[i] &lt; -eps) &#123;<br>      A[i + Aq.<span class="hljs-built_in">size</span>()][now++] = <span class="hljs-number">-1</span>;<br>      f[i + Aq.<span class="hljs-built_in">size</span>()] = -inf;<br>    &#125;<br>    b[i + Aq.<span class="hljs-built_in">size</span>()] = <span class="hljs-built_in">fabs</span>(blq[i]);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.<span class="hljs-built_in">size</span>(); ++i) f[n + i] = c[i];<br>  <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">simplexCore</span>(f, A, b);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">VD</span>(x.<span class="hljs-built_in">begin</span>() + n, x.<span class="hljs-built_in">begin</span>() + n + c.<span class="hljs-built_in">size</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> cas = <span class="hljs-number">1</span>;<br>  std::cin &gt;&gt; cas;<br>  <span class="hljs-keyword">while</span> (cas--) &#123;<br>    <span class="hljs-keyword">int</span> nlq, nq, m;<br>    std::cin &gt;&gt; nlq &gt;&gt; nq &gt;&gt; m;<br>    std::vector&lt;std::vector&lt;<span class="hljs-keyword">double</span>&gt;&gt; <span class="hljs-built_in">Alq</span>(nlq, std::vector&lt;<span class="hljs-keyword">double</span>&gt;(m, <span class="hljs-number">0</span>));<br>    std::vector&lt;std::vector&lt;<span class="hljs-keyword">double</span>&gt;&gt; <span class="hljs-built_in">Aq</span>(nq, std::vector&lt;<span class="hljs-keyword">double</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">blq</span><span class="hljs-params">(nlq)</span>, <span class="hljs-title">bq</span><span class="hljs-params">(nq)</span>, <span class="hljs-title">c</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : c) std::cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : Alq) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : x) std::cin &gt;&gt; i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : blq) std::cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : Aq) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : x) std::cin &gt;&gt; i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : bq) std::cin &gt;&gt; x;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">simplex</span>(c, Aq, bq, Alq, blq);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> t : x) std::cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输入样例：（和 matlab linprog 样例一致）</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">6 1 2</span><br><span class="hljs-comment">1 0.33333333</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 1</span><br><span class="hljs-comment">1 0.25</span><br><span class="hljs-comment">1 -1</span><br><span class="hljs-comment">-0.25 -1</span><br><span class="hljs-comment">-1 -1</span><br><span class="hljs-comment">-1 1</span><br><span class="hljs-comment">2 1 2 1 -1 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">1 0.25</span><br><span class="hljs-comment">0.5</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://doc.sagemath.org/html/en/reference/numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram">SagMath 线性规划文档</a> 以及 <a href="https://ww2.mathworks.cn/help/optim/ug/linprog.html?s_tid=srchtitle">Matlab linprog 文档</a></p></blockquote><h3 id="对偶理论">对偶理论</h3><figure><img src="dual.jpg" alt="对偶理论" /><figcaption aria-hidden="true">对偶理论</figcaption></figure><p>例题：<a href="https://codeforces.com/problemset/problem/605/C">605C</a>，利用对偶理论之后，此题两种做法，一种是利用三分法搞定，当然了要特别注意精度问题，另一种利用半平面的交（可以查看 HDU 模板）。</p><blockquote><p>以下内容以后有空再补吧</p></blockquote><h2 id="整数规划">整数规划</h2><h2 id="混合型规划">混合型规划</h2>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp 模板</title>
    <link href="/cppTemplate/"/>
    <url>/cppTemplate/</url>
    
    <content type="html"><![CDATA[<blockquote><p>编写编译器易优化、易读、易拓展、自解释的代码，并且配套文档。</p></blockquote><p>C++ 模板的 <a href="https://github.com/izlyforever/cpplibforCP">代码</a>，<a href="https://izlyforever.github.io/cpplibforCP">文档</a>，<a href="https://github.com/izlyforever/cf">比赛源码</a> 都已放在 <a href="https://github.com/izlyforever/">github</a> 上</p><p><a href="../gameTheory">博弈</a>，<a href="../poly">多项式</a>, <a href="../graph">图论</a>，<a href="../string">字符串</a>, <a href="../learnCpp">C++ 学习笔记</a> 单独成篇</p><p><code>C++11</code> 是基本，<code>C++14</code> 是福报，<code>C++17</code> 是奢望，<code>C++2x</code> 在梦里，只能用 <code>C++98</code> 那赶紧跑路</p><p>我对 C++ 的感情，犹如对祖国一样充满希望。它自然有很多被诟病的地方，但不影响它在不断完善</p><blockquote><p>代码风格一直在变化，存于心中</p></blockquote><span id="more"></span><h2 id="通用技巧">通用技巧</h2><h3 id="递归程序防止爆栈">递归程序防止爆栈</h3><ul><li>在 Windows 上，通常的方法是在 <strong>编译选项</strong> 中加入 <code>-Wl,--stack=1000000000</code></li><li>在 Linux 上，通常的方法是在运行程序前 <strong>在终端内</strong> 执行 <code>ulimit -s unlimited</code> （WSL1 下无法设置可惜）</li></ul><h3 id="c-黑魔法n2-过百万编译器优化指令集优化">C++ 黑魔法：<span class="math inline">\(n^2\)</span> 过百万，编译器优化+指令集优化</h3><p><a href="https://ouuan.github.io/post/n%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/">博文</a> 和 <a href="extension://oikmahiipjniocckomdccmplodldodja/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fwavwing.site%2F2019%2F01%2F26%2F2019.1.25%2520trainingWeek%2Finstruction_set_elephant.pdf">ppt</a></p><p>但是实际上不需要这么麻烦，仅需在头部添加下面代码（codeforces 上支持）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC optimize(<span class="hljs-meta-string">&quot;Ofast,no-stack-protector,unroll-loops&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> GCC target(<span class="hljs-meta-string">&quot;sse,sse2,sse3,ssse3,sse4.1,sse4.2,abm,mmx,avx,avx2,popcnt,tune=native&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>示例：</p><ul><li><a href="https://codeforces.com/contest/911/problem/G">911G</a> 的<a href="https://codeforces.com/contest/911/submission/113144618">提交</a></li><li><a href="https://codeforces.com/contest/1511/problem/G">1151G</a> 的 <a href="https://codeforces.com/contest/1511/submission/112897863">提交</a></li></ul><h3 id="bitset-高端压位卡常"><a href="https://www.cnblogs.com/RabbitHu/p/bitset.html">bitset 高端压位卡常</a></h3><p>典型应用，求传递闭包，高维偏序。bitset 还有两个好用的 <a href="https://codeforces.com/blog/entry/43718?locale=en">builtin 函数</a>: <code>_Find_first, _Find_next</code></p><h3 id="概率问题永不-tle-的技巧"><a href="https://codeforces.com/contest/1523/submission/117890786">概率问题永不 TLE 的技巧</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 概率问题永不 TLE 的技巧</span><br><span class="hljs-keyword">auto</span> begin = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-keyword">while</span> ((std::chrono::steady_clock::<span class="hljs-built_in">now</span>() - begin).<span class="hljs-built_in">count</span>() &lt; <span class="hljs-number">5e8</span>) &#123; <span class="hljs-comment">// 数值取时限的一半</span><br>  <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="python-输入样例以备不时之需用-pypy3-提交">Python 输入样例（以备不时之需，用 PyPy3 提交）</h3><p>用 Python 过的一次大数题：<a href="https://codeforces.com/contest/490/submission/105550245">490C</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多 case 输入</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())):<br><span class="hljs-comment"># 单行输入</span><br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-comment"># 两个元素一行输入</span><br>  a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br><span class="hljs-comment"># 提前结束</span><br>exit()<br></code></pre></td></tr></table></figure><h3 id="取平均值防溢出c20-就有-mid-函数了">取平均值（防溢出，C++20 就有 mid 函数了）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(x &amp; y) + ((x ^ y) &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// 向下取整</span><br>(x | y) - ((x ^ y) &gt;&gt; <span class="hljs-number">1</span>) <span class="hljs-comment">// 向上取整</span><br></code></pre></td></tr></table></figure><h3 id="交互式题目模板"><a href="https://codeforces.com/blog/entry/45307">交互式题目模板</a></h3><p><a href="https://codeforces.com/gym/101021/problem/1">gym101021: Guess the Number</a> 需要 <code>fflush(stdout);</code>（对于 <code>scanf/printf</code>） 或 <code>std:::cout &lt;&lt; std::flush</code> （对于 <code>std::cin/std::cout</code>） 来刷新缓冲区，不过 <code>std::endl</code> 会自动刷新一次缓冲区，所以此时可以省略。</p><blockquote><p>注意 <code>std::endl</code> 和 <code>\n</code> 的区别是前一个刷新缓冲区，后一个不刷新。仅在交互问题或者 debug 的时候使用 std::endl;</p></blockquote><h3 id="负数下标技巧">负数下标技巧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> aa[N];<br><span class="hljs-keyword">int</span> *a = (aa + N / <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><blockquote><p>可用于 <span class="math inline">\(O(1)\)</span> 首尾插入或删除元素，访问第 <span class="math inline">\(i\)</span> 个元素。 当然也可以用 <code>std::deque</code> 加一个标号，实现上述操作</p></blockquote><h3 id="优雅的输出技巧">优雅的输出技巧</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>  std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="带取整的函数取最值的技巧">带取整的函数取最值的技巧</h3><ul><li>先考虑不取整的情况，然后一般这个值是可能的最小值或者最大值</li><li>然后通过循环看是否满足取整的情况</li></ul><h3 id="输出全排列">输出全排列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">permutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(n)</span></span>;<br>  std::<span class="hljs-built_in">iota</span>(x.<span class="hljs-built_in">begin</span>(), x.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">do</span> &#123;<br>    std::for_each(x.<span class="hljs-built_in">begin</span>(), x.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">int</span> i)&#123;<br>      std::cout &lt;&lt; i;<br>    &#125;);<br>    std::cout &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">next_permutation</span>(x.<span class="hljs-built_in">begin</span>(), x.<span class="hljs-built_in">end</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出全排列的原理">输出全排列的原理</h3><p>首先初始状态从小到大排列，然后对每一个状态考虑它的后缀，如果后缀是从大到小排列，再考虑向前一位的后缀，直到不是从大到小排列，然后找比第一个位置大的最小值放在开头，其它位置排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permutation</span>(<span class="hljs-params">n</span>):</span><br>  ans = []<br>  cnt = math.factorial(n);<br>  r = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>))<br>  ans.append(r.copy())<br>  cnt -= <span class="hljs-number">1</span><br>  <span class="hljs-keyword">while</span> cnt &gt; <span class="hljs-number">0</span>:<br>    i = n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> r[i - <span class="hljs-number">1</span>] &gt; r[i]: i -= <span class="hljs-number">1</span><br>    r[i:] = r[i:][::-<span class="hljs-number">1</span>]<br>    j = i<br>    <span class="hljs-keyword">while</span> r[j] &lt; r[i - <span class="hljs-number">1</span>]: j += <span class="hljs-number">1</span><br>    r[i - <span class="hljs-number">1</span>], r[j] = r[j], r[i - <span class="hljs-number">1</span>]<br>    ans.append(r.copy())<br>    cnt -= <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>):<br>  <span class="hljs-built_in">print</span>(permutation(i))<br></code></pre></td></tr></table></figure><h2 id="通用知识">通用知识</h2><h3 id="产生-log-的几个原因">产生 log 的几个原因</h3><ol type="1"><li>二分，三分</li><li><span class="math inline">\(1 + \frac{1}{2} + \cdots \frac{1}{n} \sim \log n\)</span></li><li><span class="math inline">\(\frac{1}{2} + \cdots \frac{1}{p} \sim \log \log n\)</span></li><li>树状数组，线段树</li><li>堆排序</li><li>分治</li><li>FFT、FWT</li><li>重链剖分</li><li>倍增（太好用了，特别是 nxt 数组进行加速）</li></ol><h3 id="产生根号的几个原因">产生根号的几个原因</h3><ol type="1"><li>朴素判断素数</li><li>整除分块：<span class="math inline">\(\lfloor \frac{n}{i} \rfloor\)</span> 的值域是 <span class="math inline">\(O(\sqrt{n})\)</span> 的</li><li><span class="math inline">\(\max(x + \frac{n}{x})\)</span></li><li>网络流中 HLPP（没读过这篇复杂度分析的论文，不懂）</li><li>分块处理，分块打表</li><li>莫队（离线算法）</li></ol><h2 id="o1-额外空间复杂度算法"><span class="math inline">\(O(1)\)</span> 额外空间复杂度算法</h2><h3 id="大小步baby-step-gain-step">大小步(Baby step gain step)</h3><ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">判断链表中是否有环</a></li><li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">找出给定区间唯一重复的数</a></li></ul><h3 id="复制链表"><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复制链表</a></h3><h3 id="二叉树遍历-morris-算法"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">二叉树遍历 Morris 算法</a></h3><h3 id="const-vs-constexpr">const VS constexpr</h3><p>从 2021-4-27 开始使用 constexpr。对于变量而言，它们的本质区别，一个编译器初始化，一个运行时初始化。</p><h3 id="int-vs-long-long">int VS long long</h3><p>以前当 int 类型出现带模乘法的时候，我们一般就直接使用 LL 了，不用强制类型转化了。但是后来转而使用 int 了。</p><p>注意到 <code>LL(a) * b % n</code> 和 <code>1LL * a * b</code> 在汇编意义下没有区别。两种情况哪个方便写那个。放弃 LL 的主要理由：</p><ul><li>本身就是 int 型的变量，为什么用 LL 存储呢？</li><li>内存减少一半</li><li>在 32 位机器上更快。</li></ul><h3 id="最大最小值分配律">最大最小值分配律</h3><p><span class="math display">\[\begin{aligned}\min(\max(x, a), b) = \max(\min(x, b), \min(a, b)) \\\max(\min(x, a), b) = \min(\max(x, b), \max(a, b))\end{aligned}\]</span></p><p>例题：<a href="https://atcoder.jp/contests/abc196/tasks/abc196_e">Atcoder abc196E</a></p><h3 id="cout-cerr-clog-的区别">cout, cerr, clog 的区别</h3><p>cerr 可看作自动刷新缓冲区的 clog。 cout 和 clog 的区别就是 clog 直接打印在屏幕上，而我们文件输入输出的时候使用 <code>freopen("out", "w", stdout)</code> 后 cout 会输出到 out 文件中，而 clog 依然打印在屏幕中，这就很有用了。</p><h3 id="动态规划思想">动态规划思想</h3><p>动态规划的能力犹如程序员的内功</p><h3 id="水涨船高技巧"><a href="https://codeforces.com/blog/entry/58316">水涨船高技巧</a></h3><p>把一个集合中所有元素加一个常数，可以不操作，加在水位线上即可</p><h3 id="meet-in-middle拆半搜索法">Meet in Middle(拆半搜索法)</h3><blockquote><p>类似于动态规划，是一种思想。特别适合处理指数复杂度。</p></blockquote><p>例题：<a href="https://atcoder.jp/contests/abc184/tasks/abc184_f">AtCoder abc184F</a>，当然针对此题可以深搜剪枝法。</p><h3 id="small-to-large把小的合并到大的里面去">Small to large（把小的合并到大的里面去）</h3><p>例子：并查集（dus），map 的合并，树上启发式合并（dus on tree)，重链剖分。</p><p>例题：<a href="https://codeforces.com/contest/600/problem/E">600E</a> 的 <a href="https://codeforces.com/blog/entry/21827">题解</a></p><h3 id="倍增思想太强了">倍增思想（太强了）</h3><p>例子：RMQ，LCA。nxt 数组进行加速</p><h3 id="大小端"><a href="https://github.com/izlyforever/cf/blob/master/example/endian.cpp">大小端</a></h3><ul><li><a href="https://devdocs.io/cpp/types/endian">C++20 std::endian</a></li><li>用一个 Union（一个 uint32 的数和一个 长为 4 的 uint8 的数组</li><li>用一个 <code>char*</code> 指向一个 int 型的数，然后取指针的值</li><li><code>python -c "import sys; print(sys.byteorder)"</code></li></ul><h3 id="abi-兼容问题">ABI 兼容问题</h3><ul><li>陈硕大佬的<a href="http://www.cppblog.com/Solstice/archive/2011/03/09/141401.aspx">博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/451603936">知乎上的一种解决方案</a></li></ul><h3 id="整除c-vs-python">整除：C++ VS Python</h3><ul><li><code>C/C++</code> 中，整数除法 <code>/</code> 是向 <code>0</code> 取整(<code>int(x)</code>也是向 0 取整)</li><li><code>Python/Sagemath</code> 中，整数除法 <code>//</code> 是向下取整。</li></ul><blockquote><p>在 C++ 中一定不要用 <code>(x - 1) / n + 1</code> 的姿势向上取整！</p></blockquote><h2 id="位运算">位运算</h2><h3 id="位运算的关系">位运算的关系</h3><ul><li>异或 <code>1</code> 改变，异或 <code>0</code> 不变</li><li><span class="math inline">\(a \oplus b\)</span> 在某位为 0，表示在此位它们相等，反之不等。</li><li><span class="math inline">\(a \oplus b = (a \mid b) \oplus (a \And b)\)</span></li><li><span class="math inline">\(a \oplus b = (a \mid b) - (a \And b)\)</span></li><li><span class="math inline">\(a + b = (a \mid b) + (a \And b)\)</span></li><li><span class="math inline">\(a + b = (a \oplus b) + 2 (a \And b)\)</span></li><li><code>(a &amp; b) | c = (a | b) &amp; (a | c)</code></li><li><code>(a | b) &amp; c = (a &amp; b) | (a &amp; c)</code></li><li><code>(a | b) ^ 1 = (a ^ 1) &amp; (b ^ 1)</code></li><li><code>(a &amp; b) ^ 1 = (a ^ 1) | (b ^ 1)</code></li><li><code>(a | b) ^ c</code> 和 <code>(a &amp; b) ^ c</code> 可以逐位转化，因此任何一个数 x 经过任意多次的<code>&amp;, |, ^</code> 运算最终都可以写成 <code>((x ^ a) &amp; b) | c</code>。</li></ul><h3 id="最高位后面位取反-o1">最高位后面位取反 <span class="math inline">\(O(1)\)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverseBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> n ^ ((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">32</span> - __builtin_clz(n)) - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最低位-1-置-0-x-x-x---1">最低位 1 置 0: <code>x = x &amp; (x - 1)</code></h3><h3 id="树状数组中使用的-lowbitx-x--x-得到-x-的最大-2-的幂次因子">树状数组中使用的 <code>lowbit(x) = x &amp; (-x)</code> 得到 x 的最大 2 的幂次因子</h3><h3 id="mask-位上暴力枚举"><a href="https://cp-algorithms.com/algebra/all-submasks.html">mask 位上暴力枚举</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; i = (i - <span class="hljs-number">1</span>) &amp; n) &#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gospers-hackn-个集合中选-k-个">Gosper's Hack：n 个集合中选 k 个</h3><p>思路：想想怎么把 <code>1011100</code> 变成 <code>110011</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GospersHack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> cur = (<span class="hljs-number">1</span> &lt;&lt; k) - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> limit = (<span class="hljs-number">1</span> &lt;&lt; n);<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; r;<br>  <span class="hljs-keyword">while</span> (cur &lt; limit) &#123;<br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">int</span> lb = cur &amp; -cur;<br>    <span class="hljs-keyword">int</span> r = cur + lb;<br>    cur = (((r ^ cur) &gt;&gt; <span class="hljs-number">2</span>) / lb) | r;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>异或运算是一种很神奇用途很广的运算. 从性质上, 异或运算作为二元运算, 关于所有非负整数构成一个 Abel 群, 0 作为幺元, 每个元的逆元都是自身(等价于说 <span class="math inline">\(char(N ^ \star,xor)=2\)</span>)。</p><h3 id="异或找出唯一出现奇数次的数">异或找出唯一出现奇数次的数</h3><p>把这一堆数全体直接异或即可.</p><blockquote><p>这个方法可以推广到找出两个只出现奇数次的, 其它出现偶数次的两个数, 方法就是先异或之后的值按照最高位进行标记然后分成两组, 再来一遍</p></blockquote><h2 id="数学">数学</h2><h3 id="常用组合数公式及其直观解释">常用组合数公式及其直观解释</h3><p>对任意实数，定义：<span class="math inline">\(\binom{\alpha}{k} = \frac{\alpha(\alpha - 1) \cdots (\alpha - k + 1)}{k !}\)</span> 所以我们有：</p><p><span class="math display">\[\binom{-n}{k} = (-1)^{k} \binom{n + k - 1}{k}\]</span></p><p><span class="math display">\[\binom{n + 1}{k + 1} = \binom{n}{k} + \binom{n}{k + 1}\]</span> &gt; 最后一个数，先还是不选，这是一个问题</p><p><span class="math display">\[{n \choose k}{k \choose i}  = {n \choose i} {n - i \choose k - i}\]</span></p><blockquote><p> 组合意义理解：<span class="math inline">\(n\)</span> 个人中选出 <span class="math inline">\(i\)</span> 个一流人才， <span class="math inline">\(k - i\)</span> 个二流人才</p></blockquote><p><span class="math display">\[{n + m \choose k} = \sum_{i + j = k} {n \choose i} {m \choose j}\]</span></p><blockquote><p>组合意义理解：<span class="math inline">\(n, m\)</span> 两个堆选出 <span class="math inline">\(k\)</span> 个人</p></blockquote><h3 id="拓展-euler-定理">拓展 Euler 定理</h3><p>数论中欧拉定义说：若 <span class="math inline">\(\gcd(a, m) = 1\)</span> 则 <span class="math inline">\(a^{\phi(m)} \equiv 1 \mod m\)</span>。</p><p>类似于拓展的 Fermat 小定理：<span class="math inline">\(a^p \equiv a \mod p\)</span>，我们有拓展 Euler 定理：</p><p><span class="math display">\[a^n \equiv a^{n \mod \phi(m) + phi(m)} \mod m\]</span></p><p>证明对 <span class="math inline">\(m\)</span> 素因子分解，再利用 Euler 函数是可乘函数，显然。</p><h3 id="求原根">求原根</h3><p>首先，模 <span class="math inline">\(m\)</span> 有原根的充要条件是：<span class="math inline">\(m=2,4,p^a,2p^a\)</span>，其中 <span class="math inline">\(p\)</span> 为奇素数。</p><p>对于求模奇素数 <span class="math inline">\(p\)</span> 的原根方法：对 <span class="math inline">\(p-1\)</span> 素因子分解：<span class="math inline">\(p-1 = p_1^{a_1} \cdots p_s^{a_s}\)</span> 若恒有 <span class="math display">\[g^{\frac{p-1}{p_i}} \neq 1(\mod \; p)\]</span> 则 <span class="math inline">\(g\)</span> 是 模 <span class="math inline">\(p\)</span> 的原根。对于 <span class="math inline">\(p^a\)</span> 的原根 为 <span class="math inline">\(g\)</span> 或 <span class="math inline">\(g + p\)</span>，若 <span class="math inline">\(p^a\)</span> 的原根为 <span class="math inline">\(g_a\)</span> 而 <span class="math inline">\(2p^a\)</span> 的原根为 <span class="math inline">\(g_a\)</span> 和 <span class="math inline">\(g_a + p^a\)</span> 的中奇数者。所有原根：可以先求出一个原根，然后所有的数便是 <span class="math inline">\(g^0, g^1, \cdots, g^{\phi(m) - 1}\)</span>, 所有原根就是那些 <span class="math inline">\(\gcd(i, \phi(m)) = 1\)</span> 的 <span class="math inline">\(g^i\)</span> (证明见 P150《数论基础》潘承洞)。</p><blockquote><p>基于上述方法的<a href="https://www.luogu.com.cn/record/49945928">代码实现</a></p></blockquote><p>另外更好的做法：</p><p>我们首先求出 <span class="math inline">\(m = \phi(n)\)</span>，然后一个个的搜，搜索的时候附带把很多点都给剔除了，所以很快就能找到！<a href="https://www.luogu.com.cn/record/49948006">具体代码</a></p><h3 id="自然数方幂和精确版">自然数方幂和精确版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/multiprecision/cpp_int.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> BINT = boost::multiprecision::cpp_int;<br><br>BINT f[N];<br><span class="hljs-function">BINT <span class="hljs-title">getPowSum</span><span class="hljs-params">(LL n, <span class="hljs-keyword">int</span> k)</span> </span>&#123; <span class="hljs-comment">// k&lt;1000</span><br>  <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">BINT</span>(n);<br>  <span class="hljs-keyword">if</span> (p[<span class="hljs-number">1</span>] != <span class="hljs-number">2</span>) <span class="hljs-built_in">spf</span>();<br>  <span class="hljs-keyword">int</span> nk = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;<br>  f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">auto</span> bPow = [](BINT x, <span class="hljs-keyword">int</span> n) -&gt; BINT &#123;<br>    BINT <span class="hljs-built_in">r</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (; n; x *= x, n &gt;&gt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> (n&amp;<span class="hljs-number">1</span>) r *= x;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= nk + <span class="hljs-number">1</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (sp[i] == i) f[i] = <span class="hljs-built_in">bPow</span>(<span class="hljs-built_in">BINT</span>(i), k);<br>    <span class="hljs-keyword">else</span> f[i] = f[sp[i]] * f[i / sp[i]];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nk; ++i) f[i] += f[i - <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">if</span> (n &lt;= nk) <span class="hljs-keyword">return</span> f[n];<br>  BINT res = <span class="hljs-number">0</span>, tl = <span class="hljs-number">1</span>, tr = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nk - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) tr = tr * (n - i - <span class="hljs-number">1</span>) / (nk - i);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= nk; ++i) &#123;<br>    <span class="hljs-keyword">if</span> ((nk - i) &amp; <span class="hljs-number">1</span>) res -= f[i] * tl * tr;<br>    <span class="hljs-keyword">else</span> res += f[i] * tl * tr;<br>    tl = tl * (n - i) / (i + <span class="hljs-number">1</span>);<br>    tr = tr * (nk - i) / (n - i - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要下载<a href="https://www.boost.org/">boost 包</a> 类似的包还有 NTL，GMP</p></blockquote><h2 id="生成函数"><a href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan">生成函数</a></h2><p>Polya 说过：生成函数就像袋子，把一个个零碎的小部件放在一个袋子里，就可以优雅高效的只关注袋子了。</p><p>在 codeforces 上 <code>zscoder</code> 大佬给了一个 <a href="https://codeforces.com/blog/entry/77468">入门教程</a> 和 <a href="https://codeforces.com/blog/entry/77551">进阶教程</a> 还有 <code>MiFaFaOvO</code> 的 <a href="https://codeforces.com/blog/entry/76447">终极教程</a></p><p>生成函数分两种：Original generating function，Expentional generating function，选择哪一种是看问题中是否牵扯组合数。无论哪一种都能保存原数列的全部信息，并且由于级数可以使用微积分和常微分方程的技术，所以会变得更好处理。然后大概率可以优化算法复杂度 <span class="math inline">\(O(n^2) \to O(n \log n)\)</span></p><p>关于生成函数多项式的处理：<a href="https://cp-algorithms.com/algebra/polynomial.html">https://cp-algorithms.com/algebra/polynomial.html</a></p><p>多项式高效运算模板：<a href="https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp">https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp</a></p><p><strong>生成函数一般的处理思路</strong>：计算生成函数，分解成有分母不超过二次的分式之和，然后每一个二次的分母部分找一个递推数列来搞定。</p><p><a href="https://oi-wiki.org/math/poly/intro/">OI-wiki 多项式运算</a></p><blockquote><p><a href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan#">多项式计数杂谈</a> 很值得学习一下。</p></blockquote><h3 id="多项式取对数和指数">多项式取对数和指数</h3><p><span class="math inline">\(B(z) = e^{A(z)}\)</span>，即 <span class="math inline">\(A(z) = \ln B(z)\)</span> (不妨假设 <span class="math inline">\(A(0) = 0\)</span> 或等价地 <span class="math inline">\(B(0) = 1\)</span>)</p><p>那么 <span class="math inline">\(B&#39;(z) = A&#39;(z) \cdot B(z)\)</span>, 所以 <span class="math inline">\([z^{n - 1}] B&#39;(z) = \sum_{k = 0}^{n - 1} [z^k] A&#39;(z) \cdot B(z) [z^{n - 1 - k}] = \sum_{k = 1}^{n} [z^{k - 1}] A&#39;(z) \cdot B(z) [z^{n-k}]\)</span>，从而 <span class="math display">\[n [z^n] B(z) = \sum_{k = 1}^n k [z^k] A(z) \cdot B(z) [z^{n - k}]\]</span> 上式等价于 <span class="math display">\[n [z^n] A(z) = n [z^n] B(z) - \sum_{k = 1}^{n - 1} k [z^k] A(z) \cdot B(z) [z^{n - k}]\]</span></p><blockquote><p>参考：<a href="https://www.cnblogs.com/Soulist/p/13758388.html">Soulist</a></p></blockquote><h3 id="差分约束">差分约束</h3><p><span class="math inline">\(n\)</span> 个变量，<span class="math inline">\(m\)</span> 个约束条件，每个约束条件都形如 <span class="math inline">\(x_i - x_j \leq c_k\)</span>，此时我们从节点 j 向 i 连一条长度为 <span class="math inline">\(c_k\)</span> 的有向边，（如果有等于号，我们就连两条），设 <code>dist[0] = 0</code>，然后 0 节点向所有节点连一条长度为 0 的有向边。跑单源最短路，如果环中有负环，那么无解，否则 <span class="math inline">\(x_i = dist[i]\)</span> 为一组解。</p><p>可用图论中 Bellman-Ford 算法，或 spfa（随笔图跑的快），例题：<a href="https://www.luogu.com.cn/problem/P1993">LOJ P1993</a>，<a href="https://www.luogu.com.cn/record/46227278">spfa 做法</a>，<a href="https://www.luogu.com.cn/record/46228308">Bellman-Ford 做法</a></p><blockquote><p>变式：<span class="math inline">\(\frac{x_i}{x_j} \leq c_k\)</span>（取 log 即可）</p></blockquote><h2 id="数据结构">数据结构</h2><h3 id="逆序数">逆序数</h3><ol type="1"><li>直接求 <span class="math inline">\(O(n^2)\)</span> 没啥好写的。</li><li>把原数组每个位置进行编号，排序，然后每次把最大的数的编号丢进树状数组中，丢进去先看这个编号前面有多少个数，累加一下就可以了，<span class="math inline">\(O(n^2)\)</span>，结合下面树状数组的知识还是很简单的。</li><li>带离散化的树状数组（就是如果元素的数值特别大，树状数组内存就不够了，所以需要离散化一下）</li><li>归并的求（不会也不想搞 0.0）</li><li>逐位处理（代码如下）</li></ol><h3 id="树状数组加强版区间更新区间求和编号从-1-开始">树状数组加强版（区间更新，区间求和，编号从 1 开始）</h3><p>有了单点更新的树状数组，只需简单利用差分就可以变成区间的更新了。 设原始数组为 <code>a[1 ~ n]</code>， 定义 <code>c[i] = a[i] - a[i - 1], (a[0] = 0)</code> 显然</p><p><span class="math display">\[\sum_{i = 1}^m a_i = \sum_{i = 1}^m (m - i + 1) c_i = m \sum_{i = 1}^m c_i - \sum_{i = 1}^m (i - 1) c_i\]</span></p><p>比如对区间 <code>[l, r]</code> 做更新，那么就只需更新两点：<code>r + 1, l</code> ，套用之前的类就行了。</p><blockquote><p>注意在树状数组中搜索本来应该是 <span class="math inline">\(O(\log ^2 n)\)</span>，但是因为在 <span class="math inline">\(2^i\)</span> 的位置搜索时，一步到位。所以复杂度会降到 <span class="math inline">\(O(\log n)\)</span>：<a href="https://codeforces.com/blog/entry/61364">理论依据</a></p></blockquote><h3 id="线段树节点上界不管是不是左闭右开">线段树节点上界（不管是不是左闭右开）</h3><p>首先显然总节点 <span class="math inline">\(m\)</span> 上界为 <span class="math inline">\(4n\)</span>，并且可以证明 <span class="math inline">\(\frac{m}{n}\)</span> 的上确界为 <span class="math inline">\(4\)</span>，下确界为 <span class="math inline">\(2\)</span> 注意到如果 <span class="math inline">\(n = 2^k + 2^{j + 1}\)</span> 时，则 <span class="math inline">\(m = 2 ^{k + 1} + 2^k + \cdots 2^{k - j} + 1\)</span>，所以 <span class="math inline">\(\frac{m}{n} = \frac{4 - 2^{-j} + 2^{-k}}{1 + 2^{j + 1 - k}}\)</span>，对任意 <span class="math inline">\(\epsilon &gt; 0\)</span> 存在 <span class="math inline">\(j\)</span> 使得 <span class="math inline">\(4 - 2 ^{-j} &gt; 4 - \epsilon\)</span>， 然后让 <span class="math inline">\(k\)</span> 趋于无穷，那么显然 <span class="math inline">\(\frac{m}{n}\)</span> 上极限为 <span class="math inline">\(4\)</span>.（<span class="math inline">\(n = 40\)</span> 时， <span class="math inline">\(\frac{m}{n} &gt; 3\)</span>，<span class="math inline">\(n = 2^{20} + 2^{10} = 1049600\)</span> 时，<span class="math inline">\(\frac{m}{n} &gt; 3.99\)</span>）</p><p>根据 jiangly 的做法：这里必然会得到 <span class="math inline">\(m &lt; 4 \cdot 2^{\log_2 n}\)</span> 确实如此。这与上面的结论不矛盾，只是更加精确罢了</p><blockquote><p>和与最大值的线段树模板（如果单纯求和，可以用树状数组），现在使用左闭右开线段树，且使用吉老师 pushTag 版本</p></blockquote><h3 id="三分法简单版"><a href="https://codeforces.com/contest/439/problem/D">三分法简单版</a></h3><blockquote><p>单峰函数可以这么做，以下为求上峰的版本</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">while</span> (r &gt; l) &#123;<br>  <span class="hljs-keyword">int</span> m = (r - l) / <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">int</span> lm = l + m, rm = r - m;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(lm) &lt; <span class="hljs-built_in">f</span>(rm)) r = rm - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> l = lm + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> l;<br></code></pre></td></tr></table></figure><h3 id="标准三分法用黄金分割的原因">标准三分法用黄金分割的原因</h3><p>我们不妨设原始区间为 <code>[0, 1]</code>，我们在其中选两个点 <code>0 &lt; a &lt; b &lt; 1</code>，然后比较 <code>f(a)</code> 和 <code>f(b)</code>，然后再相应改变区间。然后重复上述过程。如果我们能充分利用计算过的值，也就是说假设更新后的区间为 <code>[0, b]</code> 那么我们自然想让 <code>a</code> 的计算值充分被利用，所以我们想再选的两个点的其中一个是 <code>a</code>，如果更新后区间为 <code>[a, 1]</code> 同理。也就是说我们有策略 <span class="math display">\[\frac{a}{b} = b, \frac{b - a}{1 - a} = a\]</span> 化简可得 <span class="math inline">\(b(1 + b) = 1\)</span>，即 <span class="math inline">\(b = \frac{\sqrt{5} - 1}{2}, a = b ^ 2 = \frac{3 - \sqrt{5}}{2} = 1 - b\)</span>。 &gt; 注意到上述 <span class="math inline">\(b\)</span> 的值正好是黄金分割 0.618...</p><h3 id="背包">背包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> r[MAX];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cash, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span> || w == <span class="hljs-number">0</span> || v == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//  0-1背包</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cash; i &gt;= v; --i)<br>      r[i] = <span class="hljs-built_in">max</span>(r[i], r[i - v] + w);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (num * v &gt;= cash - v + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//完全背包</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = v; i &lt;= cash; ++i)<br>      r[i] = <span class="hljs-built_in">max</span>(r[i], r[i - v] + w);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">int</span> q[MAX], s[MAX], head, tail;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; v; ++j) &#123; <span class="hljs-comment">//多重背包</span><br>    q[<span class="hljs-number">0</span>] = r[j];<br>    s[<span class="hljs-number">0</span>] = head = tail = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, k = j + v; k &lt;= cash; ++i, k += v) &#123;<br>      q[i] = r[k] - i * w;<br>      <span class="hljs-keyword">while</span> (s[head] &lt; i - num) ++head;<br>      <span class="hljs-keyword">while</span> (head &lt;= tail &amp;&amp; q[tail] &lt; q[i]) --tail;<br>      s[++tail] = i;<br>      q[tail] = q[i];<br>      r[k] = q[head] + i * w;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆与-stl-优先队列">堆与 STL 优先队列</h3><p>可以使用 <a href="http://www.cplusplus.com/reference/">C++STL</a> 的 priority_queue，查找可用 lower_bound 和 upper_bound。C++ STL 中优先队列是用堆来实现的。用途十分广泛，例如加速最小生成树，拓扑排序，等等。 堆的实现一般是用数组。 我们可以用 1 作为树的根， 对每一个节点 <span class="math inline">\(x\)</span>， 它的两个节点分别就是 <span class="math inline">\(2x\)</span> 和 <span class="math inline">\(2x + 1\)</span> 平时都用 <code>x &lt;&lt; 1, x &lt;&lt; 1 | 1</code> 表示。 堆只支持三个操作:</p><ol type="1"><li>插入一个节点(我们实现时是插入最尾部， 这样保证了是一个完全二叉树) <span class="math inline">\(O(\log n)\)</span></li><li>删除最大键值节点（删除根元素的值） <span class="math inline">\(O(\log n)\)</span></li><li>输出最大键值节点（查看根元素的值） <span class="math inline">\(O(1)\)</span></li></ol><h3 id="单调队列解决滑动窗口问题固定长度内的最值问题">单调队列：解决滑动窗口问题（固定长度内的最值问题）</h3><p><a href="https://zhuanlan.zhihu.com/p/346354943">知乎 Pecco</a> 讲的很好（建议直接去看它的讲解）： &gt; 如果一个选手比你小还比你强，你就可以退役了。——单调队列的原理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 求每个长度为 m 的区间最大值的编号</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">monicDequeMax</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; r;<br>  std::deque&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!Q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - Q.<span class="hljs-built_in">front</span>() &gt;= m) Q.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-comment">// 如果求最小值，大于号改成小于号即可</span><br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>() &amp;&amp; a[i] &gt; a[Q.<span class="hljs-built_in">back</span>()]) Q.<span class="hljs-built_in">pop_back</span>();<br>    Q.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-comment">// 如果需要返回值，就在下面加入 a[Q.front()]</span><br>    <span class="hljs-keyword">if</span> (i &gt;= m - <span class="hljs-number">1</span>) r.<span class="hljs-built_in">emplace_back</span>(Q.<span class="hljs-built_in">front</span>());<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.luogu.com.cn/problem/P2216">LOJ P2216</a>：这个是二维的，我们可以一维一维的处理</p><h3 id="单调队列优化-dp">单调队列优化 DP</h3><p>例题：<a href="https://www.luogu.com.cn/problem/P2034">LOJ P2034</a>：取数字使得和最大，但是不能取连续 k 个数</p><p>肯定是 dp 问题，如果把 dp[i] 定义成取第 i 个，前 i 个结果的最值，会发现很搞。 因此我们反过来考虑。考虑删除若干个数，且删除的间隔不超过 k，求删除的最小和。最终答案就是总和减去最小和。设 <code>dp[i]</code> 表示删除 i，且满足性质的前 i 个数的答案。那么显然 <span class="math inline">\(dp[i] = a[i] i \leq k\)</span>，<span class="math inline">\(dp[i] = a[i] + \min_{i - k \leq j \leq i - 1} dp[j]\)</span>。注意最终答案不是总和减去 dp 的 最小值，而是 <span class="math inline">\(dp[n - k - 2, \cdots, n - 1]\)</span> 的最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n, k;<br>  std::cin &gt;&gt; n &gt;&gt; k;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>  LL s = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) &#123;<br>    std::cin &gt;&gt; x;<br>    s += x;<br>  &#125;<br>  std::deque&lt;<span class="hljs-keyword">int</span>&gt; Q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    dp[i] = a[i];<br>    <span class="hljs-keyword">if</span> (i &gt;= k + <span class="hljs-number">1</span>) dp[i] += dp[Q.<span class="hljs-built_in">front</span>()];<br>    <span class="hljs-keyword">if</span> (!Q.<span class="hljs-built_in">empty</span>() &amp;&amp; i - Q.<span class="hljs-built_in">front</span>() &gt;= k + <span class="hljs-number">1</span>) Q.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>() &amp;&amp; dp[i] &lt;= dp[Q.<span class="hljs-built_in">back</span>()]) Q.<span class="hljs-built_in">pop_back</span>();<br>    Q.<span class="hljs-built_in">push_back</span>(i);<br>  &#125;<br>  std::cout &lt;&lt; s - *std::<span class="hljs-built_in">min_element</span>(dp.<span class="hljs-built_in">end</span>() - k - <span class="hljs-number">1</span>, dp.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调栈形式更简单应用更广">单调栈：形式更简单应用更广</h3><p><a href="https://zhuanlan.zhihu.com/p/346536592">知乎 Pecco</a> 的精彩讲解：维护一个栈，当我们碰上一个新元素，我们知道，越靠近栈顶的元素离新元素位置越近。所以不断比较新元素与栈顶，如果新元素比栈顶大，则可断定新元素就是栈顶的下一个更大元素，于是弹出栈顶并继续比较。直到新元素不比栈顶大，再将新元素压入栈。显然，这样形成的栈是单调递减的。</p><p>应用一：求下一个比自身大的元素位置（下可以改成上，大可以改成小）</p><p>洛谷模板题：<a href="https://www.luogu.com.cn/problem/P5788">LOJ P5788</a></p><p>应用二：两个元素间所有元素均（不）大/小于这二者。</p><p>洛谷进阶题：<a href="https://www.luogu.com.cn/problem/P1823">LOJ P1823</a>，问有多少对元素，它们之间没有比它们都大的元素。</p><h3 id="单调栈优化-dp">单调栈优化 DP</h3><p>应用一优化 DP 例题：<a href="https://codeforces.com/contest/1313/problem/C2">1313C2</a>，首先最优答案肯定时先递增后递减的。相当于有一个制高点，枚举制高点，自然有 <span class="math inline">\(O(n^2)\)</span> 的算法。但是可以优化到 <span class="math inline">\(O(n)\)</span></p><p>应用二优化 DP 例题：<a href="https://codeforces.com/contest/1407/problem/D">1407D</a>，每次跳跃，它们之间的元素都严格大于它们或者严格小于它们。首先设 <code>dp[i]</code> 为到达 i 最小跳跃数，那么显然 <span class="math inline">\(\displaystyle dp[i] = \min_{j \to i} dp[j] + 1\)</span>。我们可以用两个单调栈来看那些 j 能跳到 i。</p><h2 id="几何">几何</h2><h3 id="分治法求平面最短距离任何距离都适用">分治法求平面最短距离（任何距离都适用）</h3><p>首先根据横坐标排序，然后取中位数假设处理好了左右两边的值，然后合并中间的值，首先距离中心点的横坐标不能超过已知的最小值，然后把筛出来的点按照纵坐标排序，然后 <span class="math inline">\(O(n)\)</span> 更新答案。总题复杂度 <span class="math inline">\(O(n \log^2 n)\)</span>，如果使用归并排序理论复杂度为 <span class="math inline">\(O(n \log n)\)</span>，但是实际效果并不如直接排序。</p><p>例题：[https://www.luogu.com.cn/problem/P1429] 和 <a href="https://www.luogu.com.cn/problem/P6247">LOJ P6247</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Point = std::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;;<br><span class="hljs-comment">// 这里不要用 dist2，否则很多比较的地方都要平方，反而不优雅了。</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dist</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Point&amp; p, <span class="hljs-keyword">const</span> Point &amp;q)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> x = q.first - p.first, y = q.second - p.second;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>(x * x + y * y);<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">minDist</span><span class="hljs-params">(std::vector&lt;Point&gt; a)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> d = DBL_MAX;<br>  <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> d;<br>  std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; merge = [&amp;](<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r) &#123;<br>    <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (r - l == <span class="hljs-number">2</span>) &#123;<br>      d = std::<span class="hljs-built_in">min</span>(d, <span class="hljs-built_in">dist</span>(a[l], a[l + <span class="hljs-number">1</span>]));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">merge</span>(l, m);<br>    <span class="hljs-built_in">merge</span>(m + <span class="hljs-number">1</span>, r);<br>    std::vector&lt;Point&gt; p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= l &amp;&amp; a[m].first - a[i].first &lt; d; --i) &#123;<br>      p.<span class="hljs-built_in">emplace_back</span>(a[i].second, a[i].first);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &lt; r &amp;&amp; a[i].first - a[m].first &lt; d; ++i) &#123;<br>      p.<span class="hljs-built_in">emplace_back</span>(a[i].second, a[i].first);<br>    &#125;<br>    std::<span class="hljs-built_in">sort</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; p.<span class="hljs-built_in">size</span>() &amp;&amp; p[j].first - p[i].first &lt; d; ++j) &#123;<br>        d = std::<span class="hljs-built_in">min</span>(d, <span class="hljs-built_in">dist</span>(p[i], p[j]));<br>      &#125;<br>    &#125;<br>  &#125;;<br>  <span class="hljs-built_in">merge</span>(<span class="hljs-number">0</span>, n);<br>  <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分治法还能求两个点作为对交的矩阵的最大面积</p></blockquote><h3 id="三维偏序之陈丹琪分治仅支持离线查询还是直接暴力好用">三维偏序之陈丹琪分治（仅支持离线查询，还是直接暴力好用~）</h3><blockquote><p>如果带更新怎么处理呢？先预处理求出，之后更新一个计算一个更新？（那也不太行呀）</p></blockquote><p>一般地，我们考虑可以考虑 <span class="math inline">\(k\)</span> 维偏序，设有 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(k\)</span> 维向量，<span class="math inline">\(a_j \leq a_i\)</span> 当且仅当所有的下标都满足小于等于关系，想知道对任意 <span class="math inline">\(i\)</span> 有多少个 <span class="math inline">\(j \neq i\)</span> 使得 <span class="math inline">\(a_j \leq a_i\)</span>。</p><p>有复杂度 <span class="math inline">\(O(n \log^k n)\)</span> 的算法，因此在 <span class="math inline">\(k &gt; 3\)</span> 时，我们会选择直接 <span class="math inline">\(O(n^2)\)</span> 暴力解决问题（见下小节）。</p><ul><li><span class="math inline">\(k = 1\)</span> 时，我们直接排序，假设没有相同元素，那么它们排完序之后的位置就是答案，有相同的数字的话可以先合并，也可以用 <code>upper_bound</code> 查找出结果。复杂度 <span class="math inline">\(O(n \log n)\)</span></li><li><span class="math inline">\(k = 2\)</span> 时，我们先对第一个坐标偏序，再来一个树状数组，一个个的加入元素，加入之前可以查询结果。这也是求逆序数的操作(如果数据值域范围很大，可以离散化处理一下，仅需对要加入树状数组的那一维离散化，排序可以使用下标排序，就可以避免使用 tuple）。</li></ul><p>因此三维偏序是一个空缺的问题，就有大名鼎鼎的 cdq 分治。</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P3810">LOJ P3810</a>，这个题的<a href="https://www.luogu.com.cn/problem/solution/P3810">题解</a>中，有人讲的很好，echo6342：</p><blockquote><p>cdq 分治每次计算前一半对后一半的影响。具体地，假设三维分别是 <span class="math inline">\(x, y, z\)</span>，先按 <span class="math inline">\(x\)</span> 排序。分治时每次将前半边、后半边分别按 <span class="math inline">\(y\)</span> 排序。虽然现在 <span class="math inline">\(x\)</span> 的顺序被打乱了，但是前半边还是都小于后半边的，所以要是只计算前半边对后半边的偏序关系，是不会受到 <span class="math inline">\(x\)</span> 的影响的。维护后一半的指针 i，前一半的指针 j，每次将 i 后移一位时，若 <span class="math inline">\(y[j] \leq y[i]\)</span> 则不断后移 j，并不断将 z[j] 加入树状数组。然后再查询树状数组中有多少数小于等于 z[i]。 最后要清空树状数组（注意清空的时候不能直接清空，而是根据更新的命令，反向一次命令来清空，否则一直开树状数组耗时的），还有就是要去重贼麻烦，还是弃用吧。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>  <span class="hljs-keyword">int</span> x, y, z, id, w;<br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Node &amp;A) <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (x == A.x) <span class="hljs-keyword">return</span> y == A.y ? z &lt; A.z : y &lt; A.y;<br>    <span class="hljs-keyword">return</span> x &lt; A.x;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// ans[i] 表示 小于或等于 a[i] 的元素个数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cdq</span><span class="hljs-params">(std::vector&lt;Node&gt; &amp;a, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  <span class="hljs-comment">// 先按照 y 排序，免得后面代码写的太麻烦</span><br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(a.size())</span></span>;<br>  std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-comment">// 去重操作</span><br>  <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">if</span> (a[i].x != a[i - <span class="hljs-number">1</span>].x || a[i].y != a[i - <span class="hljs-number">1</span>].y || a[i].z != a[i - <span class="hljs-number">1</span>].z) &#123;<br>      <span class="hljs-keyword">int</span> t = i - last - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = last; j &lt; i; ++j) &#123;<br>        ans[a[j].id] = t;<br>        a[j].w = <span class="hljs-number">0</span>;<br>      &#125;<br>      a[i - <span class="hljs-number">1</span>].w = i - last;<br>      last = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">int</span> t = a.<span class="hljs-built_in">size</span>() - last - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = last; i &lt; a.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    ans[a[i].id] = t;<br>    a[i].w = <span class="hljs-number">0</span>;<br>  &#125;<br>  a.<span class="hljs-built_in">back</span>().w = a.<span class="hljs-built_in">size</span>() - last;<br>  <span class="hljs-function">TreeArray <span class="hljs-title">A</span><span class="hljs-params">(k)</span></span>;<br>  <span class="hljs-keyword">auto</span> cmpy = [](<span class="hljs-keyword">const</span> Node &amp;lhs, <span class="hljs-keyword">const</span> Node &amp;rhs) &#123;<br>    <span class="hljs-keyword">return</span> lhs.y &lt; rhs.y;<br>  &#125;;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; divide = [&amp;](<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r) &#123;<br>    <span class="hljs-keyword">if</span> (r - l &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">divide</span>(l, m);<br>    <span class="hljs-built_in">divide</span>(m, r);<br>    std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + l, a.<span class="hljs-built_in">begin</span>() + m, cmpy);<br>    std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + m, a.<span class="hljs-built_in">begin</span>() + r, cmpy);<br>    <span class="hljs-keyword">int</span> t = l;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &lt; r; ++i) &#123;<br>      <span class="hljs-keyword">while</span> (t &lt; m &amp;&amp; a[t].y &lt;= a[i].y) &#123;<br>        A.<span class="hljs-built_in">add</span>(a[t].z, a[t].w);<br>        ++t;<br>      &#125;<br>      ans[a[i].id] += A.<span class="hljs-built_in">sum</span>(a[i].z);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = l; i &lt; t; ++i) A.<span class="hljs-built_in">add</span>(a[i].z, -a[i].w);<br>  &#125;;<br>  <span class="hljs-built_in">divide</span>(<span class="hljs-number">0</span>, a.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="k-维偏序暴力-bitset-优化分块时间换空间-ofrack-n2w">k 维偏序（暴力 bitset 优化，分块时间换空间） <span class="math inline">\(O(\frac{k n^2}{w})\)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">4e4</span> + <span class="hljs-number">2</span>;<br><span class="hljs-comment">// a 是 k * n 矩阵表示 n 个 k 维向量，输出每个小于自身的向量个数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">partialOrder</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;a)</span> </span>&#123;<br><span class="hljs-comment">// 直接暴力不太行，所以需要时间换空间，具体说就是分块。</span><br>  <span class="hljs-keyword">int</span> k = a.<span class="hljs-built_in">size</span>(), n = a[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">using</span> Node = std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;;<br>  <span class="hljs-function">std::vector&lt;Node&gt; <span class="hljs-title">f</span><span class="hljs-params">(k, Node(n))</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) f[i][j] = &#123;a[i][j], j&#125;;<br>    std::<span class="hljs-built_in">sort</span>(f[i].<span class="hljs-built_in">begin</span>(), f[i].<span class="hljs-built_in">end</span>());<br>  &#125;<br>  <span class="hljs-keyword">int</span> sn = std::<span class="hljs-built_in">sqrt</span>(n);<br>  <span class="hljs-keyword">using</span> Data = std::vector&lt;std::bitset&lt;N&gt;&gt;;<br>  <span class="hljs-function">std::vector&lt;Data&gt; <span class="hljs-title">bs</span><span class="hljs-params">(k, Data(n / sn + <span class="hljs-number">1</span>))</span></span>;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>    std::bitset&lt;N&gt; now;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (j % sn == <span class="hljs-number">0</span>) bs[i][j / sn] = now;<br>      now.<span class="hljs-built_in">set</span>(f[i][j].second);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n % sn == <span class="hljs-number">0</span>) bs[i][n / sn] = now;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> getbst = [&amp;](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> val) -&gt; std::bitset&lt;N&gt; &#123;<br>    <span class="hljs-comment">// 如果求小于或等于的个数，这里要改成 upper_bound 并且要用 INT_MAX，还有最终答案减 1（去掉自身）</span><br>    <span class="hljs-keyword">int</span> j = std::<span class="hljs-built_in">lower_bound</span>(f[i].<span class="hljs-built_in">begin</span>(), f[i].<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">make_pair</span>(val, INT_MIN)) - f[i].<span class="hljs-built_in">begin</span>();<br>    std::bitset&lt;N&gt; r = bs[i][j / sn];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t = j / sn * sn; t &lt; j; ++t) r.<span class="hljs-built_in">set</span>(f[i][t].second);<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>    std::bitset&lt;N&gt; now; now.<span class="hljs-built_in">set</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>      now &amp;= <span class="hljs-built_in">getbst</span>(i, a[i][j]);<br>    &#125;<br>    r[j] = now.<span class="hljs-built_in">count</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板例题：<a href="https://www.luogu.com.cn/problem/U66865">LOJ U66865</a>，可参考 <a href="https://www.cnblogs.com/cjyyb/p/8196312.html">小蒟蒻 yyb 的博客</a> 中的 ppt 实现。其它例题：<a href="http://cogs.pro:8081/cogs/problem/problem.php?pid=vSJzQVejP">偏序++</a></p><blockquote><p>虽然三维偏序问题用 cdq 分治更好，但是用 bitset 暴力过题还是没啥问题的，例如 <a href="https://www.luogu.com.cn/problem/P3810">LOJ P3810</a></p></blockquote><h2 id="递归算法复杂度定理算法导论">递归算法复杂度定理（算法导论）</h2><figure><img src="complexAnalysis.png" alt="递归算法复杂度定理" /><figcaption aria-hidden="true">递归算法复杂度定理</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于快速数论变换的多项式</title>
    <link href="/poly/"/>
    <url>/poly/</url>
    
    <content type="html"><![CDATA[<p>快速 Fourier 变换（FFT），被称为 20 世纪最伟大的十大算法之一。所以很多软件都有对应的 FFT，例如 Python 的 <code>scipy.fftpack</code> 中就有关于 FFT 的包。所以个人写 FFT 就没有那么必要了。但是 NTT（快速数论变换） 的包一般都没多少，而且会写 NTT 必然就会写 FFT 了。大约在 5 年前，在 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform">miskcoo 博文：从多项式乘法到快速傅里叶变换</a> 学会并且写过 NTT 的 C++ 代码，可惜这篇文章被作者删掉了。</p><span id="more"></span><p>NTT 一个很大的限制就是你只能在 <code>NTT-friendly</code> 的域（例如 <span class="math inline">\(\mod 998244353 = 119 \cdot2^{23}\)</span>，原根为 <span class="math inline">\(3\)</span> ）</p><p>对于一般的素数 <span class="math inline">\(p\)</span>，我们可以选择 <span class="math inline">\(n\)</span> 个 <code>NTT-friendly</code> 的大基底 <span class="math inline">\(p_1,\cdots, p_n\)</span> 使得 <span class="math inline">\(p_1\cdots p_n\)</span> 大于 ans 的上界，然后再用 <a href="../chineseRemainTheorem">中国剩余定理</a> 就可以把 ans 搞出来了。</p><!-- more --><h2 id="基底的选择">基底的选择</h2><p>我们考虑 <span class="math inline">\(\mod p\)</span> 构成的域。即运算默认是 <span class="math inline">\(\mod p\)</span> 的（除了指数上的幂次数），因为原根定理，此形式必有原根 <span class="math inline">\(g\)</span>，即存在 <span class="math inline">\(\mod p\)</span> 中所有元素都可以写成 <span class="math inline">\(g^n\)</span> 的形式（所以 <span class="math inline">\(g^{p-1}=1,g^{n}\neq 1, 0&lt;n&lt;p-1\)</span>）。而我们做 NTT 是需要找一个元素 <span class="math inline">\(w\)</span>，使得 <span class="math inline">\(w^{2^k} = 1\)</span>，因此我们需要找素数 <span class="math inline">\(p\)</span>，使得 <span class="math inline">\(p-1=c \cdot 2^k\)</span>，其中 <span class="math inline">\(c\)</span> 是个小奇数。</p><h3 id="查找基底的-sagemath-代码">查找基底的 SageMath 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">ans = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">23</span>, <span class="hljs-number">28</span>):<br>  <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">if</span>(j * <span class="hljs-number">2</span> ^i + <span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>^<span class="hljs-number">30</span> <span class="hljs-keyword">and</span> is_prime(j*<span class="hljs-number">2</span>^i+<span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> primitive_root(j*<span class="hljs-number">2</span>^i+<span class="hljs-number">1</span>) == <span class="hljs-number">3</span>):<br>      ans.append(j*<span class="hljs-number">2</span>^i+<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(ans):<br>  <span class="hljs-built_in">print</span>(i, <span class="hljs-string">&quot;\t = 1 + &quot;</span>, factor(i-<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># 167772161        = 1 +  2^25 * 5</span><br><span class="hljs-comment"># 469762049        = 1 +  2^26 * 7</span><br><span class="hljs-comment"># 595591169        = 1 +  2^23 * 71</span><br><span class="hljs-comment"># 645922817        = 1 +  2^23 * 7 * 11</span><br><span class="hljs-comment"># 897581057        = 1 +  2^23 * 107</span><br><span class="hljs-comment"># 998244353        = 1 +  2^23 * 7 * 17</span><br></code></pre></td></tr></table></figure><p>我们会发现有很多可供选择的例子，其中的娇楚（<span class="math inline">\(c\)</span> 较小，<span class="math inline">\(k\)</span> 较大，<span class="math inline">\(p^2 &lt; 2^{63}\)</span>）</p><ul><li><code>x_1 = 1 + 2^27 * 15</code> 十分推荐！<span class="math inline">\(x_2\)</span> 刚好不超过 <code>INT_MAX</code>，所以在乘积取模之前还多一次加法运算，就很方便！</li><li><code>x_2 = 1 + 2^27 * 17</code> 是平方不超过 <code>LL(long long)</code> 中最大的一个，但是不推荐，因为 <span class="math inline">\(2*x_1^2\)</span> 超了 <code>LL</code>。</li><li><code>x_3 = 1 + 2^21 * 479</code> 是网上常见的一个，但并不推荐。<span class="math inline">\(c\)</span> 太大了！</li><li><code>x_4 = 1 + 2^12 * 3</code> 是最小不超过<code>INT16</code>，并且 <span class="math inline">\(c\)</span> 特别小的一个！如果不用<code>LL</code>就很推荐</li><li><code>x_5 = 1 +  2^57 * 29</code> 是不超过 <code>INT64</code> 中最推荐的一个！然后基础运算需要用 GCC 内建的 <code>__int128</code></li></ul><p>总之，<span class="math inline">\(x_1\)</span> 是最为推荐的，<span class="math inline">\(x_2,x_3\)</span> 很常见主要是因为国内第一篇比较完整的介绍 NTT 的是 <a href="http://blog.miskcoo.com/">大佬 miskcoo</a>，他当时给的常数是 <span class="math inline">\(x_2,x_3\)</span>，然后就人云亦云了 <span class="math inline">\(x_5\)</span> 很有意思，它敲好比 <span class="math inline">\(2^{62}\)</span> 小一点，然后它又大于 <span class="math inline">\(1e9+9\)</span>，而 <span class="math inline">\(1e9+7,1e9+9\)</span> 这两个孪生素数又经常的出现在 <code>ICPC/IO</code> 中！<strong>但是，貌似也没啥用，见 NTT 模板代码的注释</strong></p><p>用 SageMath 自带的 <code>primtive_root</code> 函数分别求对应的原根 <span class="math inline">\(g_1=31,g_2=g_3=g_5=3,g_4=11\)</span>。</p><p>所以，在 <code>LL</code> 的数据范围内，我们可以使用 <span class="math inline">\(x_1\)</span>，可以处理最长长度为 <span class="math inline">\(2^{27}\)</span> 的 NTT，最长为 <span class="math inline">\(2^{26} \sim 6 \times 10^7\)</span> 项的 NTT 多项式乘法。</p><blockquote><p>我们现在存在 <span class="math inline">\(w\)</span>，有 <span class="math inline">\(w^N = 1,\; w^n \neq 1, 0&lt; n &lt; N\)</span>，其中 <span class="math inline">\(N = 2^k, k&lt;27\)</span>，有时我们用 <span class="math inline">\(w_N\)</span> 表明 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(N\)</span> 的关系。</p></blockquote><h2 id="离散-fourier-变换-dft">离散 Fourier 变换 DFT</h2><p>对长度为 <span class="math inline">\(N\)</span> 的数列 <span class="math inline">\(a_0, \cdots a_{N-1}\)</span> 做离散 Fourier 变换得到数列 <span class="math inline">\(\hat{a}_0 \cdots \hat{a}_{N-1}\)</span></p><p><span class="math display">\[\hat{a}_k = \sum_{n=0} ^{N-1} w^{kn}a_n\]</span> 写成矩阵形式</p><p><span class="math display">\[\begin{pmatrix}\hat{a}_0 \\\hat{a}_1 \\\vdots \\\hat{a}_{N-1}\end{pmatrix}=\begin{pmatrix}1 &amp; 1   &amp; \cdots &amp;1 \\1 &amp; w &amp; \cdots &amp;w^{N-1} \\\vdots&amp; &amp; \ddots &amp; \\1 &amp; w^{N-1}&amp; \cdots &amp; w^{(N-1)(N-1)}\end{pmatrix}\begin{pmatrix}a_0 \\a_1 \\\vdots \\a_{N-1}\end{pmatrix}\]</span> 即上述矩阵为 <span class="math inline">\(A\)</span>，则 <span class="math inline">\(a_{ij} = w^{ij}\)</span>, 即 <span class="math inline">\(b_{ij}= w^{-ij}\)</span>，则 <span class="math inline">\(AB = NI\)</span>，即 <span class="math inline">\(A^{-1} = \frac{1}{N}(w^{-ij})_{N \times N}\)</span>。即我们得到了 Fourier 逆变换公式： <span class="math display">\[a_k = \frac{1}{N} \sum_{n=0} ^{N-1} w^{-kn} \hat{a}_n\]</span></p><h2 id="快速-fourier-数论变换-ntt">快速 Fourier 数论变换 NTT</h2><p>记 <span class="math inline">\(H = \frac{N}{2}\)</span>， <span class="math display">\[\begin{aligned}\hat{a}_{k} &amp;= \sum_{n=0} ^{N-1} w^{kn}a_n \\&amp;= (a_0+w^{2k}a_2+\cdots+ w^{2k(H-1)}a_{N-2})+w^k(a_1+w_{2k}a_3+\cdots+w^{2k(H-1)}a_{N-1}) \\&amp;= \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n} + w^k  \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n+1} \\\hat{a}_{k+H} &amp;= \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n} - w^k  \sum_{n=0}^{H-1} (w^2)^{kn}a_{2n+1} \\\end{aligned}\]</span> 即长度为 <span class="math inline">\(N\)</span> 的 Fourier 变换可以其奇数项和偶数项的长度为 <span class="math inline">\(\frac{N}{2}\)</span> 的 Fourier 变换表出。于是递归的我们可以在 <span class="math inline">\(O(n\log n)\)</span> 时间复杂度求出。</p><blockquote><p>递归太消耗计算时间了。因此我们需要给出非递归的版本</p></blockquote><h3 id="快速-ntt-图">快速 NTT 图</h3><p>下图出自 <a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform">miskcoo 从多项式乘法到快速傅里叶变换</a></p><figure><img src="bit-reverse-miskcoo.png" alt="bit-reverse-miskcoo" /><figcaption aria-hidden="true">bit-reverse-miskcoo</figcaption></figure><p>从这个图发现，最终的计算顺序，是每个数的位倒序。处理的细节 miskcoo 博客写的特别清楚了！</p><blockquote><p>当我想要修改 Miskcoo 的代码形式时，发现怎么修改都没他的好！后来有了 Jiangly 的模板（2020-03-01）打败了他</p></blockquote><p>还有 NTT 可以用于求多项式的逆！也可见 <a href="http://blog.miskcoo.com/2015/05/polynomial-inverse">Miskcoo 的博文</a></p><h2 id="ntt-和卷积的关系">NTT 和卷积的关系</h2><p>实际上我们通常的卷积 <span class="math inline">\(c_{k} = \sum_{i + j = k} a_i b_j\)</span> 会被我们拓展长度为 N（一般为 2 的幂次），且超过 a 和 b 的长度和。这样一来，我们可以把这个卷积改写成： <span class="math display">\[c_{k} = \sum_{i + j \equiv k \mod N} a_i b_j\]</span></p><blockquote><p>这样改写的好处，一来有些卷积原来就是这个形式的，二来为下面的证明做铺垫。</p></blockquote><p>设 <span class="math inline">\(a,b\)</span> 是长度为 <span class="math inline">\(N\)</span>（一般为 2 的幂次，但这个限制只是为了快速计算）的数列，则</p><p><span class="math display">\[\hat{ab} = \hat{a} \star \hat{b}\]</span></p><p><strong>Proof</strong>： <span class="math display">\[\begin{aligned}\hat{a} \star \hat{b}(k) &amp;=  \sum_{k_1 + k_2 \equiv k \mod N} ^k  \hat{a}(k_1) \hat{b}(k_2) \\&amp;=  \sum_{n=0} ^k (\sum_{i=0} ^{N-1}  w^{k_1 i} a_i ) (\sum_{j=0} ^{N-1} w^{k_2 j}b_j) \\&amp;= \hat{ab}(k)\end{aligned}\]</span></p><blockquote><p>最后一个式子成立是因为若 <span class="math inline">\(i \neq j\)</span>，则 <span class="math inline">\(\sum_{k_1 + k_2 \equiv k \mod N} w^{k_1 i} a_i w^{k_2 j}b_j=0\)</span></p></blockquote><p>所以我们有 <span class="math inline">\(a \star b= \hat{\hat{a} \hat{b}}\)</span>，而多项式乘法只是卷积的一个例子。有些时候 <strong>计算式</strong> 一开始不是卷积形式，但是可以转换成卷积形式，再利用 FFT 或者 NTT 加速。</p><h3 id="常见形式卷积">常见形式卷积</h3><p><span class="math display">\[f(x) = \sum_{i = 0}^{d} g(i) h(x - i)\]</span></p><p>这种形式的卷积，你可以认为是需要你补充 <span class="math inline">\(h(-d), \cdots, h(-1)\)</span> 这 <span class="math inline">\(d\)</span> 个数后进行卷积，就是相当于平移一下。比如说我们想求 <span class="math inline">\(f(m), \cdots f(m + n)\)</span>（其中 <span class="math inline">\(m \geq d\)</span>），那么我们考虑多项式 <span class="math inline">\(A = \sum_{i = 0}^d g(i) x^i\)</span>, <span class="math inline">\(B = \sum_{i = 0}^{n + d} h(m - d + i) x^i\)</span>，那么 <span class="math inline">\(f(m + j) = (AB)[d + j]\)</span></p><h2 id="ntt-模板">NTT 模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> BI = __int128;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bitreverse</span><span class="hljs-params">(BI *x,<span class="hljs-keyword">int</span> len)</span></span>&#123; <span class="hljs-comment">// note that bitreverse(i)=j</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i!=len;++i)&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-built_in">swap</span>(x[i],x[j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=len&gt;&gt;<span class="hljs-number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// the mod must NTT-friendly or (len+1)*mod^2 &lt; FM</span><br><span class="hljs-keyword">const</span> BI FM = <span class="hljs-built_in">BI</span>(<span class="hljs-number">29</span>)&lt;&lt;<span class="hljs-number">57</span>|<span class="hljs-number">1</span>, gg=<span class="hljs-number">3</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ntt</span><span class="hljs-params">(BI *x,<span class="hljs-keyword">int</span> len,<span class="hljs-keyword">bool</span> isInverse=<span class="hljs-literal">false</span>)</span></span>&#123;<br>  g = <span class="hljs-built_in">powmod</span>(gg,(FM<span class="hljs-number">-1</span>)/len,FM);<br>  <span class="hljs-keyword">if</span>(isInverse)&#123;<br>    g = <span class="hljs-built_in">powmod</span>(g,FM<span class="hljs-number">-2</span>,FM);<br>    BI invlen = <span class="hljs-built_in">powmod</span>(<span class="hljs-built_in">BI</span>(len),FM<span class="hljs-number">-2</span>,FM);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i!=len;++i)&#123;<br>      x[i]=x[i]*invlen%FM;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">bitreverse</span>(x,len);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> half=<span class="hljs-number">1</span>,step=<span class="hljs-number">2</span>;half!=len;half&lt;&lt;=<span class="hljs-number">1</span>,step&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>    BI wn = <span class="hljs-built_in">powmod</span>(g,len/step,FM),w=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i+=step,w=<span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j&lt;i+half;++j)&#123;<br>        BI t=(w*x[j+half])%FM;<br>        x[j+half]=(FM-t+x[j])%FM;<br>        x[j]=(x[j]+t)%FM;<br>        w = w*wn%FM;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">square</span><span class="hljs-params">(BI *a, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-number">32</span>-__builtin_clz(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">ntt</span>(a,len);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i!=len;++i)&#123;<br>    a[i]=a[i]*a[i]%FM;<br>  &#125;<br>  <span class="hljs-built_in">ntt</span>(a,len,<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(BI *a,BI *b,<span class="hljs-keyword">int</span> na,<span class="hljs-keyword">int</span> nb)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-number">32</span>-__builtin_clz(na+nb+<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">ntt</span>(a,len);<span class="hljs-built_in">ntt</span>(b,len);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i!=len;++i)&#123;<br>    a[i] = a[i]*b[i]%FM;<br>  &#125;<br>  <span class="hljs-built_in">ntt</span>(b,len,<span class="hljs-number">1</span>);<span class="hljs-built_in">ntt</span>(a,len,<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ntt-模板更新202079">NTT 模板更新（2020/7/9)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">constexpr</span> LL M = <span class="hljs-number">998244353</span>,ROOT=<span class="hljs-number">3</span>;<br><span class="hljs-function">LL <span class="hljs-title">powmod</span><span class="hljs-params">(LL x,LL n)</span></span>&#123;<br>  <span class="hljs-function">LL <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">while</span>(n)&#123;<br>    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) r=r*x%M;<br>    n&gt;&gt;=<span class="hljs-number">1</span>; x=x*x%M;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bitreverse</span><span class="hljs-params">(vector&lt;LL&gt; &amp;a)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i!=a.<span class="hljs-built_in">size</span>();++i)&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=a.<span class="hljs-built_in">size</span>()&gt;&gt;<span class="hljs-number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ntt</span><span class="hljs-params">(vector&lt;LL&gt; &amp;a,<span class="hljs-keyword">bool</span> isInverse=<span class="hljs-literal">false</span>)</span></span>&#123;<br>  LL g = <span class="hljs-built_in">powmod</span>(ROOT,(M<span class="hljs-number">-1</span>)/a.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">if</span>(isInverse)&#123;<br>    g = <span class="hljs-built_in">powmod</span>(g,M<span class="hljs-number">-2</span>);<br>    LL invLen = <span class="hljs-built_in">powmod</span>(<span class="hljs-built_in">LL</span>(a.<span class="hljs-built_in">size</span>()),M<span class="hljs-number">-2</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x:a) x=x*invLen%M;<br>  &#125;<br>  <span class="hljs-built_in">bitreverse</span>(a);<br>  <span class="hljs-function">vector&lt;LL&gt; <span class="hljs-title">w</span><span class="hljs-params">(a.size(),<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i!=w.<span class="hljs-built_in">size</span>();++i) w[i] = w[i<span class="hljs-number">-1</span>]*g%M;<br>  <span class="hljs-keyword">auto</span> addMod = [](LL x,LL y)&#123;<span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (x+=y)&gt;=M?x-=M:x;&#125;;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> step=<span class="hljs-number">2</span>,half = <span class="hljs-number">1</span>;half!=a.<span class="hljs-built_in">size</span>();step&lt;&lt;=<span class="hljs-number">1</span>,half&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,wstep=a.<span class="hljs-built_in">size</span>()/step;i!=a.<span class="hljs-built_in">size</span>();i+=step)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j!=i+half;++j)&#123;<br>        LL t = (a[j+half]*w[wstep*(j-i)])%M;<br>        a[j+half]=<span class="hljs-built_in">addMod</span>(a[j],M-t);<br>        a[j]=<span class="hljs-built_in">addMod</span>(a[j],t);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function">vector&lt;LL&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;LL&gt; a,vector&lt;LL&gt; b)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> sz=<span class="hljs-number">1</span>,tot = a.<span class="hljs-built_in">size</span>()+b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">while</span>(sz&lt;tot) sz*=<span class="hljs-number">2</span>;<br>  a.<span class="hljs-built_in">resize</span>(sz);b.<span class="hljs-built_in">resize</span>(sz);<br>  <span class="hljs-built_in">ntt</span>(a);<span class="hljs-built_in">ntt</span>(b);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i!=sz;++i) a[i] = a[i]*b[i]%M;<br>  <span class="hljs-built_in">ntt</span>(a,<span class="hljs-number">1</span>);<br>  a.<span class="hljs-built_in">resize</span>(tot);<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于多项式乘法，求逆，带余除法的理论基础见下图，取自 <a href="https://cp-algorithms.com/algebra/polynomial.html">cp-algorithm</a></p><figure><img src="mulInv.png" alt="mulInv" /><figcaption aria-hidden="true">mulInv</figcaption></figure><figure><img src="divRem.png" alt="divRem" /><figcaption aria-hidden="true">divRem</figcaption></figure><p>与之对应的还有快速 Mobius 变换</p><p>---------------------------- 分割线 ----------------------------</p><h2 id="多项式多项式全家桶-已全部-ac">多项式（<a href="https://www.luogu.com.cn/training/3015#problems">多项式全家桶</a> 已全部 AC）</h2><ul><li>仅包含乘法的四大多项式底层基类分别为：PolyBaseNTT, PolyBaseMFT3(弃用，被后面两个淘汰了), PolyBaseMFT4, PolyBaseFFT</li><li>PolyBaseNTT：基于固定的 NTT-friendly（原根一般为 3）模数快速数论变化（看具体题目，一般为 998244353）</li><li>PolyBaseMFT3：基于三个固定的 NTT-friendly 且原根为 3 的三模数（469762049, 998244353, 1004535809），利用 crt 求解任意模数多项式乘法（已被淘汰，请勿使用）</li><li>PolyBaseMFT4：基于四个固定的 NTT-friendly 且原根为 3 的四模数（595591169, 645922817, 897581057, 998244353），利用 crt 求解任意模数多项式乘法</li><li>PolyBaseFFT：基于 FFT 求解任意模数多项式乘法（需要注意精度）</li><li>通过模板继承拓展得到全面的多项式类 Poly (加减乘除余，转置乘法，求导，积分，指数，对数，求逆，开方，一点求值，多点求值，快速幂模，内积，一个首一多项式的次方模 <span class="math inline">\(x^n\)</span> 先取对数乘以次数再取指数得到，三角函数，反三角函数)，这个过程学到了很多东西</li><li>多项式静态函数：<span class="math inline">\(O(n \log^2 n)\)</span> 计算 <span class="math inline">\(\sum_{i = 1}^n \frac{a_i}{1 - b_i}\)</span></li><li>多项式静态函数：<span class="math inline">\(O(k \log k \log n)\)</span> 求 <span class="math inline">\(k\)</span> 阶常系数递推公式的第 <span class="math inline">\(n\)</span> 项</li><li>多项式静态函数：模自然数方幂和 <span class="math inline">\(O(k \log k)\)</span> 得到前 <span class="math inline">\(k\)</span> 个答案</li><li>多项式静态函数：Lagrange 插值：先分治求 <span class="math inline">\(g(x) = \prod(x - x_i)\)</span>，再求 <span class="math inline">\(g&#39;(x)\)</span> 在 <span class="math inline">\(x\)</span> 处的多点求值，再分治即可。</li><li>求阶乘 <span class="math inline">\(n! \mod p\)</span>：基于多点求值 <span class="math inline">\(O(\sqrt{n} \log^2 n)\)</span> 求 <span class="math inline">\(\sqrt{n}\)</span> 个点之后暴力</li><li>求阶乘 <span class="math inline">\(n! \mod p\)</span>：min_25 用点求点 <span class="math inline">\(O(\sqrt{n} \log n)\)</span> 求 <span class="math inline">\(\sqrt{n}\)</span> 个点之后暴力</li></ul><blockquote><p>无运算的多项式底层基类：PolyBase（standard 在取余时，特别重要不可省略）</p></blockquote><h3 id="使用准则">使用准则</h3><ul><li>多项式项数 <span class="math inline">\(N &lt; 4 \cdot 10^6\)</span></li><li><span class="math inline">\(M\)</span> 要是超了 int，那就只能用 ModLL 版本 4 模数 Poly</li><li>否则，要是 <span class="math inline">\(M\)</span> 不固定就用使用 ModInt 的 FFT 版 Poly</li><li>否则，当 <span class="math inline">\(M\)</span> 为固定的 NTT-friendly 素数时，使用 NTT 版 Poly</li><li>否则，使用 MInt 的 FFT 版 Poly</li></ul><h3 id="极简版多项式模板polys">极简版多项式模板（polyS）</h3><p>由于多项式模板一直扩展，动则 1000+ 行，实在有点搞，所以就搞了一个极简版的。</p><h3 id="次-fft-原理">4 次 FFT 原理</h3><p>我们本来要求 <span class="math inline">\(A \dot B\)</span>，然后我们把它拆成 <span class="math inline">\(A = A_1 + 2^{d} A_2, B = B_1 + 2^d B_2\)</span>，那么 <span class="math display">\[AB = A_1 B_1 + (A_1 B_2 + A_2 B_1) 2^d + A_2 B_2 2^{2d}\]</span></p><p>于是我们只需计算 <span class="math inline">\((A_1 + i A_2)(B_1 + i B_2)\)</span> 和 <span class="math inline">\((A_1 + i A_2)(B_1 - i B_2)\)</span> 即可，但是注意到 <span class="math inline">\(dft((B_1 + i B_2))[j] = \overline{dft((B_1 + i B_2))[n - j]}\)</span> 所以本来需要 5 次 FFT，现在只需要 4 次即可。</p><blockquote><p>其实本质上，我们可以只做 3.5 次 FFT，因为 2 次 dft 我们可以得到 <span class="math inline">\(A_1, A_2, B_1, B_2\)</span> 的 dft 值，然后我们最后只需 3 次实数版 idft 即可（算作 1.5 次）！所以总的来说是 3.5 次。但是实现的时候也没办法搞 0.5 次，可惜。</p></blockquote><h3 id="min_25-用点求点原理其实可以用下降幂更简洁的处理">min_25 用点求点原理（其实可以用下降幂更简洁的处理）</h3><p>学习资料：<a href="https://www.cnblogs.com/zzqsblog/p/8408691.html">zzqsblog</a>, <a href="https://www.cnblogs.com/bztMinamoto/p/10661226.html">bztMinamoto</a></p><p>我们令 <span class="math inline">\(s = \sqrt{n}\)</span> 然后 <span class="math inline">\(\displaystyle g_{s}(x) = \sum_{i = 1}^{s}(x + i)\)</span>，我们想要得到 <span class="math inline">\(g_s(0), g_s(s), \cdots g_s((s - 1)s)\)</span> 的值。然后 <span class="math inline">\(n! = \prod_{i = 0}^{s - 1} g_s(i s) \cdot \prod_{i = s^2 + 1}^n i\)</span></p><p>现在假设我们已经得到了</p><p><span class="math display">\[g_d(0), g_d(s), \cdots g_d(d s)\]</span></p><blockquote><p>一个 <span class="math inline">\(d\)</span> 次多项式由它在 <span class="math inline">\(d + 1\)</span> 个不同点的取值唯一决定（多于 d + 1 个点也可以）</p></blockquote><ol type="1"><li><p>我们如何求</p><p><span class="math display">\[g_{d + 1}(0), g_{d + 1}(s), \cdots g_{d + 1}((d + 1) s)\]</span></p><p>注意到 <span class="math inline">\(g_{d + 1}(x) = g_{d}(x) \cdot (x + d + 1)\)</span> 即可 <span class="math inline">\(O(d)\)</span> 计算出 前 <span class="math inline">\(d + 1\)</span> 个，最后一个直接暴力计算即可。</p></li><li><p>我们如何求</p></li></ol><p><span class="math display">\[g_{2d}(0), g_{2d}(s), \cdots g_{2d}(2d s)\]</span></p><p>同样我们注意到 <span class="math inline">\(g_{2d}(x) = g_{d}(x) \cdot g_d(x + d)\)</span> 如果我们设 <span class="math inline">\(h(i) = g_d(i s)\)</span>，（那么很关键的一点 <span class="math inline">\(g_d(is + d) = g((d / s + i) s = h(d / s + i)\)</span>，卧槽， <span class="math inline">\(d / s\)</span> 在模 p 意义下得到就可以了，而且肯定大于 d，否则矛盾！）那么问题就转化成如何根据一个 <span class="math inline">\(d\)</span> 次多项式的值：<span class="math inline">\(h(0), h(1), \cdots, h(d)\)</span> 求</p><p><span class="math display">\[h(d + 0), \cdots h(d + d)\]</span></p><p>以及</p><p><span class="math display">\[h(d / s + 0), \cdots h(d / s + d)\]</span></p><p>我们不妨对于任意的给定的 <span class="math inline">\(k &gt; d\)</span>，先求出</p><p><span class="math display">\[h(k + 0), h(k + 1), \cdots h(k + d)\]</span></p><p>注意到根据 Lagrange 插值多项式</p><p><span class="math display">\[\begin{aligned}h(x) &amp;= \sum_{i = 0}^{d} h(i) \prod_{j = 0, j \neq i}^{d} \frac{x - j}{i - j} \\&amp;= \sum_{i = 0}^d (-1)^{d - i} h(i) \binom{x}{i} \binom{x - i - 1}{d - i} \\&amp;=  \left(\prod_{i = x - d}^x i \right) \sum_{i = 0}^d \frac{h(i)}{i!(d - i)!(-1)^{d - i}} \cdot \frac{1}{(x - i)}\end{aligned}\]</span></p><p>注意到这里的卷积跟我们普通的卷积不一致，左边长度为 <span class="math inline">\(d + 1\)</span> 的多项式乘以右边长度为 <span class="math inline">\(2d + 1\)</span> 的多项式，然后次数为 <span class="math inline">\(d, \cdots 2d\)</span> 这 <span class="math inline">\(d + 1\)</span> 位是有效的。</p><ol type="1"><li>不能写成除以阶乘的形式，因为 x 有可能很大。</li><li>为了保证 <span class="math inline">\(d/s &lt; 2 d\)</span>，我们需要使用 Wilson 定理即 <span class="math inline">\((p - 1)! = -1\)</span></li></ol><h3 id="分治-fft">分治 FFT</h3><p>已知 <span class="math inline">\(f_i = \sum_{j=1}^i f_{i-j} g_j\)</span> 和 <span class="math inline">\(f_0\)</span> 求 <span class="math inline">\(f\)</span></p><p>这个显然可以分治来做，其实用生成函数推理可知 <span class="math inline">\(f = \frac{f_0}{1 - g}\)</span></p><h3 id="下降幂与点值">下降幂与点值</h3><p>设 n 次多项式 <span class="math inline">\(f(x) = \sum_{i = 0}^n b_i x^{\underline{i}}\)</span>，则</p><p><span class="math display">\[\frac{f(m)}{m!} = \sum_{i = 0}^m b_i \frac{1}{(m - i)!} \qquad 0 \leq m \leq n\]</span></p><p>因此 <span class="math inline">\(EGF(f) = b e^x\)</span>，反过来也一样 <span class="math inline">\(b = EGF(f) e^{-x}\)</span>（注意这里可以简单的多点求值，可以求更多的点）</p><blockquote><p>下降幂与连续点值有 <span class="math inline">\(O(n \log n)\)</span> 的转化。而普通多项式跟连续点值却没有，可以认为普通多项式要的连续其实是类似 FFT 那样的连续。但是注意到以连续点求连续点有 <span class="math inline">\(O(n \log n)\)</span> 的做法</p></blockquote><h3 id="binom">Binom</h3><p>这里的单例很秀的一点就是用了 const 引用，但是却不妨碍我修改它的值！这样的好处：</p><ul><li>对于 <code>MInt&lt;M&gt;</code> 直接初始化了，不用在 setMod</li><li>对于 <code>ModInt, ModLL</code> 这些本来就要 setMod，那就给它调用 setMod 重新刷新 Binom 的值</li></ul><blockquote><p>源代码在换 mod 的时候会有 bug，于 2021-7-24 重构 Poly，通过继承 vector 方式而非 vector 变量的方式的时候发现了这个 bug 并修复了</p></blockquote><p><strong>注意事项</strong>：如果利用了 vector 这种结构，然后再用引用可能会因扩容而导致 RE，可以通过预先申请较大的内存的做法，此后不要随便用 <code>.back()</code> 这类不确定的调用</p><h3 id="lagrange-反演"><a href="https://users.math.msu.edu/users/magyarp/Math880/Lagrange.pdf">Lagrange 反演</a></h3><p>若 <span class="math inline">\(f(x), g(x) \in F[[x]]\)</span> 且 <span class="math inline">\(f(g(x) = x\)</span>，则</p><p><span class="math display">\[[x^n] g(x) = \frac{1}{n} [x^{-1}] \frac{1}{f(x)^n}\]</span></p><p>特别地，若 <span class="math inline">\(f(x) = \frac{x}{\phi(x)}\)</span>，则</p><p><span class="math display">\[[x^n] g(x) = \frac{1}{n} [x^{n-1}] \phi(x)^n\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>math</tag>
      
      <tag>cpp</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>$x^2 \equiv a \mod n$ 何时有解</title>
    <link href="/quadraticModEquation/"/>
    <url>/quadraticModEquation/</url>
    
    <content type="html"><![CDATA[<p>显然，我们只需考虑 <span class="math inline">\(0 \leq a &lt; n\)</span> 的情形。这个问题应该很早就被人考虑好了，不过无所谓吧（反正只是个博文而已）。以下内容都是独立完成的。并可看作 <a href="../quadraticResidueAndGaussReciprocity">二次剩余和 Gauss 互反律</a> 这篇博文的延续。最后再给出方程的一个解（如果存在的话）。</p><span id="more"></span><p>记 <span class="math inline">\(A_n = \{0 &lt; x &lt; n \mid \gcd(x,n) = 1\}\)</span>，则 <span class="math inline">\(A_n\)</span> 关于 <span class="math inline">\(\mod n\)</span> 的乘法构成一个群（根据 Euler 定理 <span class="math inline">\(|A_n| = \psi(n)\)</span>）</p><p>所以若 <span class="math inline">\(\gcd(a,n)= 1\)</span>，则任意 <span class="math inline">\(x \in A_n\)</span>，存在唯一 <span class="math inline">\(y \in A_n\)</span> 使得 <span class="math inline">\(xy \equiv a \mod n\)</span></p><p>若 <span class="math inline">\(x^2 \equiv a \mod n\)</span> 无解，则 <span class="math inline">\(\prod_{x \in A_n} x = a^{\frac{\psi(n)}{2}} \mod n\)</span></p><p>若 <span class="math inline">\(x^2 \equiv a \mod n\)</span> 有解，设 <span class="math inline">\(0 &lt; a_1 &lt; a_2 &lt; \cdots &lt; a_r &lt; n\)</span> 是全部解。则 <span class="math inline">\(\prod_{x \in A_n} x = a^{\frac{\psi(n)-r}{2}} a_1 \cdots a_r \mod n\)</span>，注意到 <span class="math inline">\(r\)</span> 只与 <span class="math inline">\(n\)</span> 有关，与 <span class="math inline">\(a\)</span> 无关。</p><blockquote><p>用 <span class="math inline">\([\frac{a}{n}] = 1\)</span> 表示有解，用 <span class="math inline">\([\frac{a}{n}] = 0\)</span> 表示无解。</p></blockquote><p>为了考虑这个问题，我们分情况讨论</p><h2 id="x2-equiv-a-mod-2m-gcdapm-1-何时有解"><span class="math inline">\(x^2 \equiv a \mod 2^m, \gcd(a,p^m) = 1\)</span> 何时有解</h2><p>当 <span class="math inline">\(m=1,2\)</span> 时，有解当且仅当 <span class="math inline">\(a=1\)</span></p><p>当 <span class="math inline">\(m \geq 3\)</span> 时，<span class="math inline">\(2^m | (a_2 -a_1)(a_2+a_1)\)</span>, 若 <span class="math inline">\((a_2-a_1)\)</span> 和 <span class="math inline">\(a_2+a_1\)</span> 都是 <code>4</code> 的倍数，则 <span class="math inline">\(a_1,a_2\)</span> 也是 <code>2</code> 的倍数矛盾于 <span class="math inline">\(\gcd(a,2^m) = 1\)</span>。所以 <span class="math inline">\(2^{m-1} \mid a_2+a_1)\)</span> 或者 <span class="math inline">\(2^{m-1} \mid (a_2-a_1)\)</span>。所以 <span class="math inline">\(0 &lt; a_1 &lt; 2^{m-2}\)</span>，<span class="math inline">\(a_2 = 2^{m-1} - a_1, a_3 = 2^{m-1}+a_1, a_4 = 2^m-a_1\)</span>。</p><p>但是，若 <span class="math inline">\(x\)</span> 是奇数，则 <span class="math inline">\(x^2 \equiv 1\mod 8\)</span> ，令一方面 <span class="math inline">\(\gcd(a,2^m) = 1\)</span> 当且仅当 <span class="math inline">\(a \equiv \mod 2\)</span>，而且每一个解对应 4 个 <span class="math inline">\(x\)</span>。</p><p>即 <span class="math inline">\(1^2,2^2,\cdots,(2^m-1)^2 \mod 2^m\)</span>，只有 <span class="math inline">\(2^{m-3}\)</span> 个数，但是小于 <span class="math inline">\(2^m\)</span> 且模 8 为 1 的数也只有，<span class="math inline">\(2^{m-3}\)</span> 个。因此，</p><p>有解 <strong>当且仅当</strong> <span class="math inline">\(a \equiv 1 \mod 8\)</span></p><h2 id="x2-equiv-a-mod-pmp2-gcdapm-1-何时有解"><span class="math inline">\(x^2 \equiv a \mod p^m,\;p&gt;2, \gcd(a,p^m) = 1\)</span> 何时有解</h2><p>因为 <span class="math inline">\(p^m \mid (a_2-a_1)(a_2+a_1)\)</span>，若<span class="math inline">\((a_2-a_1)\)</span> 和 <span class="math inline">\(a_2+a_1\)</span> 都是 <span class="math inline">\(p\)</span> 的倍数，则 <span class="math inline">\(a_1, a_2\)</span> 也是 <span class="math inline">\(p\)</span> 的倍数矛盾于 <span class="math inline">\(\gcd(a,p^m) = 1\)</span>，所以 <span class="math inline">\(a_2 = p^m - a_1\)</span>。从而 <span class="math inline">\(r=2, \; a_1a_2 \equiv -a \mod p^m\)</span>，所以</p><ul><li><p>若 <span class="math inline">\(x^2 \equiv a \mod p^m\)</span> 无解，则 <span class="math inline">\(\prod_{x \in A_n} x = a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m\)</span></p></li><li><p>若 <span class="math inline">\(x^2 \equiv a \mod p^m\)</span> 有解，则 <span class="math inline">\(\prod_{x \in A_n} x = -a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m\)</span></p></li></ul><p>取 <span class="math inline">\(a=1\)</span>，则 <span class="math inline">\(\prod_{x \in A_n} x = -1 \mod p^m\)</span>，即 <span class="math display">\[[\frac{a}{p^m}] =  (1 \equiv a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m)?\]</span></p><h2 id="x2-equiv-a-pi-mod-pm-im-gcdapm-1-何时有解"><span class="math inline">\(x^2 \equiv a p^i \mod p^m, \; i&lt;m, \; \gcd(a,p^m) = 1\)</span> 何时有解</h2><p>若 <span class="math inline">\(i=2k-1\)</span> 为奇数，则 <span class="math inline">\(p^k \mid x\)</span>，从而 <span class="math inline">\(p^{i+1} \mid ap^i\)</span>，矛盾于 <span class="math inline">\(\gcd(a,p^m) = 1\)</span></p><p>所以 <span class="math inline">\(i\)</span> 为偶数，显然此时上式有解当且仅当 <span class="math inline">\(x^2 \equiv a \mod p^{m-i},\gcd(a,p^{m-i}) = 1\)</span> 有解</p><p>综上 <span class="math display">\[[ \frac{a}{p^m} ] = \left\{ \begin{array}{cc}1 &amp; a=0 \\1 &amp; p=2,\; a \equiv 1 \mod 8 \\-1 &amp; p=2,\; a \not \equiv 1 \mod 8 \\(1 \equiv a^{\frac{p^{m-1}(p-1)}{2}} \mod p^m)? &amp; p&gt;2,\; \gcd(a,p^m) = 1\\-1 &amp; \gcd(a,p^m) = p^i, i \equiv 1 \mod 2 \\[\frac{ap^{-i}}{p^{m-i}}] &amp; \gcd(a,p^m) = p^i, i \equiv 0 \mod 2 \\\end{array} \right.\]</span></p><h2 id="x2-equiv-a-mod-m_1m_2-gcdm_1m_21-何时有解"><span class="math inline">\(x^2 \equiv a \mod m_1m_2, \gcd(m_1,m_2)=1\)</span> 何时有解</h2><p>考虑 <span class="math display">\[\begin{aligned}x \equiv a_1^2 \mod m_1 \\x \equiv a_2^2 \mod m_2\end{aligned}\]</span></p><p>则，存在 <span class="math inline">\(t_1,t_2\)</span> 使得，<span class="math inline">\(t_1m_1 + t_2m_2 = 1\)</span>，所以 <span class="math inline">\(t_1^2 m_1^2 + t_2^2 m_2^2 + 2 t_1 m_1 t_2 m_2=1\)</span>, 所以 <span class="math inline">\(x \equiv (t_2m_2 a_1)^2\)</span> 且 <span class="math inline">\(x \equiv (t_1 m_1 a_2)^2\)</span>，所以 <span class="math display">\[x \equiv (t_2 m_2 a_1)^2 + (t_1 m_1 a_2)^2 \equiv (t_2 m_2 a_1 + t_1 m_1 a_2)^2 \mod m_1 m_2\]</span> 令一方面若 <span class="math inline">\(x \equiv a^2 \mod m_1 m_2\)</span>，则 <span class="math inline">\(x \equiv (a \mod m_i)^2 \mod m_i\)</span></p><p>即 <span class="math inline">\(x^2 = a \mod m_1 m_2\)</span> <strong>有解当且仅当</strong> <span class="math inline">\([\frac{a}{m_1}] = [\frac{a}{m_2}] = 1\)</span></p><blockquote><p>最终方案：<span class="math inline">\(n = p_1^{m_1} \cdots p_r^{m_r}, \; p_1&lt; \cdots &lt;p_r\)</span>, <span class="math inline">\([\frac{a}{m}] = \prod [\frac{a}{p_i^{m_i}}]\)</span></p></blockquote><h2 id="判断是否有解的-sagemath-代码">判断是否有解的 sagemath 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># modSqrtSymbol.ipynb</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modSqrtSymbol</span>(<span class="hljs-params">an,n</span>):</span><br>  <span class="hljs-keyword">for</span> p,m <span class="hljs-keyword">in</span> factor(n):<br>    a = an%p^m<br>    <span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span>:  <span class="hljs-keyword">continue</span><br>    flag = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">while</span> a%p == <span class="hljs-number">0</span>:<br>      a//=p<br>      m-=<span class="hljs-number">1</span><br>      flag = <span class="hljs-keyword">not</span> flag<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag:  <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> p == <span class="hljs-number">2</span>:<br>      <span class="hljs-keyword">if</span> a%<span class="hljs-number">8</span> != <span class="hljs-number">1</span>:  <span class="hljs-keyword">return</span>  <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">if</span> power_mod(a,p^(m-<span class="hljs-number">1</span>)*(p-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>,p^m) != <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><blockquote><p>因为 <code>factor</code> 复杂度是 <span class="math inline">\(O(\sqrt{n})\)</span>， 所以整体复杂度 <span class="math inline">\(O(\sqrt{n})\)</span></p></blockquote><h2 id="求出-x2-equiv-a-mod-n-的一个解">求出 <span class="math inline">\(x^2 \equiv a \mod n\)</span> 的一个解</h2><blockquote><p>本来是想求全部解的，但是考虑到如果 <span class="math inline">\(\gcd(a,n) \neq 1\)</span> 则解的个数实在太多，就不想求全部解了，当然如果真的有这个需要，求全部解也不难。</p><p>另外，无论是是否有解还是求全部解都可以直接暴力做，只是复杂度为 <span class="math inline">\(O(n)\)</span> ，效率太低。</p></blockquote><h3 id="求-x2-equiv-a-mod-2m-的全部解不妨设-a-equiv-1-mod-8">求 <span class="math inline">\(x^2 \equiv a \mod 2^m\)</span> 的全部解，不妨设 <span class="math inline">\(a \equiv 1 \mod 8\)</span></h3><p>若 <span class="math inline">\(m=1\)</span>，则 <span class="math inline">\(x=1\)</span>，若 <span class="math inline">\(m=2\)</span>，则 <span class="math inline">\(x = 1, 3\)</span>，若 <span class="math inline">\(m=3\)</span>，则 <span class="math inline">\(x=1,3,5,7\)</span>，若 <span class="math inline">\(m \geq 4\)</span>，不妨设 <span class="math inline">\(x_{m-1}\)</span> 是满足方程 <span class="math inline">\(x^2 \equiv a \mod 2^{m-1}\)</span>的最小正整数解，即 <span class="math inline">\(x_{m-1}^2 = a + 2^{m-1}k\)</span></p><ul><li><p>若 <span class="math inline">\(k\)</span> 是偶数，则必然是 <span class="math inline">\(x_{m-1}^2 \equiv a \mod 2^m\)</span> 的解，最小的解就是 <span class="math inline">\(\min(x_{m-1},2^{m-2}-x_{m-1})\)</span>，但由于 <span class="math inline">\(x_{m-1} \leq 2^{m-3}\)</span>，所以 <span class="math inline">\(x_m=x_{m-1}\)</span></p></li><li><p>若 <span class="math inline">\(k\)</span> 为奇数，则 <span class="math inline">\((2^{m-2} - x_{m-1})^2 = 2^{2m-4} - 2^{m-1} + x_{m-1}^2 \equiv a \mod 2^m\)</span>，且 <span class="math inline">\(0&lt;2^{m-2}-x_{m-1}&lt;2^{m-2}\)</span>，所以 <span class="math inline">\(x_m =2^{m-2} - x_{m-1}\)</span></p></li></ul><p>所以经过 <span class="math inline">\(m\)</span> 步就可找到所有解就是 <span class="math inline">\(x_m, 2^{m-1} - x_m,2^{m-1} + x_m, 2^m - x_m\)</span></p><h3 id="求-x2-equiv-a-mod-pm-p2-的全部解其中-gcdapm-1">求 <span class="math inline">\(x^2 \equiv a \mod p^m, \; p&gt;2\)</span> 的全部解，其中 <span class="math inline">\(\gcd(a,p^m) = 1\)</span></h3><p>令 <span class="math inline">\(q = \frac{\psi(p^m)}{2} = p^{m-1}\frac{p-1}{2}\)</span>，若 <span class="math inline">\(q\)</span> 是奇数，则 <span class="math inline">\((a^{\frac{q+1}{2}})^2 = a^q a \equiv a\mod p^m\)</span>，从而解就是 <span class="math inline">\(a^{\frac{q+1}{2}},p^m-a^{\frac{q+1}{2}}\)</span></p><p>否则，记 <span class="math inline">\(q = 2^{i}q&#39;\)</span>（想模仿上面 <span class="math inline">\(q\)</span> 是奇数的情况），我们找一个非二次剩余 <span class="math inline">\(b\)</span>，即 <span class="math inline">\(b^q \equiv -1 \mod p^m\)</span>。我们记 <span class="math inline">\(x = a^{\frac{q&#39;+1}{2}},\;y = b^{q&#39;}, \; t= a^{q&#39;}\)</span>。则</p><p><span class="math inline">\(x^2 = ta, t^{2^i} = 1, y^{2^i}=-1\)</span>。我们想保持 <span class="math inline">\(x^2 = ta\)</span>，让 <span class="math inline">\(t\)</span> 变成 1。就打到了我们的目的。</p><p>若 <span class="math inline">\(t^{2^{s}} = -1, t^{2^{s+1}} = 1\)</span>, 则 <span class="math inline">\(s&lt;i\)</span>，那么 <span class="math inline">\((y^{2^{i-s}}t)^{2^{s}} = y^{2^i}t^{2^{s}} = 1\)</span>，并且 <span class="math inline">\((y^{2^{i-s-1}}x)^2 = (y^{2^{i-s}}t)a\)</span>，我们更新 <span class="math inline">\(t = y^{2^{i-s}}t\)</span>，更新 <span class="math inline">\(x=y^{2^{i-s-1}}x\)</span>。重复上述过程直到 <span class="math inline">\(t=1\)</span>。</p><p>我们也可以类似 <span class="math inline">\(p=2\)</span> 的情况，经过 <span class="math inline">\(m\)</span> 步得到全部解，只是 <span class="math inline">\(m=1\)</span> 的时候是困难的，并且和上述分析一致，所以就没用 <span class="math inline">\(p=2\)</span> 时的方法。若 <span class="math inline">\(x_{m-1}\)</span> 满足 <span class="math inline">\(x_{m-1}^2 = a + p^{m-1}k\)</span></p><ul><li><p>若 <span class="math inline">\(k\)</span> 是偶数，<span class="math inline">\((x_{m-1} - \frac{k}{2}p^{m-1})^2 \equiv a \mod p^m\)</span></p></li><li><p>若 <span class="math inline">\(k\)</span> 是奇数，<span class="math inline">\((x_{m-1} + \frac{p-k}{2}p^{m-1})^2 \equiv a \mod p^m\)</span></p></li></ul><p>对一般的 <span class="math inline">\(n = p_1^{m_1} \cdots p_r ^{m_r}\)</span>，我们对每个 <span class="math inline">\((a, p_i ^m)\)</span> 给出一个解，再用 <a href="../chineseRemainTheorem">中国剩余定理</a> 拼出最终解。</p><h3 id="x2-equiv-a-mod-n-的一个解的-sagemath-代码"><span class="math inline">\(x^2 \equiv a \mod n\)</span> 的一个解的 Sagemath 代码</h3><blockquote><p>需要用到上面的 <code>modSqrtSymbol</code> 函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># modSqrt.ipynb</span><br><br><span class="hljs-comment"># find one x s.t. x^2 = a mod 2^m, gcd(a,2) = 1 and 0 &lt; a &lt; 2^m and must have an answer</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modSqrt2Core</span>(<span class="hljs-params">a,m</span>):</span><br>  x = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>,m+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> (x*x-a)%(<span class="hljs-number">1</span>&lt;&lt;i) != <span class="hljs-number">0</span>:<br>      x = (<span class="hljs-number">1</span>&lt;&lt;i-<span class="hljs-number">2</span>)-x<br>  <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># find one x s.t. x^2 = a mod p^m, gcd(a,p)=1, p&gt;2 and  0 &lt; a &lt; p^m and must have an answer</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modSqrtPCore</span>(<span class="hljs-params">a,p,m</span>):</span><br>  n = p^m<br>  q = p^(m-<span class="hljs-number">1</span>)*(p-<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> q%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">return</span> power_mod(a,(q+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>,n)<br>  b=randint(<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">while</span>(power_mod(b,q,n)==<span class="hljs-number">1</span>):<br>    b=randint(<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>)<br>  ni = q&amp;(-q)<br>  q //= ni<br>  x = power_mod(a,(q+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>,n)<br>  y = power_mod(b,q,n)<br>  t = power_mod(a,q,n)<br>  <span class="hljs-comment"># x^2 = ta mod n, y^ni = -1 mod n</span><br>  <span class="hljs-keyword">while</span> t != <span class="hljs-number">1</span>:<br>    ns = <span class="hljs-number">1</span>;tt=t*t;<br>    <span class="hljs-keyword">while</span> tt!=<span class="hljs-number">1</span>:<br>        tt=(tt*tt)%n<br>        ns&lt;&lt;=<span class="hljs-number">1</span><br>    <span class="hljs-comment"># t^ns = -1 mod n</span><br>    t = power_mod(y,ni//ns,n)*t%n<br>    x = power_mod(y,ni//(ns*<span class="hljs-number">2</span>),n)*x%n<br>  <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># find one x s.t. x^2 = a mod p^m and must have an answer</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modPowerSqrt</span>(<span class="hljs-params">a,p,m</span>):</span><br>  n = p^m<br>  a %= n<br>  <span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  time = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> a%p==<span class="hljs-number">0</span>:<br>    a//=p<br>    m-=<span class="hljs-number">1</span><br>    time+=<span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>**(time//<span class="hljs-number">2</span>)*(modSqrt2Core(a,m) <span class="hljs-keyword">if</span> p==<span class="hljs-number">2</span> <span class="hljs-keyword">else</span> modSqrtPCore(a,p,m))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modSqrt</span>(<span class="hljs-params">a,n</span>):</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> modSqrtSymbol(a,n):<br>    <span class="hljs-keyword">return</span> []<br>  fact = <span class="hljs-built_in">list</span>(factor(n))<br>  x = [modPowerSqrt(a,p,m) <span class="hljs-keyword">for</span> p,m <span class="hljs-keyword">in</span> fact]<br>  m = [p^m <span class="hljs-keyword">for</span> p,m <span class="hljs-keyword">in</span> fact]<br>  <span class="hljs-keyword">return</span> crt(x,m)<br><br><span class="hljs-comment"># 测试几个样例</span><br>a,m = <span class="hljs-number">17</span>,<span class="hljs-number">2</span>**<span class="hljs-number">8</span><br>x =  modSqrt(a,m)<br><span class="hljs-built_in">print</span>(x,x*x%m,a,m)<br><br>a,m = <span class="hljs-number">15</span>,<span class="hljs-number">7</span>**<span class="hljs-number">8</span><br>x =  modSqrt(a,m)<br><span class="hljs-built_in">print</span>(x,x*x%m,a,m)<br><br>a,m = <span class="hljs-number">16</span>,<span class="hljs-number">3</span>*<span class="hljs-number">5</span>*<span class="hljs-number">5</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span><br>x =  modSqrt(a,m)<br><span class="hljs-built_in">print</span>(x,x*x%m,a,m)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>sagemath</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/dp/"/>
    <url>/dp/</url>
    
    <content type="html"><![CDATA[<p>动态规划是研究一大类问题（特别是最值问题）的一种思路。从大二刚开始 ICPC 竞赛的时候第一次遇到，到大三学运筹学系统的了解，再到后来一直成为解决问题的一种思考方式。可以说动态规划真的是万金油的方法。</p><p>计算机领域（或者说博弈论）中的动态规划，就如同数学中的数学归纳法，一样重要。</p><blockquote><p>运用动态规划的能力，就好比武侠小说中的内功，是随着时间慢慢累积的。 进阶可看 <a href="https://codeforces.com/blog/entry/47764">zscoder 的博文</a></p></blockquote><span id="more"></span><h2 id="动态规划应用举例">动态规划应用举例</h2><ul><li>数列的递推关系</li><li>背包问题</li><li>图论中 Floyd 算法，Dijkstra 算法</li><li>流水线问题，旅行商问题</li><li>其它杂类问题</li></ul><h2 id="动态规划原理">动态规划原理</h2><p>动态规划（dynamic programming）于 1950s 被 Richard Bellman 发现。<a href="https://www.zhihu.com/question/23995189/answer/35324479">引用这里的话</a>，动态规划本质就是：</p><ul><li>定义问题的状态（必须满足"无后效性"：这个就很玄学了）</li><li>写出状态间的转移方程</li></ul><p>从而递推（分治）的解决问题。</p><blockquote><p>难点就在于定义问题的状态</p><p>很多时候一个变量的问题，我们需要强行加一个（甚至两个）变量来定义状态</p><p>然后给出状态转移方程，再做时间空间的优化。</p></blockquote><h2 id="常规动态规划的状态定义">常规动态规划的状态定义</h2><ul><li>以该位置结尾的最优策略</li><li>多设一个变量的最优策略</li></ul><h2 id="动态规划举例长期更新">动态规划举例（长期更新）</h2><h3 id="codeforces1354f"><a href="https://codeforces.ml/problemset/problem/1354/F">codeforces1354F</a></h3><p>有 <span class="math inline">\(n\)</span> 张牌，<span class="math inline">\(i\)</span> 号牌的数值是 <span class="math inline">\(a_i\)</span>，当 <span class="math inline">\(i\)</span> 号牌放入桌上，之前在桌上的牌，每张数值增加 <span class="math inline">\(b_i\)</span>，桌上的牌可以销毁（每张牌最多销毁一次），但是桌上牌的数量不能超过 <span class="math inline">\(k\)</span>。 问使桌上牌数值总和最大的放法。其中数据满足 <span class="math display">\[1 \leq k \leq n,\; 1 \leq a_i \leq N,\; 0 \leq b_i \leq N = 10^5, \; a_i,b_i,n,k \in \mathbb{N}\]</span></p><blockquote><p>由于牌的编号于问题无关，所以不妨设 <span class="math inline">\(b_i\)</span> 单调递增。</p></blockquote><p>状态定义：<code>dp[i][j]</code> 表示：场上前 <span class="math inline">\(j\)</span> 张牌数（编号都不超过 <span class="math inline">\(i\)</span> ）的桌面牌总和最大值（其实还要减去后 <span class="math inline">\(k-j\)</span> 张牌的原始面值）。如果不减去就有后效性了！！！</p><p>状态转移：我们考虑第 <span class="math inline">\(i\)</span> 张牌，</p><ul><li>如果将它最终留在桌面上，那么它一定是最后一张放在桌面上的，因为 <span class="math inline">\(b_i\)</span> 单调递增。此时 <span class="math inline">\(dp[i][j] = dp[i-1][j-1]+(j-1)b[i] + a[i]\)</span></li><li>如果它没留在桌面，那么它一定会在后来第 <span class="math inline">\(k\)</span> 张牌加过 buff，<span class="math inline">\(dp[i][j] = dp[i-1][j] + (k-1)b[i]\)</span></li></ul><p>所以 <span class="math display">\[dp[i][j] = \max(dp[i-1][j-1]+(j-1)b[i]+a[i],\; dp[i-1][j]+(k-1)b[i])\]</span> 我们可以用 <code>isin[i][j]</code> 来标记桌上第 <span class="math inline">\(j\)</span> 张牌是否是 <span class="math inline">\(i\)</span> 号牌。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">102</span>;<br><span class="hljs-keyword">int</span> dp[N][N];<br><span class="hljs-keyword">bool</span> isin[N][N],chose[N];<br><span class="hljs-keyword">using</span> node = tuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;;<br>node q[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>    dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+(k<span class="hljs-number">-1</span>)*get&lt;<span class="hljs-number">2</span>&gt;(q[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;i &amp;&amp; j&lt;=k;++j)&#123;<br>      <span class="hljs-keyword">int</span> x = dp[i<span class="hljs-number">-1</span>][j]+(k<span class="hljs-number">-1</span>)*get&lt;<span class="hljs-number">2</span>&gt;(q[i]);<br>      <span class="hljs-keyword">int</span> y = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+(j<span class="hljs-number">-1</span>)*get&lt;<span class="hljs-number">2</span>&gt;(q[i])+get&lt;<span class="hljs-number">1</span>&gt;(q[i]);<br>      <span class="hljs-keyword">if</span>(x&gt;y)&#123;<br>        dp[i][j] = x;<br>        isin[i][j] = <span class="hljs-literal">false</span>;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        dp[i][j] = y;<br>        isin[i][j] = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&lt;=k)&#123;<br>      dp[i][i] = dp[i<span class="hljs-number">-1</span>][i<span class="hljs-number">-1</span>]+(i<span class="hljs-number">-1</span>)*get&lt;<span class="hljs-number">2</span>&gt;(q[i])+get&lt;<span class="hljs-number">1</span>&gt;(q[i]);<br>      isin[i][i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n,j=k;i;--i)&#123;<br>    <span class="hljs-keyword">if</span>(isin[i][j])&#123;<br>      chose[i]=<span class="hljs-literal">true</span>;<br>      --j;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      chose[i]=<span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> cas,n,k,a,b;<br>  cin&gt;&gt;cas;<br>  <span class="hljs-keyword">while</span>(cas--)&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>      cin&gt;&gt;a&gt;&gt;b;<br>      q[i] = &#123;i,a,b&#125;;<br><br>    &#125;<br>    <span class="hljs-built_in">sort</span>(q+<span class="hljs-number">1</span>,q+n+<span class="hljs-number">1</span>,[](<span class="hljs-keyword">const</span> node &amp; x, <span class="hljs-keyword">const</span> node &amp; y)&#123;<br>      <span class="hljs-keyword">return</span> get&lt;<span class="hljs-number">2</span>&gt;(x)&lt;get&lt;<span class="hljs-number">2</span>&gt;(y);<br>    &#125;);<br>    cout&lt;&lt;(<span class="hljs-number">2</span>*n-k)&lt;&lt;endl;<br>    <span class="hljs-built_in">getans</span>(n,k);<br>    <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>      <span class="hljs-keyword">if</span>(chose[i])&#123;<br>        <span class="hljs-keyword">if</span>(++last == k)&#123;<br>          last = i;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout&lt;&lt;get&lt;<span class="hljs-number">0</span>&gt;(q[i])&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>      <span class="hljs-keyword">if</span>(!chose[i])  cout&lt;&lt;get&lt;<span class="hljs-number">0</span>&gt;(q[i])&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;-get&lt;<span class="hljs-number">0</span>&gt;(q[i])&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;get&lt;<span class="hljs-number">0</span>&gt;(q[last])&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hdu-5691"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5691">hdu 5691</a></h3><p>这题大意：给你一些数，数值固定，部分数的位置随意调节，问你如何调解使得下式取值最大</p><p><span class="math display">\[a_0 a_1 + a_1 a_2 + \cdots + a_{n-1} a_n\]</span> 这确实是经典的状态转移问题：</p><p>设 <span class="math inline">\(i\)</span> 的 2 进制表示是 <span class="math inline">\(0 \cdots 0 i_1 0 \cdots 0 i_x 0\cdots 0\)</span> 有 <span class="math inline">\(x\)</span> 位。 <code>dp[i][j]</code> 表示前 <span class="math inline">\(x\)</span> 个空 分别填了 <span class="math inline">\(a[i_1],a[i_2],\cdots,a[i_x]\)</span> 的一个排列 且 <span class="math inline">\(i_x = j\)</span> 使目标最大的最大值。 那么，自然地有 <code>dp[i|(1&lt;&lt;k)][k] = max(dp[i][j]+a[j]*a[k])</code></p><p>详细转移见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">upmax</span><span class="hljs-params">(T &amp;a,T b)</span></span>&#123; <span class="hljs-keyword">if</span> (a&lt;b) a=b;&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF =  <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">16</span>;<br><span class="hljs-keyword">int</span> a[N],p[N];<br><span class="hljs-keyword">int</span> dp[<span class="hljs-number">1</span>&lt;&lt;N][N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> T, Case = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case #%d:\n&quot;</span>,++Case);<br>        <span class="hljs-keyword">int</span> n, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)    p[i] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,a+i, &amp;x);<br>            <span class="hljs-keyword">if</span>(x != <span class="hljs-number">-1</span>) p[x] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                dp[i][j] = -INF;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>]!=<span class="hljs-number">-1</span>)    dp[<span class="hljs-number">1</span>&lt;&lt;p[<span class="hljs-number">0</span>]][p[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)   dp[<span class="hljs-number">1</span>&lt;&lt;i][i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;<br>                <span class="hljs-keyword">if</span>(!(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j)))   <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;++k)&#123;<br>                    <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;k))    <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">int</span> x = __builtin_popcount(i);<br>                    <span class="hljs-keyword">if</span>(p[x] == <span class="hljs-number">-1</span> || p[x] == k)&#123;<br>                        <span class="hljs-built_in">upmax</span>(dp[i|(<span class="hljs-number">1</span>&lt;&lt;k)][k], dp[i][j]+a[j]*a[k]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = -INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i) <span class="hljs-built_in">upmax</span>(res, dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="codeforces-1312e"><a href="https://codeforces.com/contest/1312/problem/E">Codeforces 1312E</a></h3><p>我们用 <code>ans[i][j]</code> 表示前 <code>i</code> 个数中以 <code>j</code> 结尾的最短数列长度，并用 <code>b[i][j]</code> 保存导致它以 <code>j</code> 结尾的前缀首项的位置。那么状态转移就显然，可从代码中读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1022</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> ans[<span class="hljs-number">502</span>][N],b[<span class="hljs-number">502</span>][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n,x;<br>  <span class="hljs-keyword">while</span>(cin&gt;&gt;n)&#123;<br>    <span class="hljs-built_in">memset</span>(ans,inf,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));<br>    cin&gt;&gt;x;<br>    ans[<span class="hljs-number">0</span>][x] = <span class="hljs-number">1</span>;<br>    b[<span class="hljs-number">0</span>][x]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br>      cin&gt;&gt;x;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;N;++j)&#123;<br>        <span class="hljs-keyword">if</span>(ans[i<span class="hljs-number">-1</span>][j]!=inf)&#123;<br>          ans[i][x] = <span class="hljs-built_in">min</span>(ans[i][x],ans[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>);<br>        &#125;<br>        b[i][x]=i;<br>      &#125;<br>      <span class="hljs-keyword">int</span> s = i<span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">while</span>(s&gt;=<span class="hljs-number">0</span>&amp;&amp;ans[s][x]!=inf)&#123;<br>        ans[i][x+<span class="hljs-number">1</span>] = ans[s][x];<br>        b[i][x+<span class="hljs-number">1</span>] = b[s][x];<br>        s = b[s][x]<span class="hljs-number">-1</span>;<br>        ++x;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> r = inf;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;N;++i)&#123;<br>      r = <span class="hljs-built_in">min</span>(r,ans[n<span class="hljs-number">-1</span>][i]);<br>    &#125;<br>    cout&lt;&lt;r&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="洛谷-p1005-矩阵取数游戏"><a href="https://www.luogu.com.cn/problem/P1005">洛谷 P1005 矩阵取数游戏</a></h3><blockquote><p>每一行单独考虑，然后因为数据范围，所以用 Python 交题</p><p>按照规模做 <code>dp</code>，最近做的很少，记录一哈 2020/7/4</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>):</span><br>  b = a.copy()<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(a)):<br>    c = []<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(b)-<span class="hljs-number">1</span>):<br>      c.append(<span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>*b[j]+a[i+j],<span class="hljs-number">2</span>*b[j+<span class="hljs-number">1</span>]+a[j]))<br>    b=c<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*b[<span class="hljs-number">0</span>]<br><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().split()[<span class="hljs-number">0</span>])<br>r=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>  r += f([<span class="hljs-built_in">int</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()])<br><span class="hljs-built_in">print</span>(r)<br></code></pre></td></tr></table></figure><h3 id="洛谷-t135246-swtr-05grid"><a href="https://www.luogu.com.cn/problem/T135246?contestId=28195">洛谷 T135246 「SWTR-05」Grid</a></h3><p><code>dp[i][j]</code> ：第 <code>i</code> 行，以第 <code>j</code> 个数结尾的最小和， <code>s[i][j]</code> ：第 <code>i</code> 行，前 <code>j</code> 个数之和</p><p><code>rr[i][j]</code> ：到达 <code>i,j</code> 位置经过的数字和。</p><p><code>r[i][j]</code> ：首次到达 <code>i,j</code> 位置经过格子的数字和(不包括 <code>i,j</code> 的值）初值为 <code>rr[i+1][j]</code></p><p><code>dp[i][j]</code> 和 <code>s[i][j]</code> 的状态转移是显然的，<code>rr[i][j]</code> 和 <code>r[i][j]</code> 状态转移： <span class="math display">\[\begin{aligned}r[i][j] = \min_{j \leq k&lt;m} r[i][k] + s[i][k] - s[i][j] \\rr[i][j] = r[i][j] + dp[i][j]\end{aligned}\]</span> 由于 <code>r[i][j]</code> 转移式的对称性，我们考虑记录 <code>s[i][j] + r[i][j]</code> 的最小值，（直接优化了一个 <span class="math inline">\(O(m)\)</span>），这也是此题的经典之处。最后 <code>rr</code> 数组可被优化掉。当然也可以对 <code>r</code> 进行空间优化，<del>但是没必要</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n,m;<br>  cin&gt;&gt;n&gt;&gt;m;<br>  LL a[n][m],dp[n][m],s[n][m],r[n+<span class="hljs-number">1</span>][m];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)&#123;<br>      cin&gt;&gt;a[i][j];<br>      <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) s[i][j] = a[i][j];<br>      <span class="hljs-keyword">else</span> s[i][j] = s[i][j<span class="hljs-number">-1</span>]+a[i][j];<br>      cur += a[i][j];<br>      dp[i][j] = cur;<br>      cur = <span class="hljs-built_in">min</span>(cur,<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>    LL mi = <span class="hljs-number">1e9</span>+<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=m<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;--j)&#123;<br>      r[i][j] = (i==n<span class="hljs-number">-1</span>?<span class="hljs-number">0</span>:r[i+<span class="hljs-number">1</span>][j]);<br>      <span class="hljs-keyword">if</span>(r[i][j]&lt;mi-s[i][j])&#123;<br>        mi = r[i][j]+s[i][j];<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        r[i][j] = mi-s[i][j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)&#123;<br>      r[i][j] += dp[i][j];<br>    &#125;<br>  &#125;<br>  LL ret = r[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;m;++j)&#123;<br>    ret = <span class="hljs-built_in">min</span>(ret,r[<span class="hljs-number">0</span>][j]);<br>  &#125;<br>  cout&lt;&lt;ret&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面上题的 <strong>空间优化版本（优雅的不行，需要考虑从上向下走）</strong>：</p><p><code>rr[j]</code> 表示上一行的答案， <code>r[j]</code> 表示当前行的答案。那么 <code>r[j]</code> 的初始值应该为 <code>rr[j]+dp[j]</code>，状态转移 <span class="math display">\[r[j] = \min_{0 \leq k \leq j} r[k] - s[k] + s[j]\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n,m;<br>  cin&gt;&gt;n&gt;&gt;m;<br>  LL a[m],s[m],dp[m],r[m],rr[m]=&#123;&#125;;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    LL cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)&#123;<br>      cin&gt;&gt;a[j];<br>      cur += a[j];<br>      dp[j] = cur;<br>      cur = <span class="hljs-built_in">min</span>(cur,<span class="hljs-number">0LL</span>);<br>      s[j] = a[j]+(j==<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:s[j<span class="hljs-number">-1</span>]);<br>    &#125;<br>    cur = rr[<span class="hljs-number">0</span>]+dp[<span class="hljs-number">0</span>]-s[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)&#123;<br>      r[j] = <span class="hljs-built_in">min</span>(rr[j]+dp[j],cur+s[j]);<br>      cur = <span class="hljs-built_in">min</span>(cur,r[j]-s[j]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j) rr[j] = r[j];<br>  &#125;<br>  cout&lt;&lt;*<span class="hljs-built_in">min_element</span>(rr,rr+m)&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="t134867-ysoi2020归零"><a href="https://www.luogu.com.cn/problem/T134867?contestId=31074">T134867 [YsOI2020]归零</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">const</span> LL M = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">132</span>;<br>LL f[N],invf[N];<br><span class="hljs-function">LL <span class="hljs-title">pow_mod</span><span class="hljs-params">(LL x,LL n)</span></span>&#123;<br>  LL r = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(n)&#123;<br>    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) r=r*x%M;<br>    n&gt;&gt;=<span class="hljs-number">1</span>; x=x*x%M;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>  f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;N;++i) f[i]=f[i<span class="hljs-number">-1</span>]*i%M;<br>  invf[N<span class="hljs-number">-1</span>] = <span class="hljs-built_in">pow_mod</span>(f[N<span class="hljs-number">-1</span>],M<span class="hljs-number">-2</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=N<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i) invf[i] = invf[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%M;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(k&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> f[n]*invf[n-k]%M*invf[k]%M;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-built_in">init</span>();<br>  string ss;<br>  cin&gt;&gt;ss;<br>  vector&lt;<span class="hljs-keyword">int</span>&gt; s=&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c:ss) s.<span class="hljs-built_in">emplace_back</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>);<br>  <span class="hljs-keyword">auto</span> plusOne = [&amp;](<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)&#123;<br>    <span class="hljs-keyword">int</span> id = r<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(s[id]==<span class="hljs-number">9</span>) --id;<br>    ++s[id];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=id+<span class="hljs-number">1</span>;i&lt;r;++i) s[i] = <span class="hljs-number">0</span>;<br>  &#125;;<br>  <span class="hljs-keyword">auto</span> minusOne = [&amp;](<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)&#123;<br>    <span class="hljs-keyword">int</span> id = r<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(s[id]==<span class="hljs-number">0</span>) --id;<br>    --s[id];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=id+<span class="hljs-number">1</span>;i&lt;r;++i) s[i] = <span class="hljs-number">9</span>;<br>  &#125;;<br>  function&lt;map&lt;<span class="hljs-keyword">int</span>,LL&gt;(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f = [&amp;](<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r) -&gt; map&lt;<span class="hljs-keyword">int</span>,LL&gt;&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">all_of</span>(s.<span class="hljs-built_in">begin</span>()+l,s.<span class="hljs-built_in">begin</span>()+r,[](<span class="hljs-keyword">int</span> x)&#123; <span class="hljs-keyword">return</span> x == <span class="hljs-number">0</span>;&#125;))&#123;<br>      <span class="hljs-keyword">return</span> map&lt;<span class="hljs-keyword">int</span>,LL&gt;&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>    &#125;<br>    map&lt;<span class="hljs-keyword">int</span>,LL&gt; ret;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=l;i&lt;r;++i)&#123;<br>      <span class="hljs-keyword">if</span>(s[i])&#123;<br>        <span class="hljs-keyword">int</span> x = s[i];<br>        s[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">4</span>) <span class="hljs-built_in">plusOne</span>(l,i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ia:<span class="hljs-built_in">f</span>(l,i))&#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ib:<span class="hljs-built_in">f</span>(i,r))&#123;<br>            <span class="hljs-keyword">int</span> t1 = <span class="hljs-number">1</span>+ia.first+ib.first;<br>            LL t2 = ia.second*ib.second%M*<span class="hljs-built_in">C</span>(ia.first+ib.first,ia.first)%M;<br>            <span class="hljs-keyword">if</span>(ret.<span class="hljs-built_in">find</span>(t1)==ret.<span class="hljs-built_in">end</span>())&#123;<br>              ret[t1] = t2;<br>            &#125;<span class="hljs-keyword">else</span> ret[t1] = (ret[t1]+t2)%M;<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">4</span>) <span class="hljs-built_in">minusOne</span>(l,i);<br>        s[i]=x;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;;<br>  LL res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;x:<span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>,s.<span class="hljs-built_in">size</span>()))&#123;<br>    <span class="hljs-comment">//cout&lt;&lt;x.first&lt;&lt;&quot; &quot;&lt;&lt;x.second&lt;&lt;endl;</span><br>    res+=x.second;<br>  &#125;<br>  cout&lt;&lt;res%M&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态压缩-dpmask-dp">状态压缩 DP（mask dp）</h2><h3 id="给定-2n-个非负整数求两两配对的最大公约数的和的最大值">给定 <span class="math inline">\(2n\)</span> 个非负整数，求两两配对的最大公约数的和的最大值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>  <span class="hljs-comment">// input n and 2n non-negetive integers(less than 1e9)</span><br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  n *= <span class="hljs-number">2</span>;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  <span class="hljs-comment">// initial all gcd which will be used for effectiveness</span><br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">gcd</span>(n, std::vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>      gcd[i][j] = std::__gcd(a[i], a[j]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">auto</span> cmax = [](LL &amp;a, LL b) &#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) a = b;<br>  &#125;;<br>  <span class="hljs-comment">// total complex O(2^n * n^3) and we can remove the &quot;if&quot; part of following code</span><br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">mask</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>; step &lt; n; ++step) &#123; <span class="hljs-comment">// every step choose two integers</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> msk = <span class="hljs-number">0</span>; msk &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++msk) <span class="hljs-keyword">if</span> (__builtin_popcount(msk) == <span class="hljs-number">2</span> * step) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!(msk &amp; (<span class="hljs-number">1</span> &lt;&lt; i))) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) <span class="hljs-keyword">if</span> (!(msk &amp; (<span class="hljs-number">1</span> &lt;&lt; j))) &#123;<br>          <span class="hljs-built_in">cmax</span>(mask[msk|(<span class="hljs-number">1</span> &lt;&lt; i)|(<span class="hljs-number">1</span> &lt;&lt; j)], mask[msk] + gcd[i][j]);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">print</span>(mask.<span class="hljs-built_in">back</span>());<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>本问题可以在多项式时间用<a href="https://oi-wiki.org/topic/graph-matching/general-match/">一般图匹配</a> 解决。</p></blockquote><h3 id="旅行商问题"><a href="https://atcoder.jp/contests/abc180/tasks/abc180_e">旅行商问题</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  std::vector&lt;std::tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[x, y, z] : a) std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>  <span class="hljs-keyword">auto</span> dist = [&amp;](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) &#123;<br>    <span class="hljs-keyword">auto</span> [aix, aiy, aiz] = a[i];<br>    <span class="hljs-keyword">auto</span> [ajx, ajy, ajz] = a[j];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(aix - ajx) + <span class="hljs-built_in">abs</span>(aiy - ajy) + std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, ajz - aiz);<br>  &#125;;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">d</span>(n, std::vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>      d[i][j] = <span class="hljs-built_in">dist</span>(i, j);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> cmin = [](<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> b) &#123;<br>    <span class="hljs-keyword">if</span> (a &gt; b) a = b;<br>  &#125;;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">mask</span>(<span class="hljs-number">1</span> &lt;&lt; n, std::vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">1e8</span>));<br>  mask[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = <span class="hljs-number">1</span>; step &lt; n; ++step) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> msk = <span class="hljs-number">1</span>; msk &lt; (<span class="hljs-number">1</span> &lt;&lt; n); msk += <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> (__builtin_popcount(msk) == step) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (msk &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) <span class="hljs-keyword">if</span> (!(msk &amp; (<span class="hljs-number">1</span> &lt;&lt; j))) &#123;<br>          <span class="hljs-built_in">cmin</span>(mask[msk|(<span class="hljs-number">1</span> &lt;&lt; j)][j], mask[msk][i] + d[i][j]);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">int</span> r = <span class="hljs-number">1e8</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) r = std::<span class="hljs-built_in">min</span>(r, mask[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][i] + d[i][<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">print</span>(r);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="b状态压缩-dp"><a href="https://codeforces.com/contest/453/problem/B">453B</a>：状态压缩 DP</h3><p>给定数列 <span class="math inline">\(a\)</span>，求满足元素两两互素的数列 <span class="math inline">\(b\)</span> 使得 <span class="math inline">\(\sum |a_i - b_i|\)</span> 最小</p><blockquote><p>注意到 <span class="math inline">\(b_i &lt; 2 a_i\)</span>，因为否则取 <span class="math inline">\(b_i = 1\)</span> 即可。</p></blockquote><p>由于 <span class="math inline">\(60\)</span> 内的素数个数为 17, 因此可以状态压缩 DP。设 <code>dp[i][j]</code> 表示使得 <span class="math inline">\(\sum_{k = 1} ^ i |a_k - b_k|\)</span> 最小，且<span class="math inline">\(b_1 \cdots b_i\)</span> 中所有出现的素因子的状态为 <span class="math inline">\(j\)</span>。因此状态转移就是 <code>dp[i][j | factor[k]] = min(dp[i - 1][j] + |a_i - k|)</code>，其中 <code>factor[k]</code> 与 <span class="math inline">\(j\)</span> 没有交集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  <span class="hljs-keyword">int</span> ma = *std::<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) * <span class="hljs-number">2</span>;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; p;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; ma; ++i) &#123;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j * j &lt;= i; ++j) <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;<br>      flag = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) p.<span class="hljs-built_in">emplace_back</span>(i);<br>  &#125;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">factor</span><span class="hljs-params">(ma)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; ma; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; p.<span class="hljs-built_in">size</span>(); ++j) <span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>) &#123;<br>      factor[i] |= (<span class="hljs-number">1</span> &lt;&lt; j);<br>    &#125;<br>  &#125;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n + <span class="hljs-number">1</span>, std::vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span> &lt;&lt; p.<span class="hljs-built_in">size</span>(), <span class="hljs-number">1e9</span>));<br>  ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * a[i - <span class="hljs-number">1</span>]; ++j) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; (<span class="hljs-number">1</span> &lt;&lt; p.<span class="hljs-built_in">size</span>()); ++k) <span class="hljs-keyword">if</span> ((k &amp; factor[j]) == <span class="hljs-number">0</span>) &#123;<br>        ans[i][k | factor[j]] = std::<span class="hljs-built_in">min</span>(ans[i][k | factor[j]], ans[i - <span class="hljs-number">1</span>][k] + <span class="hljs-built_in">abs</span>(a[i - <span class="hljs-number">1</span>] - j));<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">r</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">int</span> now = std::<span class="hljs-built_in">min_element</span>(ans[n].<span class="hljs-built_in">begin</span>(), ans[n].<span class="hljs-built_in">end</span>()) - ans[n].<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">2</span> * a[i]; ++j) <span class="hljs-keyword">if</span> ((now | factor[j]) == now) &#123;<br>      <span class="hljs-keyword">if</span> (ans[i][now ^ factor[j]] + <span class="hljs-built_in">abs</span>(a[i] - j) == ans[i + <span class="hljs-number">1</span>][now]) &#123;<br>        r[i] = j;<br>        now ^= factor[j];<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : r) std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  println;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c状态压缩-dp-fwt-模板"><a href="https://codeforces.com/contest/662/problem/C">662C</a>：状态压缩 DP + FWT 模板</h3><p>给定 <span class="math inline">\(n \times m\)</span> 的 0-1 方阵，可以取反一些行和列使得最后 0 的数列最小。</p><blockquote><p>首先注意到 <span class="math inline">\(n &lt; 20\)</span>，我们可以把每一列看作一个状态 <code>i</code> ，并且结果跟列的顺序无关。我们可以记录下初始情况每种状态数 C[i] 量。 并且每一种状态 <code>i</code> 对答案的贡献显然就是它的 0, 1 个数的最小值记作 <code>g[i]</code>。 对于每一个行取反 S, 其实就是将一个状态 i 变成 状态 <code>i ^ S</code> 所以每一种行取反 S，最终的答案 <span class="math inline">\(\displaystyle F(S) = \sum_{i} C[i] \cdot g[i \wedge S] = \sum_{i \wedge j = S} C[i] \cdot g[j]\)</span></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> print(x) std::cout &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> println std::cout &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> P = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    (x += y) &gt;= P &amp;&amp; (x -= P);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    (x -= y) &lt; <span class="hljs-number">0</span> &amp;&amp; (x += P);<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FWT</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">extend</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> N = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (; N &lt; n; N &lt;&lt;= <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> N;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FWTor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, <span class="hljs-keyword">bool</span> rev)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>, m = <span class="hljs-number">1</span>; l &lt;= n; l &lt;&lt;= <span class="hljs-number">1</span>, m &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j += l) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!rev) <span class="hljs-built_in">add</span>(a[i + j + m], a[i + j]);<br>                <span class="hljs-keyword">else</span> <span class="hljs-built_in">sub</span>(a[i + j + m], a[i + j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FWTand</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, <span class="hljs-keyword">bool</span> rev)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>, m = <span class="hljs-number">1</span>; l &lt;= n; l &lt;&lt;= <span class="hljs-number">1</span>, m &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j += l) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!rev) <span class="hljs-built_in">add</span>(a[i + j], a[i + j + m]);<br>                <span class="hljs-keyword">else</span> <span class="hljs-built_in">sub</span>(a[i + j], a[i + j + m]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FWTxor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, <span class="hljs-keyword">bool</span> rev)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>(), inv2 = (P + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>, m = <span class="hljs-number">1</span>; l &lt;= n; l &lt;&lt;= <span class="hljs-number">1</span>, m &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j += l) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">int</span> x = a[i + j], y = a[i + j + m];<br>                <span class="hljs-keyword">if</span> (!rev) &#123;<br>                    a[i + j] = (x + y) % P;<br>                    a[i + j + m] = (x - y + P) % P;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    a[i + j] = <span class="hljs-number">1LL</span> * (x + y) * inv2 % P;<br>                    a[i + j + m] = <span class="hljs-number">1LL</span> * (x - y + P) * inv2 % P;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Or</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; a1, std::vector&lt;<span class="hljs-keyword">int</span>&gt; a2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = std::<span class="hljs-built_in">max</span>(a1.<span class="hljs-built_in">size</span>(), a2.<span class="hljs-built_in">size</span>()), N = <span class="hljs-built_in">extend</span>(n);<br>        a1.<span class="hljs-built_in">resize</span>(N), <span class="hljs-built_in">FWTor</span>(a1, <span class="hljs-literal">false</span>);<br>        a2.<span class="hljs-built_in">resize</span>(N), <span class="hljs-built_in">FWTor</span>(a2, <span class="hljs-literal">false</span>);<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(N)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) A[i] = <span class="hljs-number">1LL</span> * a1[i] * a2[i] % P;<br>        <span class="hljs-built_in">FWTor</span>(A, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">And</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; a1, std::vector&lt;<span class="hljs-keyword">int</span>&gt; a2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = std::<span class="hljs-built_in">max</span>(a1.<span class="hljs-built_in">size</span>(), a2.<span class="hljs-built_in">size</span>()), N = <span class="hljs-built_in">extend</span>(n);<br>        a1.<span class="hljs-built_in">resize</span>(N), <span class="hljs-built_in">FWTand</span>(a1, <span class="hljs-literal">false</span>);<br>        a2.<span class="hljs-built_in">resize</span>(N), <span class="hljs-built_in">FWTand</span>(a2, <span class="hljs-literal">false</span>);<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(N)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) A[i] = <span class="hljs-number">1LL</span> * a1[i] * a2[i] % P;<br>        <span class="hljs-built_in">FWTand</span>(A, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Xor</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; a1, std::vector&lt;<span class="hljs-keyword">int</span>&gt; a2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = std::<span class="hljs-built_in">max</span>(a1.<span class="hljs-built_in">size</span>(), a2.<span class="hljs-built_in">size</span>()), N = <span class="hljs-built_in">extend</span>(n);<br>        a1.<span class="hljs-built_in">resize</span>(N), <span class="hljs-built_in">FWTxor</span>(a1, <span class="hljs-literal">false</span>);<br>        a2.<span class="hljs-built_in">resize</span>(N), <span class="hljs-built_in">FWTxor</span>(a2, <span class="hljs-literal">false</span>);<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(N)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) A[i] = <span class="hljs-number">1LL</span> * a1[i] * a2[i] % P;<br>        <span class="hljs-built_in">FWTxor</span>(A, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125; fwt;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n, m;<br>  std::cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span>, <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>      r |= (a[j][i] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;&lt; j;<br>    &#125;<br>    ++c[r];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++j) &#123;<br>      <span class="hljs-keyword">if</span> (j &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) ++g[j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++i) &#123;<br>    g[i] = std::<span class="hljs-built_in">min</span>(g[i], n - g[i]);<br>  &#125;<br>  <span class="hljs-keyword">auto</span> f = fwt.<span class="hljs-built_in">Xor</span>(c, g);<br>  <span class="hljs-built_in">print</span>(*std::<span class="hljs-built_in">min_element</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>()));<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树形-dp">树形 DP</h2><blockquote><p>树形 DP 本质上就是，树结构可以给出各种不同的偏序关系，针对不同的问题，给出偏序关系，再来 DP</p></blockquote><h2 id="换根-dp">换根 DP</h2><p>树形 DP 的进阶：<a href="https://zhuanlan.zhihu.com/p/348349531">朝夕 ACM 笔记</a></p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P3478">LOJ P3478</a></p><p>题意：求以树的某个节点为根，各个节点的深度之和</p><p>做法：先以 1 为根预处理出所有子树的深度之和，然后 DP，例如 v 的父节点为 u，那么 <code>ans[v] = ans[u] - sz[v] + sz[1] - sz[v]</code> (以 v 的根的子树的深度都要降低 1， v 的父节点和兄弟节点深度都要加 1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> u, v;<br>    std::cin &gt;&gt; u &gt;&gt; v;<br>    e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>    e[v].<span class="hljs-built_in">emplace_back</span>(u);<br>  &#125;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">sz</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; pdfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; <span class="hljs-keyword">void</span> &#123;<br>    sz[u] = <span class="hljs-number">1</span>;<br>    ans[u] = dep[u];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) &#123;<br>      dep[v] = dep[u] + <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">pdfs</span>(v, u);<br>      sz[u] += sz[v];<br>      ans[u] += ans[v];<br>    &#125;<br>  &#125;;<br>  dep[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">pdfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 预处理出 1 为根的结果，然后进行换根 DP</span><br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) -&gt; <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) &#123;<br>      ans[v] = ans[u] + sz[<span class="hljs-number">1</span>] - <span class="hljs-number">2</span> * sz[v];<br>      <span class="hljs-built_in">dfs</span>(v, u);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  std::cout &lt;&lt; std::<span class="hljs-built_in">max_element</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>()) - ans.<span class="hljs-built_in">begin</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>换根 DP 套路：</p><ul><li>dfs 预处理以 1 为根的结果，预处理时其实也计算了子树的结果</li><li>第二次 dfs 进行 DP。</li></ul><p>其它例题：<a href="https://codeforces.com/problemset/problem/1324/F">1324F</a> 和 <a href="https://codeforces.com/problemset/problem/708/C">708C</a></p><h2 id="斜率优化-dpon">斜率优化 DP（<span class="math inline">\(O(n)\)</span>）</h2><p>形如 <span class="math inline">\(\displaystyle dp[i] = c_i + \min_{j &lt; i} a_j x_i + b_j\)</span> 的都可以用斜率优化 DP（要求 <span class="math inline">\(x_i, a_j\)</span> 单调，最大值同理也是一样的）</p><blockquote><p>也称<a href="https://zhuanlan.zhihu.com/p/363772434">凸壳优化 DP</a></p></blockquote><p>例题：<a href="https://www.luogu.com.cn/problem/P2120">LOJ P2120</a></p><p>就此题具体说明斜率优化 DP</p><p>首先设 <code>dp[i]</code> 为在第 i 个工厂建设仓库，前 i 个工厂的费用之和的最小值。显然 <span class="math inline">\(dp[0] = 0\)</span></p><p><span class="math display">\[dp[i] = c_i + \min_{j &lt; i} dp[j] + \sum_{k = j + 1}^i (x_i - x_k) p_k\]</span></p><p>设 <span class="math inline">\(a_i = \sum_{j = 1}^i p_j\)</span>，<span class="math inline">\(b_i = \sum_{j = 1}^i x_j p_j\)</span>，则</p><p><span class="math display">\[dp[i] = c_i + a_i x_i - b_i + \min_{j &lt; i} -a_j x_i + (b_j + dp[j])\]</span></p><p>不妨设 <span class="math inline">\(i &gt; j &gt; k\)</span>，那么若决策 j 优于 k 当且仅当 <span class="math inline">\(-a_j x_i + b_j + dp[j] &lt; -a_k x_i + b_k + dp[k]\)</span> 当且仅当 <span class="math inline">\(x_i &gt; \frac{(b_j + dp[j]) - (b_k + dp[k])}{a_j - a_k}\)</span>（记作 solpe(j, k)），显然若 <code>solpe(i, j) &lt; solpe(j, k)</code> 则 <code>j</code> 必不可能成为最优点。因此相邻的节点斜率必然是递增的，因此合法队首对应的就是答案。用一个双向队列即可。（实现的时候变量有一些混用为了代码的简洁）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">x</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    std::cin &gt;&gt; x[i] &gt;&gt; a[i] &gt;&gt; c[i];<br>    ++x[i]; <span class="hljs-comment">// 为了避免 x[0] = x[1]</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    b[i] = b[i - <span class="hljs-number">1</span>] + x[i] * a[i];<br>    a[i] += a[i - <span class="hljs-number">1</span>];<br>  &#125;<br>  <span class="hljs-comment">// j &gt; k,</span><br>  <span class="hljs-keyword">auto</span> solpe = [&amp;](<span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k) -&gt; <span class="hljs-keyword">double</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(b[j] - b[k]) / (a[j] - a[k]);<br>  &#125;;<br>  <span class="hljs-comment">// 这里手写双向队列要更为方便，队列中相邻两点斜率是单调递增的，且队首最优</span><br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">Q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; <span class="hljs-built_in">solpe</span>(Q[l + <span class="hljs-number">1</span>], Q[l]) &lt;= x[i]) ++l;<br>    dp[i] = c[i] + (a[i] - a[Q[l]]) * x[i] - b[i] + b[Q[l]];<br>    b[i] += dp[i];<br>    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; <span class="hljs-built_in">solpe</span>(Q[r], Q[r - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-built_in">solpe</span>(i, Q[r])) --r;<br>    Q[++r] = i;<br>  &#125;<br>  std::cout &lt;&lt; dp.<span class="hljs-built_in">back</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意到上述问题中 <span class="math inline">\(b_j\)</span> 的取值和 <code>dp[j]</code> 有关，即不能提前给出 <span class="math inline">\(b_j\)</span>，因此没法写出可复用的代码，必须好好理解，然后灵活运用</p></blockquote><p>因此我们更一般性的利用 <strong>凸包优化 DP</strong> 在 <span class="math inline">\(O(n \log n)\)</span> 复杂度更一般性的解决问题，不需要通用性</p><h2 id="凸包优化-dpon-log-n">凸包优化 DP（<span class="math inline">\(O(n \log n)\)</span>）</h2><h2 id="四边形优化-dp"><a href="https://oi-wiki.org/dp/opt/quadrangle/">四边形优化 DP</a></h2><h3 id="区间-2d1d-动态规划将-on3-复杂度优化成-on2">区间 2D1D 动态规划，将 <span class="math inline">\(O(n^3)\)</span> 复杂度优化成 <span class="math inline">\(O(n^2)\)</span></h3><p><span class="math display">\[f_{l, r} = \min_{l \leq k &lt; r} f_{l, k} + f_{k + 1, r} + w(l, r) \qquad (1 \leq l &lt; r \leq n)\]</span></p><p>其中 <span class="math inline">\(w(l, r)\)</span> 满足</p><ul><li>区间单调性：<span class="math inline">\(w(l&#39;, r&#39;) \leq w(l, r)\)</span> 对任意 <span class="math inline">\(l \leq l&#39; \leq r&#39; \leq r\)</span> 成立</li><li>四边形不等式：<span class="math inline">\(w(l_1, r_1) + w(l_2, r_2) \leq w(l_2, r_1) + w(l_1, r_2)\)</span> 对任意 <span class="math inline">\(l_1 \leq l_2 \leq r_1 \leq r_2\)</span> 成立。</li><li>四边形不等式（等价形式）：<span class="math inline">\(w(i, j) + w(i + 1, j + 1) \geq w(i + 1, j) + w(i, j + 1)\)</span> 对任意 <span class="math inline">\(i &lt; j\)</span> 成立。</li></ul><p>若 <span class="math inline">\(w(l, r)\)</span> 满足上述关系，那么 <span class="math inline">\(f_{l, r}\)</span> 满足四边形不等式。首先注意到 <span class="math inline">\(l_1 = l_2\)</span> 或 <span class="math inline">\(r_1 = r_2\)</span> 时是平凡的。我们分 <span class="math inline">\(l_1 &lt; l_2 = r_1 &lt; r_2\)</span> 和 <span class="math inline">\(l_1 &lt; l_2 &lt; r_1 &lt; r_2\)</span> 两种情况讨论，都用数学归纳法证明。第一种情形只需 <span class="math inline">\(w(l, r)\)</span> 的区间单调性，第二种情形的证明只需四边形不等式。</p><p><a href="https://github.com/OI-wiki/OI-wiki/pull/2958/commits/172c5b18aa3b3b63fd4df4978341a1743818ef05">完整证明</a></p><p>此时记 <span class="math inline">\(m_{l, r} = \min \{k: f_{l, r} = f_{l, k} + f_{k + 1, r} + w(l, r)\} \quad (1 \leq l &lt; r \leq n)\)</span> 即最小最优决策点。则有（反证法证明） <span class="math display">\[m_{l, r - 1} \leq m_{l, r} \leq m_{l + 1, r} \quad (l + 1 &lt; r)\]</span></p><p>因此如果我们在计算 <span class="math inline">\(f_{l, r}\)</span> 的同时记录下最小最优决策点 <span class="math inline">\(m_{l, r}\)</span> 那么我们对 决策点 <span class="math inline">\(k\)</span> 的总枚举次数为</p><p><span class="math display">\[\sum_{1 \leq l \leq r} m_{l, r} = n - 1 +\sum_{1 \leq l + 1 \leq r} m_{l + 1, r} - m_{l, r -1} = n - 1 \sum_{1 &lt; i &lt; n} m_{i, n} - m_{1, i} \leq n^2\]</span></p><blockquote><p>若 <span class="math inline">\(w\)</span> 仅满足区间单调性，我们取最大值，那么做法完全不同，此时</p></blockquote><p><span class="math display">\[g_{l, r} = \max_{l \leq k &lt; r} g_{l, k} + g_{k + 1, r} + w(l, r) \qquad (1 \leq l &lt; r \leq n)\]</span> 我们可以证明：<span class="math inline">\(g_{l, r} = \max \left(g_{l, l} + g_{l + 1, r}, g_{l, r - 1} + g(r, r) \right) + w(l, r)\)</span>。</p><p>设 <span class="math inline">\(k\)</span> 是 <span class="math inline">\(g_{l, r}\)</span> 的最小最优决策点。不妨假设 <span class="math inline">\(l &lt; k &lt; r - 1\)</span>，设 <span class="math inline">\(u\)</span> 是 <span class="math inline">\(g_{l, k}\)</span> 的最优决策点，<span class="math inline">\(v\)</span> 是 <span class="math inline">\(g_{k + 1, r}\)</span> 的最优决策点。那么我们先决策 <span class="math inline">\(u\)</span> 再决策 <span class="math inline">\(k\)</span> 可知 <span class="math inline">\(w(u + 1, r) &lt; w(l, k)\)</span>。先决策 <span class="math inline">\(v\)</span> 再决策 <span class="math inline">\(k\)</span> 知 <span class="math inline">\(w(l, v) \leq w(k + 1, r)\)</span>，然而 <span class="math inline">\(w(l, v) + w(u + 1,r) \geq w(l, k) + w(k + 1, r)\)</span> 矛盾。（画图看就能看得很清晰）</p><p>模板例题：<a href="https://www.luogu.com.cn/problem/P1880">LOJ P1880</a></p><p>题意：在一个圆圈上，有 n 堆石子，可以合并相邻的石子获得合并后的石子数的得分。问最后合并成一堆时最大得分和最小得分。</p><p>做法：首先我们可以搞 2n 堆石子，破圈为链。然后设 <span class="math inline">\(f_{i, j}, g_{i, j}\)</span> 为分别为第 i 堆到第 j 堆合并成一堆的最小和最大得分。记 <span class="math inline">\(w(i, j)\)</span> 为第 i 堆到第 j 堆石子数之和，则</p><p><span class="math display">\[\begin{aligned}f_{i, j} = \min_{i \leq k &lt; j} g(i, k) + g(k + 1, j) + w(i, j) \\g_{i, j} = \max_{i \leq k &lt; j} g(i, k) + g(k + 1, j) + w(i, j)\end{aligned}\]</span></p><p>显然 <span class="math inline">\(w(i, j)\)</span> 满足区间单调性和四边形恒等式，因此对于最小都可以用平行四边形优化。</p><p>对于最大值，用上述优化做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  <span class="hljs-function">std::vector&lt;LL&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-comment">// 破圈为链</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>    std::cin &gt;&gt; a[i];<br>    a[i + n] = a[i];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; ++i) a[i] += a[i - <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">auto</span> w = [&amp;](<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r) &#123;<br>    <span class="hljs-keyword">return</span> a[r] - a[l - <span class="hljs-number">1</span>];<br>  &#125;;<br>  std::vector&lt;std::vector&lt;LL&gt;&gt; <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, std::vector&lt;LL&gt;(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>)), <span class="hljs-built_in">mf</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>, std::vector&lt;LL&gt;(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * n; ++i) &#123;<br>    f[i][i + <span class="hljs-number">1</span>] = <span class="hljs-built_in">w</span>(i, i + <span class="hljs-number">1</span>);<br>    mf[i][i + <span class="hljs-number">1</span>] = i;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> g = f;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt; n; ++len) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = len + <span class="hljs-number">1</span>; r &lt;= <span class="hljs-number">2</span> * n; ++l, ++r) &#123;<br>      f[l][r] = INT64_MAX;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = mf[l][r - <span class="hljs-number">1</span>]; k &lt;= mf[l + <span class="hljs-number">1</span>][r]; ++k) &#123;<br>        <span class="hljs-keyword">if</span> (f[l][r] &gt; f[l][k] + f[k + <span class="hljs-number">1</span>][r]) &#123;<br>          f[l][r] = f[l][k] + f[k + <span class="hljs-number">1</span>][r];<br>          mf[l][r] = k;<br>        &#125;<br>      &#125;<br>      f[l][r] += <span class="hljs-built_in">w</span>(l, r);<br>      g[l][r] = std::<span class="hljs-built_in">max</span>(g[l + <span class="hljs-number">1</span>][r], g[l][r - <span class="hljs-number">1</span>]) + <span class="hljs-built_in">w</span>(l, r);<br>    &#125;<br>  &#125;<br>  LL ff = INT64_MAX;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ff = std::<span class="hljs-built_in">min</span>(ff, f[i][i + n - <span class="hljs-number">1</span>]);<br>  LL gg = INT64_MIN;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) gg = std::<span class="hljs-built_in">max</span>(gg, g[i][i + n - <span class="hljs-number">1</span>]);<br>  std::cout &lt;&lt; ff &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; gg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>石子合并问题的最优解法是 GarsiaWachs 算法，复杂度 <span class="math inline">\(O(n \log n)\)</span>。例题：<a href="https://www.luogu.com.cn/problem/P5569">LOJ 5569</a>，以后有时间再学论文：<a href="https://sci-hub.do/10.1016/0196-6774%2888%2990009-0#">A New Proof of the Garsia-Wachs Algorithm</a>，本质是决策树问题。</p></blockquote><h3 id="二维滚动-dp-分治-dp-将-on-m2-复杂度优化成-on-m">二维滚动 DP 分治 DP 将 <span class="math inline">\(O(n m^2)\)</span> 复杂度优化成 <span class="math inline">\(O(n m)\)</span></h3><p><span class="math display">\[f_{i, j} = \min_{k &lt; j} f_{i - 1, k} + w(k + 1, j) \quad (1 \leq i \leq n, 1 \leq j \leq m)\]</span></p><p>其中 <span class="math inline">\(f(0, 0) = 0\)</span>，<span class="math inline">\(f_0, i = \infty, f_{i, j} = 0 \quad i &gt; j\)</span>。<span class="math inline">\(w\)</span> 满足区间单调和四边形不等式。</p><p>不难看出 <span class="math inline">\(f_{1, j} = w(1, j)\)</span>。</p><p>我们对 <span class="math inline">\(i\)</span> 数学归纳法证明：<span class="math inline">\(f_{i, j + 1} + f_{i + 1, j} \geq f_{i, j} + f_{i + 1, j + 1}\)</span> 对任意 <span class="math inline">\(i &lt; j\)</span> 成立。即证明四边形不等式。</p><p>当 <span class="math inline">\(i = 1\)</span> 时，<span class="math inline">\(f_{2, j} = f_{1, p} + w(p + 1, j) = w(1, p) + w(p + 1, j)\)</span>，并且 <span class="math inline">\(f_{2, j + 1} \leq w(1, p) + w(p + 1, j + 1)\)</span></p><p>从而 <span class="math display">\[f_{1, j + 1} + f_{2, j} = w(1, j + 1) + w(1, p) + w(p + 1, j) \geq w(1, j) + w(p + 1, j + 1) + w(1, p) \geq f_{1, j} + f_{2, j + 1}\]</span></p><p>假设 <span class="math inline">\(f_{i - 1, j} + f_{i, j - 1} \geq f_{i - 1, j - 1} + f_{i, j}\)</span> 对任意 <span class="math inline">\(i &lt; j\)</span> 成立，那么显然 <span class="math inline">\(f_{i - 1, k} + f_{i, j - 1} \geq f_{i - 1, j - 1} + f_{i, k}\)</span> 对任意 <span class="math inline">\(i &lt; j \leq k\)</span> 成立。</p><p>分情况讨论，记 <span class="math inline">\(u, v\)</span> 分别为 <span class="math inline">\(f_{i, j + 1}, f_{i+ 1, j}\)</span> 的最优决策点（<span class="math inline">\(i - 1 \leq u \leq j, i \leq v &lt; j\)</span>）。那么</p><p>假设 <span class="math inline">\(i &lt; i + 1 &lt; j &lt; j +1\)</span></p><ul><li><p><span class="math inline">\(u \geq v\)</span>，则 <span class="math inline">\(i \leq u \leq j\)</span>，<span class="math inline">\(f_{i + 1, j + 1} \leq f_{i, u} + w(u + 1, j +1)\)</span>，<span class="math inline">\(f_{i, j} \leq f_{i - 1, v} + w(v + 1, j)\)</span> 从而 <span class="math display">\[  f_{i, j + 1} + f_{i + 1, j} = f_{i - 1, u} + w(u + 1, j +1) + f_{i, v} + w(v + 1, j)  \]</span> 由归纳法知道 <span class="math inline">\(f_{i - 1, u} + f_{i, v} \geq f_{i - 1, v} + f_{i, u} \quad (i - 1 &lt; i &lt; v \leq u)\)</span>。两式相加得到我们要证的目标。</p></li><li><p><span class="math inline">\(u &lt; v\)</span> 则 <span class="math inline">\(i - 1 \leq u &lt; j\)</span>，<span class="math inline">\(f_{i + 1, j + 1} \leq f_{i, v} + w(v + 1, j + 1), f_{i, j} \leq f_{i - 1, u} + w(u + 1, j)\)</span>，从而 <span class="math inline">\(u + 1 \leq v + 1 \leq j \leq j + 1\)</span> <span class="math display">\[  f_{i, j + 1} + f_{i + 1, j} - f_{i +1, j + 1} - f_{i, j} \geq w(u + 1, j +1) + w(v + 1, j) - w(v + 1, j + 1) - w(u + 1, j) \geq 0  \]</span></p></li></ul><p>假设 <span class="math inline">\(i &lt; i + 1 = j &lt; j + 1\)</span></p><ul><li><p>若 <span class="math inline">\(u &lt; j\)</span>，则 <span class="math inline">\(f_{i, j} \leq f_{i - 1, u} + w(u + 1, j)\)</span>， <span class="math display">\[  f_{i, j} + f_{i + 1, j + 1} \leq f_{i - 1, u} + w(u + 1, j) + f_{i, i} + w(i + 1, j + 1) \leq f_{i - 1, u} + w(u + 1, j + 1) + f_{i, i} + w(i + 1, j) = f_{i, j + 1} + f_{i + 1, j}  \]</span></p></li><li><p>若 <span class="math inline">\(u = j\)</span> ，注意到 <span class="math inline">\(i - 1 &lt; i = j - 1 &lt; j\)</span>，归纳法有 <span class="math inline">\(f_{i - 1, j} + f_{i, j - 1} \geq f_{i - 1, j - 1} + f_{i, j}\)</span>。所以 <span class="math inline">\(f_{i, j + 1} + f_{i + 1, j} = f_{i - 1, j} + w(j + 1, j + 1) + f_{i, j - 1} + w(j, j) \geq f_{i - 1, j - 1} + w(j, j) f_{i, j} + w(j + 1, j + 1) \geq f_{i, j} + f_{i + 1, j + 1}\)</span>，证毕。</p></li></ul><p>记 <span class="math inline">\(k[i][j]\)</span> 为 <span class="math inline">\(f_{i, j}\)</span> 的最小最优策略。</p><p>决策优化不等式：<span class="math inline">\(k[i -1][j] \leq k[i][j] \leq k[i][j + 1]\)</span>（注意这与之前的不同）。</p><p>证明：记 <span class="math inline">\(u = k[i][j], x = k[i - 1][j], y = k[i][j + 1]\)</span>，反证法：若 <span class="math inline">\(u &lt; x\)</span>。首先由定义 <span class="math display">\[f_{i - 1, u} + w(u + 1, j) \leq f_{i - 1, x} + w(x + 1, j)\]</span> 又 <span class="math inline">\(i - 2 &lt; i - 1 \leq u &lt; k\)</span>，因此 <span class="math display">\[f_{i - 2, u} + f_{i - 1, x} \leq f_{i - 2, x} + f_{i - 1, u}\]</span> 两式相加得到 <span class="math display">\[f_{i - 2, u} + w(u + 1, j) \leq f_{i - 2, x} + w(x + 1, j)\]</span> 矛盾与 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(f_{i - 1, j}\)</span> 的最小最优策略。</p><p>同理，假设 <span class="math inline">\(u &gt; y\)</span>。由定义 <span class="math display">\[f_{i - 1, y} + w(y + 1, j + 1) \leq f_{i - 1, u} + w(u + 1, j + 1)\]</span> 又 <span class="math inline">\(y + 1 &lt; u + 1 \leq j &lt; j + 1\)</span>。 <span class="math display">\[w(y + 1, j) + w(u + 1, j + 1) \leq w(y + 1, j + 1) + w(u + 1, j)\]</span> 两式相加得到 <span class="math display">\[f_{i - 1, y} + w(y + 1, j) \leq f_{i - 1, u} + w(u + 1, j)\]</span></p><p>复杂度： <span class="math display">\[\sum_{i = 1}^{n} \sum_{j = 1}^m k_{i, j + 1} - k_{i - 1, j} = \sum_{i = 1}^n k_{i, m + 1} + \sum_{j = 1}^m  k_{n, j} &lt; 2 n m\]</span></p><p>例题：<a href="https://www.luogu.com.cn/problem/P4767">LOJ P4767</a></p><p>不难看出 <span class="math inline">\(w(k, j)\)</span> 表示在 <span class="math inline">\(k\)</span> 到 <span class="math inline">\(j\)</span> 个村庄建一个邮局使得总距离之和最小（那肯定是建在中位数位置）不难证明它满足四边形不等式（分奇偶很好证明）。首先把 w 给预处理出来。然后再转移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n, m;<br>  std::cin &gt;&gt; n &gt;&gt; m;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) std::cin &gt;&gt; a[i];<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">w</span>(n + <span class="hljs-number">1</span>, std::vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>)), <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, std::vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">2</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) w[i][i + <span class="hljs-number">1</span>] = a[i + <span class="hljs-number">1</span>] - a[i];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>; len &lt; n; ++len) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, j = len + <span class="hljs-number">1</span>; j &lt;= n; ++j, ++i) &#123;<br>      w[i][j] = w[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[j] - a[i];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> mf = f;<br>  <span class="hljs-comment">// mf[i - 1][j] \leq mf[i][j] \leq m[i][j + 1]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) f[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1e9</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    mf[i][n + <span class="hljs-number">1</span>] = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt; <span class="hljs-number">0</span>; --j) &#123;<br>      f[i][j] = INT_MAX;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = std::<span class="hljs-built_in">max</span>(i - <span class="hljs-number">1</span>, mf[i - <span class="hljs-number">1</span>][j]); k &lt; j &amp;&amp; k &lt;= mf[i][j + <span class="hljs-number">1</span>]; ++k) &#123;<br>        <span class="hljs-keyword">if</span> (f[i][j] &gt; f[i - <span class="hljs-number">1</span>][k] + w[k + <span class="hljs-number">1</span>][j]) &#123;<br>          f[i][j] = f[i - <span class="hljs-number">1</span>][k] + w[k + <span class="hljs-number">1</span>][j];<br>          mf[i][j] = k;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  std::cout &lt;&lt; f[m][n] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其它例题：<a href="https://codeforces.com/contest/321/problem/E">321E</a>。</p><h3 id="d1d-四边形-分治-dp-将-on2-复杂度优化成-on-log-n">1D1D 四边形 + 分治 DP 将 <span class="math inline">\(O(n^2)\)</span> 复杂度优化成 <span class="math inline">\(O(n \log n)\)</span></h3><p><span class="math display">\[f_r = \min_{l = 1}^{r - 1} f_l + w(l, r) \quad (1 \leq r \leq n)\]</span></p><p>若 <span class="math inline">\(w(l, r)\)</span> 满足四边形不等式，记 <span class="math inline">\(k_r\)</span> 为 <span class="math inline">\(f_r\)</span> 的最小最优决策点，则（反证法可证明） <span class="math display">\[\forall r_1 \leq r_2: \quad k_{r_1} \leq k_{r_2}\]</span></p><p>使用分治法优化 DP（递归实现）可以给出 <span class="math inline">\(O(n \log n)\)</span> 的做法。 &gt; 如果上述 <span class="math inline">\(w(l, r) = f(r) - g(l)\)</span>，并且 <span class="math inline">\(f, g\)</span> 单调递增，则我们可以使用斜率优化 DP，<span class="math inline">\(O(n)\)</span> 解决。本质是后面的决策单调性</p><h3 id="四边形不等式函数类">四边形不等式函数类</h3><ul><li><span class="math inline">\(w_1(l, r), w_2(l, r)\)</span> 均满足四边形不等式（或区间包含单调性），则 <span class="math inline">\(\forall c_1, c_2 \geq 0\)</span>，<span class="math inline">\(c_1 w_1 + c_2 w_2\)</span> 对应的也满足。</li><li>若存在函数 <span class="math inline">\(f, g\)</span> 使得 <span class="math inline">\(w(l, r) = f(r) - g(l)\)</span> 则函数 <span class="math inline">\(w\)</span> 满足四边形恒等式。若 <span class="math inline">\(f, g\)</span> 单调递增，则 <span class="math inline">\(w\)</span> 满足区间包含单调性。</li><li>若 <span class="math inline">\(h(x), h&#39;(x)\)</span> 都是单调递增的，若 <span class="math inline">\(w\)</span> 满足区间包含单调性和四边形不等式，则 <span class="math inline">\(h(w)\)</span> 也满足。</li><li><span class="math inline">\(h&#39;(x)\)</span> 单调递增，若 <span class="math inline">\(w\)</span> 满足区间包含单调性和四边形恒等式，则 <span class="math inline">\(h(w)\)</span> 满足四边形不等式。</li></ul><h3 id="决策单调性分治优化-dp">决策单调性分治优化 DP</h3><p>例题：<a href="https://codeforces.com/gym/101471/">2017 ACM-ICPC Word Final D: Money for Nothing</a></p><p><span class="math inline">\(L_i = (x_i, y_i) x_i &lt; x_{i + 1}, y_i &gt; y_{i + 1}\)</span> <span class="math inline">\(R_i = (p_i, q_i) p_i &lt; p_{i + 1}, q_i &gt; q_{i + 1}\)</span></p><p><span class="math inline">\(L_iR_j = (q_j - y_i)(p_j - x_i), \quad (x_i &lt; p_i, y_j &lt; p_j)\)</span> 即围成的面积。 即 <span class="math inline">\(u_i\)</span> 为 使得 <span class="math inline">\(L_iR_j\)</span> 最大的 <span class="math inline">\(j\)</span>（多个取下标最大的）。若 <span class="math inline">\(i &lt; j, k &lt; l\)</span>，画个图显然就有（有点四边形内味）</p><p><span class="math display">\[L_iR_l + L_jR_k \leq L_iR_k + L_jR_l\]</span></p><p>因此 <span class="math inline">\(u_i\)</span> 是单调递增的（因此这样就可以调整最优策略了，这也就给出了决策单调性）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n, m;<br>  std::cin &gt;&gt; n &gt;&gt; m;<br>  std::vector&lt;std::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n), <span class="hljs-built_in">b</span>(m);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[x, y] : a) std::cin &gt;&gt; x &gt;&gt; y;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[x, y] : b) std::cin &gt;&gt; x &gt;&gt; y;<br>  std::<span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (a[i].second &lt; a[cnt - <span class="hljs-number">1</span>].second) a[cnt++] = a[i];<br>  &#125;<br>  a.<span class="hljs-built_in">resize</span>(cnt);<br>  std::<span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>  cnt = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span> &amp;&amp; b[i].second &gt;= b[cnt - <span class="hljs-number">1</span>].second) --cnt;<br>    b[cnt++] = b[i];<br>  &#125;<br>  b.<span class="hljs-built_in">resize</span>(cnt);<br>  <span class="hljs-comment">// 确保了始终能找到最优策略</span><br>  b.<span class="hljs-built_in">insert</span>(b.<span class="hljs-built_in">begin</span>(), &#123;<span class="hljs-number">0</span>, INT_MAX&#125;);<br>  LL ans = <span class="hljs-number">0</span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; divideConquer = [&amp;](<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> opl, <span class="hljs-keyword">int</span> opr) &#123;<br>    <span class="hljs-comment">// 区间都是左闭右开的</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    LL rm = INT64_MIN;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 一开始必然满足 b[opl].second &gt; a[mid].second，因此 k 必然满足</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = opl; i &lt; opr &amp;&amp; b[i].second &gt; a[mid].second; ++i) &#123;<br>      LL tmp = <span class="hljs-built_in">LL</span>(b[i].second - a[mid].second) * (b[i].first - a[mid].first);<br>      <span class="hljs-keyword">if</span> (tmp &gt; rm) &#123;<br>        rm = tmp;<br>        k = i;<br>      &#125;<br>    &#125;<br>    ans = std::<span class="hljs-built_in">max</span>(ans, rm);<br>    <span class="hljs-built_in">divideConquer</span>(l, mid, opl, k + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// b[k].second &gt; a[mid].second &gt; ... &gt; a[r - 1].second，从而没有 k = -1 出现的可能</span><br>    <span class="hljs-built_in">divideConquer</span>(mid + <span class="hljs-number">1</span>, r, k, opr);<br>  &#125;;<br>  <span class="hljs-built_in">divideConquer</span>(<span class="hljs-number">0</span>, a.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>, b.<span class="hljs-built_in">size</span>());<br>  std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这题不指定左下角节点和右上角节点。那么我们可以让所有节点成为左下角，所有节点成为右上角，就又变成此问题了。如果更进一步，不要求左下角和右上角，只要是斜对角线即可。那么我们可以让所有横坐标取相反数，再算一遍即可（妙啊）。</p><p>如果求最小值我目前还不知道有什么好方法。</p><h3 id="仅有一个特殊元素分治优化">仅有一个特殊元素分治优化</h3><p>例题：<a href="https://codeforces.com/contest/1442/problem/D">1442D</a>，详见<a href="https://codeforces.com/blog/entry/84298">官方题解</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grossman 常数</title>
    <link href="/grossmanConstant/"/>
    <url>/grossmanConstant/</url>
    
    <content type="html"><![CDATA[<p>考虑由如下递推关系确定的实数数列 <span class="math inline">\(\lbrace A_n \rbrace\)</span>： <span class="math display">\[\begin{aligned}A_{n+2} = \frac{A_n}{1+A_{n+1}} \\A_0=1,\; A_1=x\end{aligned}\]</span> 可以证明，有且仅有一个 <span class="math inline">\(x=x_0\)</span> 使得 <span class="math inline">\(\lbrace A_n \rbrace\)</span> 收敛。这个 <span class="math inline">\(x_0 = 0.7373383...\)</span> 被称为 Grossman 常数。</p><span id="more"></span><p><a href="https://mathworld.wolfram.com/GrossmansConstant.html">Grossman 常数</a> 在 Wolfram 百科里面有讲，也在 Finch, S. R.《Mathematical Constants》又讲，但是都依赖于核心论文 <a href="1987_Article_MathematicalEntertainments.pdf">Janssen, A. J. E. M. and Tjaden, D. L. A. Solution to Problem 86-2. <em>Math. Intel.</em> <strong>9</strong>, 40-43, 1987.</a> 折腾终于下下来了。</p><blockquote><p>吐槽一下 Wolfram 百科提供的所有 Reference 链接没法访问。。。</p></blockquote><!-- more --><p>为了方便起见，我们记： <span class="math display">\[\begin{aligned}A_0(x) = \alpha &gt;0 ,\; A_1(x) = x \\A_{n+2}(x) = \frac{A_{n}(x)}{1+A_{n+1}(x)}\end{aligned}\]</span> 首先罗列一些显而易见的结果：</p><ul><li><p>如果 <span class="math inline">\(x&gt;0\)</span>，则 <span class="math inline">\(A_n(x)&gt;0\)</span>，且 <span class="math inline">\(A_{2n}(0)=\alpha,A_{2n+1}(0)=0\)</span></p></li><li><p><span class="math inline">\(a(x) = \lim A_{2n}(x),\; b(x)= \lim A_{2n+1}(x)\)</span> 均存在，且 <span class="math inline">\(a(x)b(x)=0\)</span></p></li><li><p>如果 <span class="math inline">\(\lim A_n(x)\)</span> 存在，则为 <span class="math inline">\(0\)</span></p></li><li><p>如果 <span class="math inline">\(x \leq 0\)</span>，则 <span class="math inline">\(\lim A_n(x)\)</span> 不存在 （反证，奇偶项写出两个递推关系分析）</p><p><strong>以下仅考虑 <span class="math inline">\(x\geq 0\)</span> 的情形</strong></p></li><li><p><span class="math inline">\(A_{2n}(x)\)</span> 是连续单调递减的函数 （数学归纳）</p></li><li><p><span class="math inline">\(A_{2n+1}(x)\)</span> 是连续单调递增的函数 （数学归纳）</p></li><li><p><span class="math inline">\(a(x) \geq 0\)</span> 单调递减，<span class="math inline">\(b(x) \geq 0\)</span> 单调递增</p></li><li><p><span class="math inline">\(A_{2n}(x),\;A_{2n+1}(x)\)</span> 都关于 <span class="math inline">\(n\)</span> 单调递减</p></li><li><p>重要公式（累和相加）： <span class="math display">\[\alpha - A_{2N+2}(x) =  \sum_{n=0} ^N A_{2n+1}(x) A_{2n+2}(x) \\x - A_{2N+3}(x) = \sum_{n=0} ^N A_{2n+3}(x) A_{2n+2}(x)\]</span></p></li></ul><blockquote><p>以上罗列的结果按顺序证明是容易的！</p></blockquote><h2 id="lim-a_nx-0-当且仅当-a_nx-关于-n-单调递减"><span class="math inline">\(\lim A_n(x) =0\)</span> 当且仅当 <span class="math inline">\(A_n(x)\)</span> 关于 <span class="math inline">\(n\)</span> 单调递减</h2><p><strong>Proof</strong>： 若 <span class="math inline">\(\lim A_n(x) =0\)</span> ，再由上面的 “重要公式” 易知： <span class="math display">\[A_{2N+2}(x) =  \sum_{n=N+1} ^ \infty A_{2n+1}(x) A_{2n+2}(x) \\A_{2N+3}(x) = \sum_{n=N+1} ^ \infty A_{2n+3}(x) A_{2n+2}(x)\]</span> 所以 <span class="math inline">\(A_{2N+2}&gt;A_{2N+3}\)</span> ，紧接着 <span class="math inline">\(A_{2N+1} = \sum_{n=N+1} ^ \infty A_{2n+1}A_{2n} &gt; A_{2N+2}\)</span>，所以 <span class="math inline">\(A_n(x)\)</span> 关于 <span class="math inline">\(n\)</span> 单调递减</p><blockquote><p>这也提供了一个求解 Grossman 常数的数值依据。</p></blockquote><h2 id="最多只有一个-x-使得-lim-a_nx-0">最多只有一个 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(\lim A_n(x) =0\)</span></h2><p><strong>Proof</strong>：若 <span class="math inline">\(\lim A_n(y) = \lim A_n(x) = 0,\; y&gt;x\)</span>，则： <span class="math display">\[\frac{A_{n+2}(y)}{A_{n+2}(x)} = \frac{A_{n}(y)}{A_{n}(x)} \frac{1+A_{n+1}(x)}{1+A_{n+1}(y)}\]</span> 从而 <span class="math display">\[\frac{A_{2n+2}(y)}{A_{2n+2}(x)} = \prod _{k=1} ^n \frac{1+A_{2k+1}(y)}{1+A_{2k+1}(x)} \\\frac{A_{2n+1}(y)}{A_{2n+1}(x)} = \frac{y}{x} \prod_{k=1} ^n \frac{1+A_{2k}(y)}{1+A_{2k}(x)}\]</span> 从而 <span class="math inline">\(\frac{A_{2n+2}(y)}{A_{2n+2}(x)}\)</span> 单调递减收敛于 <span class="math inline">\(L_1 \leq 1\)</span>，<span class="math inline">\(\frac{A_{2n+1}(y)}{A_{2n+1}(x)}\)</span> 单调递增收敛于 <span class="math inline">\(L_2&gt;1\)</span>。所以 <span class="math display">\[\lim \frac{A_{2n+2}(y)}{A_{2n+2}(x)} \frac{A_{2n+1}(x)}{A_{2n+1}(y)} = \frac{L_1}{L_2} &lt;1\]</span> 但是另一方面 <span class="math display">\[1 \geq \frac{A_{2n+2}(y)}{A_{2n+1}(y)} \geq \frac{A_{2n+3}(y)}{A_{2n+1}(y)} = \frac{1}{1+A_{2n+2}(y)} \to 1 \\1 \leq \frac{A_{2n+1}(x)}{A_{2n+2}(x)} \geq \frac{A_{2n+1}(x)}{A_{2n+3}(x)} = 1+A_{2n+2}(x) \to 1\]</span> 矛盾！</p><h2 id="dini-定理">Dini 定理</h2><p>为了证明的连贯性，先给出下面需要引用 <strong>Dini 定理</strong>（证明见陈纪修《数学分析》下册定理 10.2.7）</p><p>设函数序列 <span class="math inline">\(\{S_n(x)\}\)</span> 在闭区间 <span class="math inline">\([a,b]\)</span> 上（点态）收敛于 <span class="math inline">\(S(x)\)</span>，且满足：</p><ul><li><span class="math inline">\(S_n(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上连续</li><li><span class="math inline">\(\{S_n(x)\}\)</span> 关于 <span class="math inline">\(n\)</span> 单调</li></ul><p>则 <span class="math inline">\(\{S_n(x)\}\)</span> 在 <span class="math inline">\([a,b]\)</span> 一致收敛于 <span class="math inline">\(S(x)\)</span> 当且仅当 <span class="math inline">\(S(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上连续 （"<span class="math inline">\(\Rightarrow\)</span>"易证，"<span class="math inline">\(\Leftarrow\)</span>" 称作 Dini <strong>定理</strong>）</p><h2 id="存在唯一的-x-使得-lim-a_nx-0">存在唯一的 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(\lim A_{n}(x) = 0\)</span></h2><p>由“重要公式”知： <span class="math display">\[\alpha - a(x) = \sum_{n=0} ^{\infty} A_{2n+1}(x) A_{2n+2}(x) \\x - b(x) = \sum_{n=0} ^{\infty} A_{2n+3}(x) A_{2n+2}(x) \\\]</span> 从而 <span class="math inline">\(\alpha - a(x) &gt; x - b(x)\)</span>，所以 <span class="math inline">\(b(\alpha) &gt; 0\)</span>，从而 <span class="math inline">\(a(\alpha) = 0\)</span>，并且 <span class="math inline">\(a(0) = \alpha,\; b(0) = 0\)</span>。令 <span class="math display">\[x_0 = \sup \{ x \in [0, \alpha] \mid a(x) &gt;0 \} \\x_1 = \inf \{ x \in [0,\alpha] \mid b(x)&gt;0 \}\]</span> 显然 <span class="math inline">\(x_0 \leq x_1\)</span>， 若 <span class="math inline">\(x_0 &lt; x_1\)</span>，则 对任意 <span class="math inline">\(x_0 &lt; x &lt; x_1\)</span> 有，<span class="math inline">\(a(x) = b(x) = 0\)</span>，矛盾于收敛于 0 的 <span class="math inline">\(x\)</span> 最多只有一个，从而 <span class="math inline">\(x_0 = x_1\)</span>。</p><p>注意到 <span class="math inline">\(\frac{1}{1+\alpha} A_{2n+1}(x) A_{2n+2}(x) \leq A_{2n+3}(x) A_{2n+2}(x) \leq A_{2n+1}(x) A_{2n+2}(x)\)</span>，所以 <span class="math inline">\(a(x),b(x)\)</span> 在闭区间 <span class="math inline">\(D\)</span> 上有共同的一致收敛性，从而由 <strong>Dini 定理</strong> 知，<span class="math inline">\(a(x)\)</span> 在闭区间 <span class="math inline">\(D\)</span> 上连续当且仅当 <span class="math inline">\(b(x)\)</span> 在闭区间 <span class="math inline">\(D\)</span> 上连续。</p><blockquote><p>我们想要证明 $a(x),b(x) $ 在区间 <span class="math inline">\([0,\alpha]\)</span> 上连续，从而 <span class="math inline">\(a(x_0) = b(x_0) = 0\)</span>。</p></blockquote><p>当 <span class="math inline">\(x &lt; x_0\)</span> 时，<span class="math inline">\(b(x)=0\)</span>，当 <span class="math inline">\(x &gt; x_0\)</span> 时，<span class="math inline">\(a(x)=0\)</span>，所以 <span class="math inline">\(a(x),b(x)\)</span> 在 <span class="math inline">\([0,x_0) \cup (x_0, \alpha]\)</span> 上连续。</p><p>若 <span class="math inline">\(a(x_0) &gt;0\)</span>，则 <span class="math inline">\(b(x_0) = 0\)</span>，记 <span class="math inline">\(b_0 = \lim_{x \to x_0 ^{+}} b(x)\)</span>，若 <span class="math inline">\(b_0&gt;0\)</span>， 则 <span class="math display">\[A_{2k+2}(x) = \prod_{j=1} ^k \frac{1}{1+A_{2j-1}(x)} &lt; \frac{1}{(1+b_0)^k} \quad x \in (x_0, \alpha ] \\A_{2k+1}(x) = \prod_{j=1}^k \frac{1}{1+A_{2j}(x)} &lt; \frac{1}{(1+a(x_0))^k} \quad x \in [0,x_0]\]</span> 从而 <span class="math inline">\(a(x),b(x)\)</span> 在 <span class="math inline">\([0,\alpha]\)</span> 上一致收敛，矛盾，从而 <span class="math inline">\(b_0 = 0\)</span>，从而 <span class="math inline">\(b(x)\)</span> 连续，从而 <span class="math inline">\(a(x)\)</span> 连续，矛盾，从而 <span class="math inline">\(a(x_0) = 0\)</span>。同理 <span class="math inline">\(b(x_0) = 0\)</span>。所以 <span class="math inline">\(\lim A_n(x) = 0\)</span>。</p><h2 id="grossman-常数的推广">Grossman 常数的推广</h2><p>由上述过程可知，本质上，对每个给定的 <span class="math inline">\(A_0 \geq 0\)</span>, 都存在唯一的 <span class="math inline">\(0 \leq A_1 \leq A_0\)</span> ，使得 <span class="math inline">\(\lim A_n\)</span> 存在（且等于 0）。我们不妨 <span class="math inline">\(A_1 = F(A_0)\)</span>，其中 <span class="math inline">\(F: [0, +\infty] \to [0, \infty]\)</span>，满足 <span class="math inline">\(F(0)= 0\)</span>，若<span class="math inline">\(x&gt;0\)</span> 则，<span class="math inline">\(0&lt;F(x)&lt;x\)</span> ，假设 <span class="math inline">\(A_0 = \alpha\)</span>，则 <span class="math inline">\(A_1 = F(\alpha),\;A_2 = \frac{\alpha}{1+F(\alpha)}\)</span>，而 <span class="math inline">\((A_0, A_1) = (F(\alpha),\frac{\alpha}{1+F(\alpha)})\)</span> 必然能使得 <span class="math inline">\(\lim A_n = 0\)</span>， 所以 <span class="math inline">\(F(F(\alpha)) = \frac{\alpha}{1+F(\alpha)}\)</span>，写成 <span class="math display">\[x = (1+F(x))F(F(x))\]</span> 由于 <span class="math inline">\(a(x)\)</span> 关于 <span class="math inline">\(\alpha\)</span> 连续，所以 <span class="math inline">\(x_0(\alpha) = \sup \{ x \in [0, \alpha] \mid a(x) &gt;0 \}\)</span> 关于 <span class="math inline">\(\alpha\)</span> 连续，即上述 <span class="math inline">\(F(x)\)</span> 连续，若可导​，则 <span class="math inline">\(F(x)\)</span> 单调递增。</p><blockquote><p>上述形式最早由 Gabor Nyerges 给出（由于找不到文献，所以就自己推导了一下）</p></blockquote><p>按照上述观点，从而 Grossman 常数就是 <span class="math inline">\(F(1)\)</span>。</p><h2 id="grossman-常数的数值计算">Grossman 常数的数值计算</h2><p>由于 <span class="math inline">\(\lim A_n(x) =0\)</span> 当且仅当 <span class="math inline">\(A_n(x)\)</span> 关于 <span class="math inline">\(n\)</span> 单调递减 。令 <span class="math inline">\(n_0\)</span> 是最小的 <span class="math inline">\(n\)</span> 使得 <span class="math inline">\(A_{n+1}(x) &gt; A_n(x)\)</span>，则 <span class="math display">\[A_{n+3}(x) - A_{n+2}(x) = \frac{(A_{n+1} - A_n) + (A_{n+1}^2 - A_n A_{n+2}) }{(1+A_{n+2})(1+A_{n-1})} &gt; 0\]</span> 从而对任意 <span class="math inline">\(k \geq 0\)</span>，<span class="math inline">\(A_{n+2k+1} &gt; A_{n+2k}\)</span>。</p><p>若 <span class="math inline">\(n\)</span> 为偶数，则 <span class="math inline">\(b(x)&gt;a(x)\)</span>，从而 <span class="math inline">\(b(x) &gt; 0 = a(x)\)</span>，即 <span class="math inline">\(x&gt;x_0\)</span>。反之，若 <span class="math inline">\(n\)</span> 为奇数，则 <span class="math inline">\(x &lt; x_0\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bigercheck</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">double</span> m,<span class="hljs-keyword">int</span> step = <span class="hljs-number">10000</span>)</span></span>&#123;<br>  <span class="hljs-keyword">bool</span> ans=<span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">while</span>(--step&amp;&amp;x&gt;m)&#123;<br>    ans = !ans;<br>    <span class="hljs-keyword">double</span> t=x/(<span class="hljs-number">1</span>+m);<br>    x = m;<br>    m = t;<br>  &#125;<br>  <span class="hljs-keyword">return</span> x&gt;m||ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-12</span>)</span></span>&#123;<br>  <span class="hljs-keyword">double</span> l =x/(<span class="hljs-number">1</span>+x),r = x;<br>  <span class="hljs-keyword">while</span>(r-l&gt;eps)&#123;<br>    <span class="hljs-keyword">double</span> m = (l+r)*<span class="hljs-number">0.5</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bigercheck</span>(x,m))  r=m;<br>    <span class="hljs-keyword">else</span> l=m;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">double</span> x;<br>  <span class="hljs-keyword">while</span>(cin&gt;&gt;x)&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">F</span>(x)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">F</span>(<span class="hljs-built_in">F</span>(x))*(<span class="hljs-built_in">F</span>(x)+<span class="hljs-number">1</span>)-x&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>高精度太耗时了！参考 <a href="https://oeis.org/A085835">A085835</a></p></blockquote><h2 id="后来的故事">后来的故事</h2><p>Gabor Nyerges 在 2014 年的论文 《On the convergence of <span class="math inline">\(x_n = f(x_{n–2}, x_{n–1})\)</span> when <span class="math inline">\(f (x, y) &lt; x\)</span>. Advances in Difference Equations2014, 2014:8》中证明，只需 <span class="math inline">\(f: (0,\infty)^2 \to (0,\infty)\)</span>，<span class="math inline">\(f (x, y) &lt; x\)</span>，且<span class="math inline">\(f(x,y)\)</span> 关于 <span class="math inline">\(y\)</span> 递减，则对任意 <span class="math inline">\(x_0 &gt; 0\)</span>，存在 <span class="math inline">\(f(x_0,x_0)&lt;x_1&lt;x_0\)</span> 使得 <span class="math inline">\(x_n\)</span> 单调递减趋于 0 。但是没法保证唯一性，毕竟条件这么弱。证明过程巧妙的应用了闭区间套定理。</p><h3 id="明显的推论若-x_n-fracx_n-21fx_n-1其中-f-0infty-to-0-infty为单调递增的连续函数-则对任意-x-geq-0存在唯一的-fracx_01fx_0-leq-x_1-leq-x_0">明显的推论：若 <span class="math inline">\(x_n = \frac{x_{n-2}}{1+f(x_{n-1})}\)</span>，其中 <span class="math inline">\(f: (0,\infty) \to (0, \infty)\)</span>为单调递增的连续函数， 则，对任意 <span class="math inline">\(x \geq 0\)</span>，存在唯一的 <span class="math inline">\(\frac{x_0}{1+f(x_0)} \leq x_1 \leq x_0\)</span></h3><p><strong>Proof</strong> ：存在性由 Gabor Nyerges 的证明显然，唯一性模仿之前的过程显然。</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页工具</title>
    <link href="/webTools/"/>
    <url>/webTools/</url>
    
    <content type="html"><![CDATA[<h2 id="通用">通用</h2><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a>：google is your friends</li><li><a href="https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md">别像弱智一样提问</a>：不要做不劳而获的人，想想你的问题能给别人带来帮助吗</li><li><a href="https://www.wanweibaike.com/">万维百科</a></li><li><a href="https://en.jinzhao.wiki/wiki/Main_Page">Wiki 镜像</a></li></ul><h2 id="数学">数学</h2><ul><li><a href="https://www.mathpages.com/">MathPages</a></li><li><a href="https://stacks.math.columbia.edu/">代数几何的 Stack project</a></li><li><a href="https://projecteuler.net/">欧拉计划</a></li><li><a href="https://oeis.org/welcome">oeis.org: 数列百科全书</a></li><li><a href="http://www.sagemath.org/">sagemath</a></li><li><a href="https://cocalc.com/">sagemath 在线版</a></li><li><a href="http://www.wolframalpha.com/">Wolframalpha</a></li><li><a href="http://web2.0calc.com/">在线多功能计算器</a></li><li><a href="https://matlab.mathworks.com/">Matlab Online</a></li><li><a href="https://ww2.mathworks.cn/help">Matlab 官方文档</a></li><li><a href="http://detexify.kirelabs.org/classify.html">手写输入 Latex</a></li><li><a href="https://latexlive.com/">latex 公式编辑器</a></li><li><a href="https://www.desmos.com/calculator?lang=zh-CN">在线绘制函数图像</a></li><li><a href="http://weavesilk.com">分形绘图</a></li><li><a href="http://www.radicaleye.com/lifepage/lifepage.html">Game of Life</a></li><li><a href="https://zhuanlan.zhihu.com/p/36481400">Game of Life 知乎讲解</a></li><li><a href="https://bitstorm.org/gameoflife/">Game of Life 在线演示</a></li></ul><h2 id="算法竞赛相关">算法竞赛相关</h2><ul><li><a href="https://img.atcoder.jp/practice2/ac-library.zip">AtCoder 公用模板</a></li><li><a href="https://cp-algorithms.com/">CP-algorithm</a></li><li><a href="https://cp-wiki.vercel.app/">CP-Wiki</a></li><li><a href="https://oi-wiki.org/">OI-wiki</a></li><li><a href="https://vjudge.net/">vjudge</a></li><li><a href="https://uoj.ac/problems?search=%E6%B8%85%E5%8D%8E">UOJ 清华集训题</a></li></ul><h2 id="计算机">计算机</h2><ul><li><a href="https://devdocs.io/">devDocs</a></li><li><a href="https://akaedu.github.io/book/">Linux C 编程一站式学习</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html">Linux 工具快速教程</a></li><li><a href="https://wandbox.org/">wandbox 在线 IDE（推荐！）</a></li><li><a href="https://godbolt.org/z/Pjdc7bxbE">C++ 生成汇编</a></li><li><a href="https://quick-bench.com/">C++ benchmark</a></li><li><a href="https://www.ui.perfetto.dev/#!/">perfetto UI</a>：trace 性能分析可视化工具</li><li><a href="http://jyywiki.cn/">南京大学操作系统课</a>, jyy yyds</li><li><a href="http://courses.csail.mit.edu/6.851/spring12/lectures/">MIT 课程：Advanced Data Structures</a></li><li><a href="https://www.bilibili.com/video/BV1EW411u7th?p=1">计算机科学速成课</a></li><li><a href="http://cleancoder.com/products">Uncle Bob Martin: cleancoder</a></li><li><a href="https://regex101.com/">正则表达式快速验证</a></li><li><a href="https://explainshell.com/">shell 命令详解</a></li><li><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">非官方 Windows 版 Python 拓展包</a></li><li><a href="http://www.pythontutor.com/visualize.html#mode=edit">代码可视化</a></li><li><a href="http://visualgo.net/">算法可视化</a></li><li><a href="http://xuewei.world:8000/2020/03/30/高效使用github寻找开源项目/">Github 带关键词搜索方式</a></li><li><a href="https://paste.ubuntu.com/">paste ubuntu 贴公开代码</a></li><li><a href="https://readthedocs.org/">文档制作 Read the Docs</a></li><li><a href="https://github.com/GitbookIO/gitbook">gitbook 做学习文档</a></li><li><a href="https://gitmind.cn/">gitmind 在线思维导图</a></li></ul><h1 id="前端工具">前端工具</h1><ul><li><a href="https://xiaomark.com/">短链接</a></li><li><a href="http://tool.oschina.net/">前端工具</a></li><li><a href="http://www.qijishow.com/down/index.html">奇迹工具箱</a></li><li><a href="http://www.bewindoweb.com/dwg.php">各类工具链接</a></li><li><a href="http://clonezone.link/">在线修改任意网页的内容（做假冒网站）</a></li><li><a href="http://www.bejson.com/convert/html2markdown/">html 转成 markdown</a></li><li><a href="https://www.runoob.com/html/html-quicklist.html">html 速查</a></li><li><a href="https://www.bookstack.cn/">书栈网</a></li><li><a href="https://www.imgurl.org/vip/manage/upload">图床</a></li><li><a href="https://www.sioe.cn/yingyong/yanse-rgb-16/">颜色对应 16 进制</a></li><li><a href="https://98.js.org/">体验 Windows98</a></li><li><a href="https://windows93.net/">体验 Windows93</a></li><li><a href="https://www.logoly.pro/#/">Logo 制作</a></li><li><a href="http://www.makepic.com/">印章制作</a></li></ul><h2 id="生活">生活</h2><ul><li><a href="https://www.creditchina.gov.cn/home/?navPage=0">信用中国</a></li><li><a href="https://www.bangongziyuan.com/">办公资源</a></li><li><a href="http://www.pdfdo.com/pdf-split.aspx">pdf 在线处理</a></li><li><a href="https://cn.office-converter.com/">各类办公软件互转</a></li><li><a href="https://uzer.me/">云端超级应用空间: PS,Word,Excel,PPT,Matlab?</a></li><li><a href="https://extract.me/">各类文件解压</a></li><li><a href="https://aq-game.yy.com/">AQ 录制软件</a></li><li><a href="https://ipinfo.io/">ip 查询地理位置</a></li><li><a href="http://www.tineye.com/">类似图片 搜索</a></li><li><a href="http://chineseposters.net/">又红又专的图集</a></li><li><a href="http://wigflip.com/signbot/">在线生成液晶字幕</a></li><li><a href="http://www.freeroms.com/nes_roms_NUM.htm">黑白机 nes 游戏资源和素材</a></li><li><a href="https://www.fodey.com/generators/animated/ninjatext.asp">英文文本用小忍着的动画画出</a></li><li><a href="https://suulnnka.github.io/BullshitGenerator/index.html">狗屁不通文章生成器</a></li><li><a href="http://www.nows.fun/">毒鸡汤</a></li><li><a href="https://www.v2fy.com/p/000readme-chinesebqb/">表情包</a></li><li><a href="https://www.jiumodiary.com/">鸠摩搜书</a></li><li><a href="https://cxk.ssrr.one/">和 CXK 打篮球（游戏）</a></li><li><a href="http://www.midomi.com/">哼歌识曲</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中国剩余定理</title>
    <link href="/chineseRemainTheorem/"/>
    <url>/chineseRemainTheorem/</url>
    
    <content type="html"><![CDATA[<p>仅以此博文，感谢知乎好友 <a href="https://www.zhihu.com/people/li-yong-xiang-38">Vivr0</a></p><p>中国剩余定理也称孙子定理，是中国古代求解一次同余方程组的方法。</p><span id="more"></span><p>用现代的语言来说就是： <span class="math display">\[x \equiv\left\{\begin{array}{cc}a_1 \mod m_1 \\a_2 \mod m_2 \\\vdots \\a_n \mod m_n\end{array}\right.\]</span> 且正整数组 <span class="math inline">\(m_i\)</span> 两两互素，则对任意整数组 <span class="math inline">\(a_i\)</span>，上述方程有解，解可以写成 <span class="math inline">\(x \equiv a \mod m\)</span></p><p>我们不要求 <span class="math inline">\(m_i\)</span> 两两互素也能求解，只是不一定有解，下面详细给出做法。</p><p>我们先考虑 <span class="math inline">\(n=2\)</span> 的情形。即 <span class="math display">\[x \equiv\left\{\begin{array}{cc}a_1 \mod m_1 \\a_2 \mod m_2\end{array}\right.\]</span></p><p>我们可以把方程写成</p><p><span class="math display">\[\left\{\begin{array}{lll}x - a_1 &amp; \equiv \; 0  &amp; \mod m_1 \\x - a_1 &amp; \equiv \; a_2-a_1 &amp; \mod m_2\end{array}\right.\]</span></p><p>我们设 <span class="math inline">\(d = \gcd(m_1,m_2)\)</span>，则 <span class="math inline">\(d| x-a_1\)</span> 又 <span class="math inline">\(d|m_2\)</span>，所以 <span class="math inline">\(d|a_2-a_1\)</span>。</p><blockquote><p>我们知道对任意正整数 <span class="math inline">\(a,b\)</span>, 存在整数 <span class="math inline">\(x, y\)</span> 使得 <span class="math inline">\(xa + yb = \gcd(a,b)\)</span>。</p><p>(最后 Python 代码注释中有给出 <span class="math inline">\(x, y\)</span> 的详细操作)</p></blockquote><p>存在 <span class="math inline">\(t_1, t_2\)</span> 使得 <span class="math inline">\(m_1 t_1 + m_2 t_2 = gcd(m_1, m_2) = d\)</span>，所以 <span class="math display">\[x-a_1 \equiv \frac{a_2-a_1}{d} (m_1t_1 + m_2t_2) \equiv \frac{a_2-a_1}{d} t_1 m_1 \mod m_2\]</span> 即 <span class="math inline">\(x \equiv a \mod m\)</span>，其中 <span class="math inline">\(a= a_1 + \frac{a_2-a_1}{d} t_1m_1 = \frac{t_2m_2a_1+t_1m_1a_2}{d}\)</span>，<span class="math inline">\(m = lcm(m_1,m_2) = \frac{m_1m_2}{d}\)</span></p><blockquote><p><span class="math inline">\(n-1\)</span> 次上述操作，就处理了一般情况</p></blockquote><h2 id="c-代码">C++ 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-function">LL <span class="hljs-title">exgcd</span><span class="hljs-params">(LL a,LL b,LL&amp; x,LL&amp; y)</span></span>&#123;  <span class="hljs-comment">// ax + by = gcd(a,b)</span><br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> a;<br>    &#125;<br>    LL d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>    y-=a/b*x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function">pair&lt;LL,LL&gt; <span class="hljs-title">crt2</span><span class="hljs-params">(LL a1,LL m1,LL a2,LL m2)</span></span>&#123; <span class="hljs-comment">// x = ai mod mi, m_i &gt;0</span><br>    LL t1,t2,ans = a2-a1;<br>    LL d = <span class="hljs-built_in">exgcd</span>(m1,m2,t1,t2);<br>    <span class="hljs-built_in">assert</span>(ans%d == <span class="hljs-number">0</span>);<br>    LL m = m1/d*m2;<br>    ans = (a1+ans/d*t1%m2*m1)%m; <span class="hljs-comment">// %m2 是避免溢出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(ans&gt;<span class="hljs-number">0</span>?ans:ans+m,m);<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">22</span>;<br>LL a[N],m[N];<br><span class="hljs-function">pair&lt;LL,LL&gt; <span class="hljs-title">crt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123; <span class="hljs-comment">// x = a[i] mod m[i], m[i] &gt;0</span><br>    pair&lt;LL,LL&gt; ans = <span class="hljs-built_in">make_pair</span>(a[<span class="hljs-number">0</span>]%m[<span class="hljs-number">0</span>],m[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;<br>        ans = <span class="hljs-built_in">crt2</span>(ans.first,ans.second,a[i],m[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    LL a1,m1,a2,m2;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;a1&gt;&gt;m1&gt;&gt;a2&gt;&gt;m2)&#123;<br>        LL ans = <span class="hljs-built_in">crt2</span>(a1,m1,a2,m2).first;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>        <span class="hljs-keyword">if</span>((ans-a1)%m1 || (ans-a2)%m2)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;something wrong&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="python-代码">Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># input : a,b natural number</span><br><span class="hljs-comment"># output: [gcd(a,b), x, y]</span><br><span class="hljs-comment"># ax + by = gcd(a,b)</span><br><span class="hljs-comment"># Algorithm: b(a//bx+y) + a%bx = gcd(b,a%b)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exgcd</span>(<span class="hljs-params">a,b</span>):</span><br>  <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> [a,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>  [d,y,x] = exgcd(b,a%b)<br>  <span class="hljs-keyword">return</span> [d,x,y-a//b*x]<br><br><span class="hljs-comment"># input:  x = ai mod m_i, mi&gt;0, i=1,2</span><br><span class="hljs-comment"># output: x = a mod m</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crt2</span>(<span class="hljs-params">a1,m1,a2,m2</span>):</span><br>  [d,t1,t2] = exgcd(m1,m2)<br>  a,m = a2-a1,m1//d*m2<br>  <span class="hljs-keyword">if</span>(a%d):  <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;No solution to crt problem&#x27;</span>)<br>  <span class="hljs-keyword">return</span> [(a1+a//d*t1*m1)%m,m]<br><br><span class="hljs-comment"># input:  x = ai mod m_i, mi&gt;0</span><br><span class="hljs-comment"># output: x = a mod m</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crt</span>(<span class="hljs-params">a,m</span>):</span><br>  n = <span class="hljs-built_in">len</span>(a)<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(m)!=n):  <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;a and m must have equal length&#x27;</span>)<br>  aa,mm = a[<span class="hljs-number">0</span>],m[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>    [aa,mm] = crt2(aa,mm,a[i],m[i])<br>  <span class="hljs-keyword">return</span> [aa,mm]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>  [a,m]=crt([<span class="hljs-number">2</span>,-<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>])<br>  <span class="hljs-built_in">print</span>(a,m)<br>  [a,m]=crt([<span class="hljs-number">2</span>,-<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>])<br>  <span class="hljs-built_in">print</span>(a,m)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>cpp</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>$GL_n(\mathbb{Z}_m)$ 的阶数</title>
    <link href="/orderOfGLnZm/"/>
    <url>/orderOfGLnZm/</url>
    
    <content type="html"><![CDATA[<p>由线性无关性，我们不难知道 <span class="math inline">\(|GL_n(\mathbb{Z}_p)| = \prod_{i=0} ^{n-1} (p^n-p^i)\)</span>，但是 <span class="math inline">\(|GL_n(\mathbb{Z}_m)|\)</span> 却是一个相对复杂的问题，它本质上是在考虑有限 Abel 群的自同构群的阶数问题。它又跟递推数列模 <span class="math inline">\(m\)</span> 的周期密切相关。</p><span id="more"></span><p>2007 年 CHRISTOPHER J. HILLAR AND DARREN L. RHEA 发表一篇论文<a href="automorphismsOfFiniteAblianGroup.pdf">《AUTOMORPHISMS OF FINITE Abelian GROUPS》</a> 完美的解决了这个问题。</p><h2 id="有限生成-abel-群结构定理">有限生成 Abel 群结构定理</h2><p>设 <span class="math inline">\(G\)</span> 是一个有限 Abel 群，那么 <span class="math inline">\(G\)</span> 同构于一些 <span class="math display">\[H_p = \mathbb{Z}_{p^{e_1}} \times \cdots  \mathbb{Z}_{p^{e_n}}\]</span> 的乘积。其中 <span class="math inline">\(p\)</span> 是素数（<span class="math inline">\(p\)</span> 一般默认为素数），<span class="math inline">\(1 \leq e_1 \leq \cdots \leq e_n\)</span> 是正整数。</p><blockquote><p>证明可见任意一般抽象代数（或近世代数）书。</p></blockquote><h2 id="乘积的自同构">乘积的自同构</h2><p>若 <span class="math inline">\(H\)</span> 和 <span class="math inline">\(K\)</span> 是有限群，且它们的阶数互素。那么我们就有同构： <span class="math display">\[Aut(H) \times Aut(K) \simeq Aut(H \times K)\]</span> <strong>Proof</strong> ：我们构造很自然的映射： <span class="math display">\[\begin{aligned}\phi: Aut(H) \times Aut(K) \to Aut(H \times K) \\\phi(\alpha,\beta)(h,k) = (\alpha(h),\beta(k))\end{aligned}\]</span> 容易验证 <span class="math inline">\(\phi\)</span> 是合理的映射，并且是单射，然后我们同构构造它的逆映射来说明它是满射。</p><p>我们记 <span class="math inline">\(n = |H|,m = |K|\)</span>，<span class="math inline">\(\pi_H,\pi_K\)</span> 是标准投影映射： <span class="math inline">\(\pi_H: H \times K \to H\)</span>，<span class="math inline">\(\pi_K: H \times K \to K\)</span> 。对于给定的 <span class="math inline">\(\omega \in Aut(H \times K)\)</span>，我们定义同态 <span class="math inline">\(\gamma: K \to H\)</span>， <span class="math inline">\(\gamma(k) = \pi_H(\omega(1_H,k))\)</span>，注意到 <span class="math inline">\(\lbrace k^n: k \in K \rbrace \subseteq \ker \gamma\)</span>。又 <span class="math inline">\(m,n\)</span>是互素的，所以 <span class="math inline">\(\gamma\)</span> 是平凡的映射。同理，我们定义 <span class="math inline">\(\delta: H \to K\)</span>，<span class="math inline">\(\delta(h) = \pi_K(\omega(h,1_K))\)</span> 也是平凡映射。最后我们定义<span class="math inline">\(H\)</span>和<span class="math inline">\(K\)</span>的自同态： <span class="math display">\[\begin{aligned}\omega_H(h) = \pi_H(w(h,1_K)) ,\quad \omega(k) = \pi_K(w(1_H,k)) \\\omega(h,k) = \omega(h,1_K) \omega(1_H,k) = (\omega_H(h),  \omega_K(k)) = \phi(w_H,w_k)(h,k)\end{aligned}\]</span> 由于 <span class="math inline">\(\omega_H,\omega_K\)</span> 都是单射，并且 <span class="math inline">\(H,K\)</span> 是有限群，所以它们是自同构，证毕。</p><blockquote><p>所以我们考虑 <span class="math inline">\(Aut(G)\)</span>，只需考虑 <span class="math inline">\(Aut(H_p)\)</span> 即可</p></blockquote><h2 id="h_p-的自同态"><span class="math inline">\(H_p\)</span> 的自同态</h2><p>我们定义，环 <span class="math inline">\(E_p = End(H_p)\)</span>（加法就是映射的加法，乘法就是映射的复合）</p><p>由于循环群 <span class="math inline">\(C_{p^{e_i}}\)</span> 对应的是 模 <span class="math inline">\(p^{e_i}\)</span> 的加法群。所以 <span class="math inline">\(H_p\)</span> 中的元素可以表示成列向量 <span class="math inline">\((\overline{h_1},\cdots \overline{h_n})^T\)</span>，其中 <span class="math inline">\(\overline{h_i} \in \mathbb{Z}_{p^{e_i}}, \; h_i \in \mathbb{Z}\)</span></p><p>我们定义（<strong>精华所在</strong>) <span class="math display">\[R_p \doteq \lbrace (a_{ij} \in \mathbb{Z}^{n \times n}: p^{e_i - e_j}|a_{ij} \quad \forall 1 \leq j &lt; i \leq n)\]</span></p><p>注意到 <span class="math inline">\(\forall A \in R_p\)</span>，<span class="math inline">\(A = P A&#39; P^{-1}\)</span>，其中 <span class="math inline">\(P = diag(p^{e_1},\cdots,p^{e_n}), A&#39; \in \mathbb{Z}^{n \times n}\)</span>。从而 <span class="math inline">\(R_p\)</span> 根据加法和矩阵乘法，构成了一个环。</p><p>我们定义 <span class="math inline">\(\pi_i: \mathbb{Z} \to \mathbb{Z}_{p^{e_i}}\)</span> 为标准商映射。<span class="math inline">\(\pi: \mathbb{Z}^n \to H_p\)</span> 为： <span class="math display">\[\pi(h_1,\cdots h_n)^T = (\pi_1(h_1),\cdots,\pi_n(h_n))^T = (\overline{h_1},\cdots \overline{h_n})^T\]</span> 我们不难验证 <span class="math inline">\(\psi: R_p \to E_p\)</span> <span class="math display">\[\psi(A)(\overline{h_1},\cdots \overline{h_n})^T = \pi(A(h_1,\cdots,h_n)^T)\]</span> 是环满同态（需要验证映射合理性，环同态，满射）且 <span class="math inline">\(\ker \psi = \lbrace A = (a_{ij}) \in R_p: p^{e_i} | a_{ij}\)</span></p><h2 id="h_p-的自同构-auth_p"><span class="math inline">\(H_p\)</span> 的自同构 <span class="math inline">\(Aut(H_p)\)</span></h2><p><span class="math inline">\(M = \psi(A) \in Aut(H_p)\)</span> 当且仅当 <span class="math inline">\(A \mod p \in GL_n(\mathbb{F}_p)\)</span>，即 <span class="math inline">\(\det(A) \in U(H_p)\)</span> 是 <span class="math inline">\(H_p\)</span> 中可逆元。</p><p><strong>Proof</strong>：利用 <span class="math inline">\(A\)</span> 的逆矩阵推出 <span class="math inline">\(M\)</span> 是自同构，利用 <span class="math inline">\(M\)</span> 的逆映射给出 <span class="math inline">\(A\)</span> 的逆矩阵。</p><h2 id="auth_p"><span class="math inline">\(| Aut(H_p)|\)</span></h2><p>定义：<span class="math inline">\(d_k = \max \lbrace l: e_l = e_k \rbrace, c_k = \min \lbrace l: e_l = e_k \rbrace\)</span>，显然 <span class="math inline">\(c_k \leq k \leq d_k\)</span>。我们需要计算</p><ul><li>所有 <span class="math inline">\(GL_n(\mathbb{F}_p)\)</span> 中可以拓展成 <span class="math inline">\(A \in R_p\)</span> 的元素</li><li>每个元素拓展方式</li></ul><p>我们找到所有 <span class="math inline">\(M \in GL_n(\mathbb{F}_p)\)</span> 形如： <span class="math display">\[M =\begin{pmatrix}m_{11} &amp; &amp; &amp; \star \\\vdots \\m_{d_1 1} \\&amp; m_{d_2 2} \\&amp; &amp; \ddots \\0 &amp; &amp; &amp; m_{d_n n}\end{pmatrix}\]</span> &gt; 注意到 <span class="math inline">\(\sum_{j=1} ^n \sum_{i=1} ^{d_j} m_{ij} = \sum_{e_i \leq e_j} m_{ij} = \sum_{i=1} ^n \sum_{j = c_i}^n m_{ij}\)</span></p><p>因为我们只考虑线性无关的，所以这种 <span class="math inline">\(M\)</span> 的数量是 <span class="math display">\[\prod_{k=1} ^n (p^{d_k} - p^{k-1})\]</span> 将 <span class="math inline">\(m_{ij}\)</span> 从 <span class="math inline">\(\overline{m_{ij}} \in \mathbb{Z}_p\)</span> 到 <span class="math inline">\(\overline{a_{ij}} \in p^{e_i-e_j} \mathbb{Z}/p^{e_i} \mathbb{Z}\)</span> 使得 <span class="math inline">\(a_{ij} \equiv m_{ij} \mod p\)</span> 的方案数分两种情况</p><ul><li><span class="math inline">\(e_i &gt; e_j\)</span> 时， <span class="math inline">\(p^{e_j}\)</span> 种</li><li><span class="math inline">\(e_i \leq e_j\)</span> 时， <span class="math inline">\(p^{e_i-1}\)</span> 种</li></ul><p>从而 <span class="math display">\[|Aut(H_p)| = \prod_{k=1} ^n (p^{d_k} - p^{k-1}) \prod_{j=1} ^n (p^{e_j})^{n-d_j} \prod_{i=1} ^n (p^{e_i -1})^{n-c_i+1}\]</span></p><h2 id="gl_nmathbbz_m"><span class="math inline">\(|GL_n(\mathbb{Z}_m)|\)</span></h2><p>由 <span class="math inline">\(|Aut(H_p)|\)</span> 的公式的特殊形式，我们知道 <span class="math inline">\(|GL_n(Z_{p^s})| = p^{n^2 (s-1)} \prod_{k=1} ^n (p^n - p^{k-1})\)</span>。</p><p>将 <span class="math inline">\(m\)</span> 质因数分解 <span class="math inline">\(m = p_1^{s_1} \cdots p_r ^{s_r}, \quad p_1 &lt; \cdots &lt; p_r\)</span> <span class="math display">\[|GL_n(\mathbb{Z}_m)| =  \prod_{i=1} ^r |GL_n(Z_{p_i^{s_i}})|\]</span></p><h2 id="mathbbz_m-上n-阶给定可逆矩阵-a-的周期"><span class="math inline">\(\mathbb{Z}_m\)</span> 上<span class="math inline">\(n\)</span> 阶给定可逆矩阵 <span class="math inline">\(A\)</span> 的周期</h2><p>设 <span class="math inline">\(f(\lambda) = | \lambda I -A|\)</span>，<span class="math inline">\(A\)</span> 可逆等价于 <span class="math inline">\(\gcd(f(\lambda),\lambda) = 1\)</span>，由于 <span class="math inline">\(A^k\)</span> 都可以由 <span class="math inline">\(I,A,\cdots A^{n-1}\)</span>，线性表出，但是由于是在 <span class="math inline">\(\mod m\)</span> 的意义下，所以根据容斥原理，对任意 <span class="math inline">\(k \geq m^n\)</span> 时，必然存在 <span class="math inline">\(l &lt; k\)</span>，使得 <span class="math inline">\(A^k = A^l\)</span>。即 <span class="math inline">\(A\)</span> 的周期上限是 <span class="math inline">\(m^n\)</span>，并且周期是 <span class="math inline">\(|GL_n(\mathbb{Z}_m)|\)</span> 的一个真因子（<span class="math inline">\(n&gt;1\)</span>）。</p><p>显然若 <span class="math inline">\(A\)</span> 可对角化，那么 <span class="math inline">\(A\)</span> 的周期必然是 <span class="math inline">\(\phi(m)\)</span> 的一个因子！但是注意这里 <span class="math inline">\(A\)</span> 对称并不能推出 <span class="math inline">\(A\)</span> 可对角化。</p><h2 id="常系数递推数列模意义下的周期">常系数递推数列模意义下的周期</h2>给定初值，<span class="math inline">\(x_1,\cdots x_s\)</span>, 和递推关系：<span class="math inline">\(x_{n+s} = a_1 x_{n+s-1} + \cdots + a_s x_n, a_s \neq 0\)</span> 的数列 <span class="math inline">\({x_n}\)</span>可以表示成： $$<span class="math display">\[\begin{pmatrix}x_n \\x_{n-1} \\\vdots  \\x_{n-s+1}\end{pmatrix}\]</span>=<span class="math display">\[\begin{pmatrix}a_1 &amp; a_2 &amp;\cdots &amp; a_s \\1 &amp; 0 \\\vdots  &amp; &amp; &amp; 0\\0 &amp;\cdots &amp; 1&amp; 0\end{pmatrix}\]</span><span class="math display">\[\begin{pmatrix}x_{n-1} \\x_{n-2} \\\vdots  \\x_{n-s}\end{pmatrix}\]</span><p>$$</p><p>可以通过矩阵幂在 <span class="math inline">\(O(s^3 \log n)\)</span> 复杂度求出。</p><blockquote><p>当 <span class="math inline">\(s\)</span> 相对较大时，根据特征多项式将系数矩阵 <span class="math inline">\(A^n\)</span> 写成 <span class="math inline">\(I,A,\cdots A^{s-1}\)</span> 的线性组合，然后只考虑仅乘以第一行，就可以在 <span class="math inline">\(O(s^2\log n)\)</span> 复杂度求出</p></blockquote><p>我们考虑 数列 <span class="math inline">\(\lbrace x_n \mod m \rbrace\)</span> ，由容斥原理知，数列 <span class="math inline">\(\lbrace x_n \mod m \rbrace\)</span> 是周期数列，记它的最小正周期为 <span class="math inline">\(f(m)\)</span> ，则 <span class="math display">\[f(m) = lcm(f(p_1^{s_1}),\cdots f(p_r^{s_r}))\]</span> 只要 <span class="math inline">\(p_i \not| \; a_s\)</span>，则 <span class="math inline">\(f(p_i ^{s_i})\)</span> 是 <span class="math inline">\(|GL_n(\mathbb{Z}_{p_i^{s_i}})|\)</span> 的一个真因子（当 <span class="math inline">\(n&gt;1\)</span> 时，<span class="math inline">\(GL_n(\mathbb{Z}_{p_i^{s_i}})\)</span> 不是循环群）。</p><blockquote><p>精确的周期要具体问题具体分析。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特殊数列</title>
    <link href="/SpecialNumberSequences/"/>
    <url>/SpecialNumberSequences/</url>
    
    <content type="html"><![CDATA[<p>在知乎上看到一个有趣的问题: <a href="https://www.zhihu.com/question/383254359">如何证明这个数列无界？</a> 在此记录一下简单的做法，然后把这篇博客记录以后遇到的一些特殊数列。</p><span id="more"></span><p>证明：当 <span class="math inline">\(x\)</span> 是无理数时，<span class="math inline">\(f_n(x) = \sum_{i=1}^n (-1)^{\lfloor ix \rfloor}\)</span> 无界</p><blockquote><p><span class="math inline">\(\lfloor x \rfloor\)</span> 表示 <span class="math inline">\(x\)</span> 的整数部分， <span class="math inline">\(0 \leq \lbrace x \rbrace \doteq x- \lfloor x \rfloor&lt;1\)</span> 表示 <span class="math inline">\(x\)</span> 的小数部分</p><p>为了更顺畅的介绍这个数列，我们先来点前戏，不然插入的时候就不那么顺滑了 0.0 不要笑，我没有开车 0.0</p></blockquote><h2 id="连分数"><a href="ContinuedFractions.pdf">连分数</a></h2><blockquote><p>它和 Farey 序列，无理数的有理逼近，密切相关，还是由于求 Pell 方程的快速方法</p></blockquote><p>我们将一个整数序列 <span class="math inline">\(a_0,a_1, \cdots, a_n\)</span> 构成的分数叫做连分数，记作 <span class="math display">\[[a_0,a_1,\cdots, a_n] = a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \cdots}}\]</span> 其中 <span class="math inline">\(a_0\)</span> 是整数， <span class="math inline">\(a_i (i&gt;0)\)</span> 是正整数。</p><p>我们定义:</p><p><span class="math inline">\(p_0 = a_0,p_1 = a_1a_0 +1,p_n = a_np_{n-1} + p_{n-2} (n&gt;1)\)</span></p><p><span class="math inline">\(q_0 = 1,q_1 = a_1,q_n=a_nq_{n-1}+q_{n-2} (n&gt;1)\)</span></p><p>那么数学归纳法易证： <span class="math display">\[[a_0,a_1,\cdots, a_n] = \frac{p_n}{q_n} = x_0\]</span> 并且还有</p><ul><li><span class="math inline">\([a_0,a_1,\cdots, a_n] = [a_0,a_1,\cdots, a_{n-1} + \frac{1}{a_n}]\)</span></li><li><span class="math inline">\(p_{n+1}q_n - q_{n+1}p_n = (-1)^n\)</span></li><li>从而 <span class="math inline">\((p_n,p_{n+1}) = (q_n,q_{n+1}) = (p_n,q_n) = 1\)</span></li><li><span class="math inline">\(x_{n+2} - x_n = \frac{(-1)^n a_{n+2}}{q_n q_{n+2}}\)</span></li><li>从而 <span class="math inline">\(x_0 &lt; x_2&lt; x_4 &lt; \cdots &lt; x_5 &lt; x_3 &lt; x_1\)</span></li></ul><h3 id="对任意一个数-x-构造连分数">对任意一个数 <span class="math inline">\(x\)</span> 构造连分数</h3><ol start="0" type="1"><li>初始 <span class="math inline">\(i = 0\)</span></li><li><span class="math inline">\(a_i = \lfloor x \rfloor\)</span> 取 <span class="math inline">\(x\)</span> 的整数部分。</li><li><span class="math inline">\(x - a_i == 0\)</span> 结束</li><li>取 <span class="math inline">\(x = \frac{1}{x-a_i}\)</span></li><li>++<span class="math inline">\(i\)</span> 回到步骤 1</li></ol><p>从构造中，我们看出：<strong>连分数长度有限当且仅当 <span class="math inline">\(x\)</span> 是有理数</strong>，此时，最后一项得到的连分数就是 <span class="math inline">\(x\)</span>。</p><p>当 <span class="math inline">\(x\)</span> 是无理数时， <span class="math inline">\(x_{2n} &lt; x &lt; x_{2n+1}\)</span> ，又因为 <span class="math display">\[x_{2n+1} - x_{2n} = \frac{1}{q_{2n}q_{2n+1}} \leq  \frac{1}{2n(2n+1)}\]</span> 且 <span class="math inline">\(x_{2n}\)</span> 单调递增，<span class="math inline">\(x_{2n+1}\)</span> 单调递减。所以 <span class="math inline">\(\lim _{n \to \infty} x_n = x\)</span>。并且 <span class="math display">\[|x - \frac{p_n}{q_n} | &lt; \frac{1}{q_n ^2}\]</span></p><h3 id="补充定义">补充定义</h3><p><span class="math display">\[a_n&#39; \doteq a_n&#39;(x) \doteq [a_n, a_{n+1}, a_{n+2},\cdots]\]</span></p><p><span class="math display">\[p_{n+1}&#39; \doteq a_{n+1}&#39; p_n + p_{n-1} = \frac{p_{n+2}&#39;}{a_{n+2}&#39;} \\q_{n+1}&#39; \doteq a_{n+1}&#39; q_n + q_{n-1} = \frac{q_{n+2}&#39;}{a_{n+2}&#39;}\]</span></p><p>显然，<span class="math inline">\(x = \frac{p_n&#39;}{q_n&#39;} = \frac{p_n}{q_n} + \frac{(-1)^n}{q_n q_{n+1}&#39;}\)</span></p><h3 id="唯一分解">唯一分解</h3><p>对于任意给定 <span class="math inline">\(x = [a_0,a_1,\cdots,a_n,\cdots]\)</span>，对任意 <span class="math inline">\(N\)</span>，有如下唯一分解： <span class="math display">\[N = \sum c_i q_i  = \sum_{i=0} ^{m(N,x)} c_i(N,x)q_i(x)\]</span> 其中 <span class="math inline">\(0 \leq c_i \leq a_{i+1}, c_m(N,x) &gt;0\)</span> 且对任意 <span class="math inline">\(0 \leq j \leq m(N,x)\)</span>，<span class="math inline">\(\sum_{i=0} ^ j c_i q_i &lt; q_{j+1}\)</span> 。</p><h2 id="f_nx-_i1n--1ix-何时有界">$ f_n(x) = _{i=1}^n (-1)^{ix } $ 何时有界</h2><p>由于 $f_n(x+2) = f_n(x) $， 所以我们仅考虑 $x $ 时，<span class="math inline">\(i\frac{p}{2} \mod q\)</span> 跑遍 <span class="math inline">\([0,q-1]\)</span>，即 <span class="math display">\[  f_q = \sum_{i=1}^q (-1)^{ \lfloor \frac{2( i\frac{p}{2} \mod q)}{q} \rfloor} =\sum_{i=0} ^{q-1} (-1)^{\lfloor \frac{2i}{q} \rfloor} = \frac{q+1}{2} - \frac{q-1}{2} = 1  \]</span> 从而 <span class="math inline">\(f_{2q} = 2f_q = 2\)</span> 推出 <span class="math inline">\(f_n\)</span> 无界。</p><h2 id="对任意无理数-x我们证明-g_nx-f_n2x-无界从而-f_nx-无界">对任意无理数 <span class="math inline">\(x\)</span>，我们证明 <span class="math inline">\(g_n(x) = f_n(2x)\)</span> 无界，从而 <span class="math inline">\(f_n(x)\)</span> 无界</h2><blockquote><p>目前没理解论文中的做法，太繁琐了</p></blockquote><p>显然，我们只需考虑 <span class="math inline">\(0&lt; x &lt;1\)</span></p><p>我们考虑 <span class="math inline">\(x\)</span> 的连分数 <span class="math inline">\([0,a_1,a_2,\cdots,a_n,\cdots]\)</span>，由于 <span class="math inline">\((p_n,q_n)=(q_n,q_{n+1})=1\)</span> (目前不知道有什么简单的操作)</p><p>这个问题可以推广到更一般的情形：<a href="1.pdf">单栏阅读</a> <a href="2.pdf">双栏阅读</a></p><blockquote><p>里面定理一挺有意思的，虽然长但是很清晰。</p></blockquote><h2 id="另一个相关问题httpswww.zhihu.comquestion392014769">另一个相关问题：<a href="https://www.zhihu.com/question/392014769" class="uri">https://www.zhihu.com/question/392014769</a></h2><p>是否存在 <span class="math inline">\(N\)</span> 使得， <span class="math inline">\(|\sin n|&gt;\frac{1}{n}\)</span> 对所有 <span class="math inline">\(n&gt;N\)</span> 成立。(<a href="https://www.zhihu.com/people/izlyforever">izlyforever</a> 和 <a href="https://www.zhihu.com/people/zhai-sen-8">寨森 Lambda-CDM</a> 建议修改)</p><h3 id="存在无穷多个正整数-x_n-使得-sin-x_n-frac2-pix_n">存在无穷多个正整数 <span class="math inline">\(x_n\)</span> 使得 <span class="math inline">\(|\sin x_n| &lt; \frac{2 \pi}{x_n}\)</span></h3><p>引理： 对任意无理数 <span class="math inline">\(a\)</span> , 存在无穷多个 <span class="math inline">\(x_n\)</span>，使得 <span class="math inline">\(\min(\{a x_n\},\{-a x_n\}) &lt; \frac{2}{x_n}\)</span></p><p>我们考虑 <span class="math inline">\(a\)</span> 的连分数 <span class="math inline">\([a_0,a_1,\cdots,a_n,\cdots]\)</span>, 我们知道 <span class="math inline">\(|a - \frac{p_n}{q_n} | &lt; \frac{1}{q_n ^2}\)</span>，由于 <span class="math inline">\((p_n,q_n) = 1\)</span>, 所以存在 <span class="math inline">\(u_n,v_n\)</span> 使得 <span class="math inline">\(p_n u_n + q_n v_n = 1\)</span>, 此时 <span class="math inline">\(p_n(u_n+tq_n) + q_n(v_n - tp_n) = 1\)</span>，所以我们不妨假设 <span class="math inline">\(q_n &lt; u_n &lt; 2q_n\)</span>。所以 <span class="math display">\[\{ a u_n \} = \{ (a-\frac{p_n}{q_n})u_n + \frac{p_n}{q_n}u_n \}  = \{ (a-\frac{p_n}{q_n})u_n + \frac{1}{q_n} \}\]</span> 我们仅考虑 <span class="math inline">\(n\)</span> 为奇数数的情况，此时 <span class="math inline">\(-\frac{1}{q_n^2} &lt; a - \frac{p_n}{q_n} &lt; 0\)</span>，所以 <span class="math inline">\(-\frac{1}{q_n} &lt;(a-\frac{p_n}{q_n})u_n + \frac{1}{q_n} &lt;\frac{1}{q_n}\)</span>。而 <span class="math inline">\(x_n = u_{2n+1} &gt; q_{2n+1}\)</span> 即为所求。</p><blockquote><p>实际上 <span class="math inline">\(n\)</span> 为偶数时，也可以取做，只是此时 <span class="math inline">\(u_n\)</span> 要换成 <span class="math inline">\(3q_n - u_n\)</span></p></blockquote><p>取引理中 <span class="math inline">\(a = \frac{1}{\pi}\)</span>，由于 <span class="math inline">\(|\sin(x)|\)</span> 是周期为 <span class="math inline">\(\pi\)</span> 的偶函数。所以 <span class="math inline">\(|\sin(x_n)| = |\sin(\{ax_n\}\pi)| = |\sin(\{-ax_n\}\pi)| &lt; \frac{2\pi}{x_n}\)</span></p><p>受 <a href="https://www.zhihu.com/people/zhai-sen-8">寨森 Lambda-CDM</a> 启发，可以不用引理直接证明：</p><h3 id="存在无穷多个正整数-m使得-sin-m-fracpim">存在无穷多个正整数 <span class="math inline">\(m\)</span>，使得 <span class="math inline">\(|\sin m| &lt; \frac{\pi}{m}\)</span></h3><p>Proof：考虑 <span class="math inline">\(\frac{1}{\pi}\)</span> 的连分数 <span class="math inline">\([a_0,a_1,\cdots,a_n,\cdots]\)</span>，我们有 <span class="math inline">\(|\frac{1}{\pi} - \frac{p_n}{q_n} | &lt; \frac{1}{q_n ^2}\)</span>，所以 <span class="math display">\[|\sin q_n| = |\sin[(\frac{q_n}{\pi} -p_n) \pi + p_n\pi ]|  =  |\sin[(|\frac{q_n}{\pi} -p_n|) \pi]| &lt; \frac{\pi}{q_n}\]</span></p><p>这个问题还关联这 <a href="https://mathworld.wolfram.com/IrrationalityMeasure.html">Irrationality Measure</a>，菲尔兹奖级别的工作！</p><h3 id="irrationality-measure"><a href="https://mathworld.wolfram.com/IrrationalityMeasure.html">Irrationality Measure</a></h3><p>对于给定是实数 <span class="math inline">\(x\)</span>, 定义 <span class="math display">\[\begin{aligned}\mu(x) \doteq \inf_{u \in R} u \\R = \{ u\mid \exists \text{ infty } (p,q)\; s.t.\quad 0&lt; |x -\frac{p}{q}| &lt; \frac{1}{q^u} \}\end{aligned}\]</span> 显然考虑连分数，我们知道 当 <span class="math inline">\(x\)</span> 是有理数时，<span class="math inline">\(u(x) = 1\)</span>，无理数时，<span class="math inline">\(\mu(x) \geq 2\)</span>。</p><p>Roth 证明，当 <span class="math inline">\(x\)</span> 是代数数时 <span class="math inline">\(\mu(x) = 2\)</span>，因此获得 Field 奖。</p><p><span class="math inline">\(\mu(L) = \infty\)</span>，其中 <span class="math inline">\(L = \sum_{n=1} ^{\infty} 10^{-n!}\)</span> 为刘维尔（Joseph Liouville）数</p><p>我们下面证明：当 <span class="math inline">\(u&gt;2\)</span> 时，<span class="math inline">\(A = \{ x \mid 0&lt; |x -\frac{p}{q}| &lt; \frac{1}{q^u}\}\)</span>，则 <span class="math inline">\(A\)</span> 的外（lebesgue）测度 <span class="math inline">\(m^{\star}(A) = 0\)</span>，从而（lebesgue）测度 <span class="math inline">\(m(A)=0\)</span></p><p>由于 当 <span class="math inline">\(1 \leq p \leq q\)</span> 时， <span class="math inline">\((\frac{p}{q} - \frac{1}{q^u}, \frac{p}{q} + \frac{1}{q^u})\)</span> 只有可数个，记作 <span class="math inline">\(I_1, I_2,\cdots I_n,\cdots\)</span> ，按照定义，<span class="math inline">\(A \cap (0,1) \subseteq \overline\lim I_n\)</span>, 另一方面 <span class="math inline">\(\sum_{i=1}^{\infty} I_n = \sum_{q=1}^{\infty} \frac{q+1}{q^u} &lt; +\infty\)</span>，从而 <span class="math inline">\(m^{\star}(A \cup (0,1)) = 0\)</span>，同理可证了<span class="math inline">\(m^{\star}(A \cup (n,n+1))=0, n \in \mathbb{Z}\)</span>，从而 <span class="math display">\[0 \leq m^{\star}(A) \leq \sum_{n \in \mathbb{Z}} m^{\star}(A \cup (n,n+1)) =0\]</span> 从而<span class="math inline">\(m^{\star}(A) = m(A) = 0\)</span>。其中 <span class="math inline">\(m^{\star}(I) = \inf \{u|u=\sum_{k=1}^{\infty} |I_k|,\; \cup_{k=1}^ {\infty} I_k \supset m ,I_k \text{ 是开矩形 } \}\)</span></p><h2 id="sagemath-数值测试jupyter-notebook-上运行">sagemath 数值测试(Jupyter Notebook 上运行)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">x = continued_fraction(<span class="hljs-number">1</span>/pi).convergents()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>):<br>    n = x[i].denominator()<br>    <span class="hljs-built_in">print</span>(N(<span class="hljs-built_in">abs</span>(sin(n))-pi/n),<span class="hljs-string">&quot;\t= &quot;</span>,<span class="hljs-built_in">abs</span>(sin(n))-pi/n ) <span class="hljs-comment"># 后来精度就崩了</span><br><br>x = continued_fraction(<span class="hljs-number">1</span>/pi).convergents()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>):<br>    n = x[i].denominator()<br>    <span class="hljs-built_in">print</span>(i,N(<span class="hljs-built_in">abs</span>(sin(n))*n),<span class="hljs-string">&quot;\t= &quot;</span>,<span class="hljs-built_in">abs</span>(sin(n))*n) <span class="hljs-comment"># 后来精度就崩了</span><br></code></pre></td></tr></table></figure><h3 id="sum_s-in-s-frac1s2-1-其中-s-am-a-1-m1-am-in-mathbbn"><span class="math inline">\(1 = \sum_{s \in S} \frac{1}{s^2-1}\)</span>, 其中 <span class="math inline">\(S = \{a^m | a &gt; 1, m&gt;1, a,m \in \mathbb{N} \}\)</span></h3><blockquote><p>方法：<a href="https://link.zhihu.com/?target=https%3A//www.maa.org/sites/default/files/pdf/upload_library/22/Ford/bibiloni206.pdf">On a Series of Goldbach and Euler</a></p></blockquote><p><span class="math display">\[\begin{aligned}\lim S(n) &amp;= \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m -1} \\&amp;=  \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m} + \sum_{a \in A} \sum_{m\geq 2} \frac{1}{a^m(a^m -1)} \\&amp; =  \sum_{a \in A} \frac{1}{a(a-1)} +   \sum_{b \in B} \frac{1}{b(b -1)} \\&amp; = \sum_{i=2}^n \frac{1}{n(n-1)} = 1\end{aligned}\]</span></p><p>其中 <span class="math inline">\(B = \{n \in \mathbb{N} \mid n = k^m , k&gt;1 \}\)</span>，<span class="math inline">\(A= \{n \in \mathbb{N} \mid n &gt;1 \} - B\)</span></p><h2 id="fnm-sum_i0i-leq-n-im-c_n-imi"><span class="math inline">\(f(n,m) = \sum_{i=0}^{i \leq n-im} C_{n-im}^i\)</span></h2><blockquote><p>洛谷题目，具体题号就不便说了。</p></blockquote><p>数据范围 <span class="math inline">\(1 \leq n \leq 10^{18} , m \leq 100\)</span> 。我们注意考察 <span class="math inline">\(f(n,m)\)</span> 的意义！假设我们要上楼梯，每次只能上 1 步或者 <span class="math inline">\(m+1\)</span> 步，那么 <span class="math inline">\(f(n,m)\)</span> 就是方案数，因此，我们显然有</p><p><span class="math display">\[f(n,m) = f(n-1,m)+f(n-m-1,m)\]</span></p><p>当然了我们不考虑意义直接用 <span class="math inline">\(f(n,m)-f(n-1,m)\)</span> 也可以得到这个公式。</p><h3 id="无法过题的-om-log-m-log-n-代码原因是没法找一个合适的基底">无法过题的 <span class="math inline">\(O(m \log m \log n)\)</span> 代码，原因是没法找一个合适的基底</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL=<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">using</span> BI=__int128;<br><span class="hljs-keyword">const</span> LL mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M =<span class="hljs-number">10004</span>;<br>BI a[<span class="hljs-number">4</span>*M],r[<span class="hljs-number">4</span>*M],ans[<span class="hljs-number">2</span>*M];<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">T <span class="hljs-title">powmod</span><span class="hljs-params">(T x,U n,T p)</span></span>&#123;<br>  <span class="hljs-function">T <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-keyword">while</span>(n)&#123;<br>    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) r=r*x%p;<br>    n&gt;&gt;=<span class="hljs-number">1</span>;  x=x*x%p;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bitreverse</span><span class="hljs-params">(BI *x,<span class="hljs-keyword">int</span> len)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i!=len;++i)&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;j) <span class="hljs-built_in">swap</span>(x[i],x[j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=len&gt;&gt;<span class="hljs-number">1</span>;(j^=l)&lt;l;l&gt;&gt;=<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> BI FM = <span class="hljs-built_in">BI</span>(<span class="hljs-number">29</span>)&lt;&lt;<span class="hljs-number">57</span>|<span class="hljs-number">1</span>,gg=<span class="hljs-number">3</span>;<br><span class="hljs-comment">// the mod must NTT-friendly or (len+1)*mod^2 &lt; FM</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ntt</span><span class="hljs-params">(BI *x,<span class="hljs-keyword">int</span> len,<span class="hljs-keyword">bool</span> isInverse=<span class="hljs-literal">false</span>)</span></span>&#123;<br>  g = <span class="hljs-built_in">powmod</span>(gg,(FM<span class="hljs-number">-1</span>)/len,FM);<br>  <span class="hljs-keyword">if</span>(isInverse)&#123;<br>    g=<span class="hljs-built_in">powmod</span>(g,len<span class="hljs-number">-1</span>,FM);<br>    BI invlen = <span class="hljs-built_in">powmod</span>(<span class="hljs-built_in">BI</span>(len),FM<span class="hljs-number">-2</span>,FM);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i!=len;++i)&#123;<br>      x[i]=x[i]*invlen%FM;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">bitreverse</span>(x,len);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> half=<span class="hljs-number">1</span>,step=<span class="hljs-number">2</span>;half!=len;half&lt;&lt;=<span class="hljs-number">1</span>,step&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>    BI wn = <span class="hljs-built_in">powmod</span>(g,len/step,FM);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i+=step)&#123;<br>      <span class="hljs-function">BI <span class="hljs-title">w</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j&lt;i+half;++j)&#123;<br>        BI t=(w*x[j+half])%FM;<br>        x[j+half]=(FM-t+x[j])%FM;<br>        x[j]=(x[j]+t)%FM;<br>        w = w*wn%FM;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stand</span><span class="hljs-params">(BI *a, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>*n;i&gt;n;--i)&#123;<br>    a[i<span class="hljs-number">-1</span>]=(a[i<span class="hljs-number">-1</span>]+a[i])%mod;<br>    a[i-n<span class="hljs-number">-1</span>]=(a[i-n<span class="hljs-number">-1</span>]+a[i])%mod;<br>    a[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">square</span><span class="hljs-params">(BI *a, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-number">32</span>-__builtin_clz(<span class="hljs-number">2</span>*n+<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">ntt</span>(a,len);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;<br>    a[i]=a[i]*a[i]%FM;<br>  &#125;<br>  <span class="hljs-built_in">ntt</span>(a,len,<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">stand</span>(a,n);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(BI *a,BI *b,<span class="hljs-keyword">int</span> na,<span class="hljs-keyword">int</span> nb)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-number">32</span>-__builtin_clz((na+nb)+<span class="hljs-number">1</span>));<br>  <span class="hljs-built_in">ntt</span>(a,len);<span class="hljs-built_in">ntt</span>(b,len);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;<br>    a[i] = a[i]*b[i]%FM;<br>  &#125;<br>  <span class="hljs-built_in">ntt</span>(b,len,<span class="hljs-number">1</span>);<span class="hljs-built_in">ntt</span>(a,len,<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">stand</span>(a,na);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initC</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i)&#123;<br>    ans[i] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=m+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*m;++i)&#123;<br>    ans[i] = (ans[i<span class="hljs-number">-1</span>]+ans[i-m<span class="hljs-number">-1</span>])%mod;<br>  &#125;<br>  <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br>  <span class="hljs-built_in">memset</span>(r,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(r));<br>  r[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">getans</span><span class="hljs-params">(LL n,<span class="hljs-keyword">int</span> m)</span></span>&#123;<br>  <span class="hljs-built_in">initC</span>(m);<br>  <span class="hljs-keyword">while</span>(n)&#123;<br>    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">mul</span>(r,a,m,m);<br>    n&gt;&gt;=<span class="hljs-number">1</span>; <span class="hljs-built_in">square</span>(a,m);<br>  &#125;<br>  LL ret = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i)&#123;<br>    ret+=(r[i]*ans[i+m])%mod;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret%mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  <span class="hljs-comment">//freopen(&quot;m&quot;,&quot;w&quot;,stdout);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  LL n;<br>  <span class="hljs-keyword">int</span> m;<br>  <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;<br>    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)&#123;<br>      cout&lt;&lt;<span class="hljs-built_in">powmod</span>(<span class="hljs-number">2LL</span>,n,mod)&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">if</span>(n&lt;=m)&#123;<br>        cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">getans</span>(n-m,m)&lt;&lt;endl;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求-m-阶线性递推关系式第-n-项">求 <span class="math inline">\(m\)</span> 阶线性递推关系式第 <span class="math inline">\(n\)</span> 项</h2><blockquote><p>参考：<a href="https://wenku.baidu.com/view/bac23be1c8d376eeafaa3111.html">2013/03/02 线性递推关系和矩阵乘法</a></p><p><strong>上面文献的意义</strong>：矩阵加速已经成为过去式了，多项式加速时代的到来，NTT 加速多项式的时代到来。</p></blockquote><p>设 <span class="math inline">\(a_n = c_{m-1} a_{n-1} + c_{m-2} a_{n-2} + c_0 a_{n-m}\)</span>，给定了初值 <span class="math inline">\(a_1,a_2,\cdots,a_m\)</span> 的情况下，求 <span class="math inline">\(a_n\)</span></p><p>我们记 <span class="math display">\[A = \begin{pmatrix}c_1 &amp; c_2 &amp;\cdots&amp; c_m \\1 &amp; 0&amp;  &amp; 0 \\&amp; &amp;\vdots&amp;  \\0 &amp; \cdots &amp;1 &amp; 0\end{pmatrix}\]</span> 并且显然 <span class="math display">\[\begin{pmatrix}a_n \\a_{n-1} \\\vdots \\a_{n-m+1}\end{pmatrix} =A\begin{pmatrix}a_{n-1} \\a_{n-2} \\\vdots \\a_{n-m}\end{pmatrix}  =A^{n-m}\begin{pmatrix}a_{m} \\a_{m-1} \\\vdots \\a_{1}\end{pmatrix}\]</span> 我们就可以用矩阵乘法在 <span class="math inline">\(O(m^3 \log n)\)</span> 解决这个问题了。</p><p><strong>但线性递推关系式可以不用矩阵优化到</strong> <span class="math inline">\(O(m^2 \log n)\)</span> ：</p><p>显然 <span class="math inline">\(A\)</span> 的特征多项式 <span class="math inline">\(f(x) = x^m - c_1 x^{m-1}- \cdots -c_m\)</span>，所以 <span class="math inline">\(A^n = c_{m-1} A^{n-1} + \cdots c_0 I\)</span>，也就是说 <span class="math inline">\(A^n\)</span> 可以由 <span class="math inline">\(A^{m-1},A^{m-2},\cdots,I\)</span> 线性表出，而 <span class="math inline">\(A^{n_1+n_2} = A^{n1} A^{n_2}\)</span> 然后运算就是卷积运算，相当于多项式乘法！也就是说我们可以在 <span class="math inline">\(O(m^2 \log n)\)</span> 时间复杂度，求出 <span class="math inline">\(A^n = b_0 I + b_1 A + \cdots b_{m-1} A^{m-1}\)</span>, 注意到 <span class="math display">\[A^i \begin{pmatrix}a_{m} \\a_{m-1} \\\vdots \\a_{1}\end{pmatrix} =\begin{pmatrix}a_{i+m} \\a_{i+m-1} \\\vdots \\a_{i+1}\end{pmatrix}\]</span> 所以我们只需预处理出 <span class="math inline">\(a_1,\cdots,a_{2m-1}\)</span> 这 <span class="math inline">\(2m-1\)</span> 个数即可。 <a href="../templateCpp">代码见我博客的模板</a></p><blockquote><p>这也提供了一般 <span class="math inline">\(m\)</span> 阶矩阵的 <span class="math inline">\(n\)</span> 次方的一个 <span class="math inline">\(O(m^3+m^2\log n)\)</span> 的算法！！！卧槽！我也太帅了吧。</p></blockquote><p><del>最后如果递推关系中仅有常数个 <span class="math inline">\(c_i\)</span> 不为 0，此时还能用 NTT（数论快速变换）</del> 利用 <a href="https://cp-algorithms.com/algebra/polynomial.html">多项式带模除法: Division with remainder</a> 的 <span class="math inline">\(O(m \log m)\)</span> 算法，上述算法可以优化到 <span class="math inline">\(O(m\log m \log n + m^2)\)</span>，（暂时不知道如何去掉 <span class="math inline">\(m^2\)</span>）但是写法太复杂。搞定！参考 <a href="https://oi-wiki.org/math/linear-recurrence/">这里</a>，不要涉及矩阵</p><p>注意到一次乘法之后，会变成 <span class="math inline">\(I,A,\cdots A^{2m-1}\)</span> 的线性组合，<span class="math inline">\(A^{m},\cdots A^{2m-1}\)</span> 这 <span class="math inline">\(m\)</span> 个要再用前 <span class="math inline">\(m\)</span> 线性表出，由于 <span class="math inline">\(c_i\)</span> 仅有常数个不为 0，可以 <span class="math inline">\(O(m)\)</span> 复杂度把他们写成前 <span class="math inline">\(m\)</span> 个的线性组合。</p><blockquote><p>当 <span class="math inline">\(m&gt;10^4\)</span> 时，我们就有必要写带 NTT 的版本了（NTT 模板可以在我博客中找到）有需求的时候再写吧。</p></blockquote><h2 id="sum_i-equiv-r-mod-m-binomni-mod-m"><span class="math inline">\(\sum_{i \equiv r \mod m} \binom{n}{i} \mod M\)</span></h2><p>数据范围：<span class="math inline">\(1 \leq n \leq 10^{18},\; 2 \leq m \leq 2000,\; 0 \leq r &lt; m,\; 10^8 &lt; M &lt; 10^9\)</span></p><p>记 <span class="math inline">\(w\)</span> 满足 <span class="math inline">\(w^m = 1,w^n \neq 1, 0 &lt; n &lt; m\)</span>，则答案为 <span class="math inline">\(\frac{1}{m}\sum_{i=0}^{m-1}F(w^i)\)</span>，其中 <span class="math inline">\(F(x) = x^{m-r}(1+x)^n \mod x^{m}-1\)</span></p><p>假设 <span class="math inline">\(F(x) = \sum_{i=0}^{m-1} a_i x^i\)</span>，则答案就是 <span class="math inline">\(a_0\)</span>，即答案是 <span class="math inline">\(F(0)\)</span></p><p>这个跟上面一样本质是一样的，做带模的多项式运算。</p><blockquote><p>参考：<a href="https://codeforces.ml/blog/zscoder">zscoder 的博客</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poly</span>&#123;</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">2003</span>;<br>  <span class="hljs-keyword">int</span> d;<br>  LL a[N];<br>  <span class="hljs-built_in">Poly</span>(<span class="hljs-keyword">int</span> _d):<span class="hljs-built_in">d</span>(_d)&#123;<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br>  &#125;<br>  <span class="hljs-keyword">auto</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> i)&#123;<br>    <span class="hljs-keyword">return</span> a[i];<br>  &#125;<br>  Poly <span class="hljs-keyword">operator</span>*(Poly &amp;A)&#123;<br>    <span class="hljs-function">Poly <span class="hljs-title">R</span><span class="hljs-params">(d+A.d)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=d;++i)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=A.d;++j)&#123;<br>        R[i+j] += a[i]*A[j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> R;<br>  &#125;<br>&#125;;<br><span class="hljs-function">Poly <span class="hljs-title">mulmod</span><span class="hljs-params">(Poly &amp;A,Poly &amp;B,<span class="hljs-keyword">int</span> m,LL mod)</span></span>&#123;<br>  Poly R = A*B;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=R.d;i&gt;=m;--i)&#123;<br>    R[i-m] += R[i];<br>    R[i]=<span class="hljs-number">0</span>;<br>  &#125;<br>  R.d = m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i)&#123;<br>    R[i]%=mod;<br>  &#125;<br>  <span class="hljs-keyword">return</span> R;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">T <span class="hljs-title">powmod</span><span class="hljs-params">(T x,U n,<span class="hljs-keyword">int</span> m,LL mod)</span></span>&#123;<br>  <span class="hljs-function">T <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  r[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(n)&#123;<br>    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) r=<span class="hljs-built_in">mulmod</span>(r,x,m,mod);<br>    n&gt;&gt;=<span class="hljs-number">1</span>;  x=<span class="hljs-built_in">mulmod</span>(x,x,m,mod);<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  LL n,r,mod;<br>  <span class="hljs-keyword">int</span> m;<br>  <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;mod)&#123;<br>    <span class="hljs-function">Poly <span class="hljs-title">A</span><span class="hljs-params">(m<span class="hljs-number">-1</span>)</span></span>;<br>    A[<span class="hljs-number">0</span>]=A[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    Poly R = <span class="hljs-built_in">powmod</span>(A,n,m,mod);<br>    cout&lt;&lt;(R[r%m]*m%mod)&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合数倒数交错和-sum_i0n-frac-1in-choose-i">组合数倒数交错和 <span class="math inline">\(\sum_{i=0}^n \frac{(-1)^i}{n \choose i}\)</span></h2><p>考虑积分 <span class="math inline">\(F(n,m) = \int_0^1 x^m (1-x)^{n-m} dx\)</span>，显然 <span class="math inline">\(F(n,m)=F(n,n-m),F(n,0) = \frac{1}{n+1}\)</span> 且分部积分即可知道 <span class="math inline">\(F(n,m) = \frac{m}{n-m+1} F(n,m-1) = \frac{1}{(n+1){n \choose m}}\)</span>，再等比数列求和就有</p><p><span class="math display">\[\sum_{i=0}^n \frac{(-1)^i}{n \choose i} = (n+1) \int _0 ^1 \sum _{i=0} ^n (-x)^ i (1-x)^ {n-i} dx = (n+1) \int_0 ^1 (1-x)^{n+1} - (-x)^{n+1} dx = \frac{n+1}{n+2} (1+(-1)^n)\]</span></p><h2 id="to-be-continued">To be continued</h2>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点灯问题之高斯消元法</title>
    <link href="/gaussianElimination/"/>
    <url>/gaussianElimination/</url>
    
    <content type="html"><![CDATA[<p>在知乎的 <a href="https://zhuanlan.zhihu.com/skymath">数学&amp;算法</a> 专栏里看到 <a href="https://zhuanlan.zhihu.com/p/53646257">点灯游戏的 <span class="math inline">\(O(n^3)\)</span> 算法</a>，觉得挺有意思，特此记录，并且补充代码</p><span id="more"></span><h2 id="点灯游戏简介">点灯游戏简介</h2><p>一层大楼共有 <span class="math inline">\(n \times n\)</span> 个房间，每个房间都有一盏灯和一个按钮。按动一个房间的按钮后，这个房间和周围四个相邻的房间的灯的状态全部都会改变（由暗变为亮或者亮变为暗）。目标是通过按按钮把所有的灯都点亮（默认情况下全暗）。求点灯方案。</p><ol type="1"><li>全局枚举，复杂度 <span class="math inline">\(O(2^{n^2})\)</span></li><li>首行枚举，复杂度 <span class="math inline">\(O(2^n)\)</span> ，由于第一行的方案就决定了下一行的方案</li><li>线性方程组求解，复杂度 <span class="math inline">\(O(n^6)\)</span></li><li>上述线性方程组求解可以转化成 <span class="math inline">\(n\)</span> 个变量的线性方程组，复杂度 <span class="math inline">\(O(n^3)\)</span></li></ol><p>以上内容取自 <a href="https://zhuanlan.zhihu.com/p/53646257">点灯游戏的 <span class="math inline">\(O(n^3)\)</span> 算法</a></p><blockquote><p>最终方案做法概括：<span class="math inline">\(n^2\)</span> 个方程 <span class="math inline">\(n^2\)</span> 个未知数的线性方程组，由于用第<span class="math inline">\(i\)</span>行的方程可以将第 <span class="math inline">\(i+1\)</span> 行的未知数表示成前 <span class="math inline">\(i\)</span> 行的线性组合，从而是第一行的现行组合，这样到最后一行。最后一行的方程还未使用，从而变成了 <span class="math inline">\(n\)</span> 个方程 <span class="math inline">\(n\)</span> 个未知数的线性方程组。</p></blockquote><p>由于方案可能不唯一，所以用 Python 自带的 numpy 以及 scipy 都不计算奇异矩阵。所以就自己写了高斯消元法来求解。</p><blockquote><p>注意 numpy 数据越界的问题！</p></blockquote><h2 id="高斯消元法普通版本">高斯消元法普通版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># numpy 是用C写的，所以本质是强类型的，需要注意</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tri</span>(<span class="hljs-params">A, b, eps = <span class="hljs-number">1e-6</span></span>):</span><br><span class="hljs-comment"># 使A上三角，并返回A的秩 和 列变换px</span><br>  n = <span class="hljs-built_in">len</span>(A)<br>  px = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    j,k = i,i<br>    <span class="hljs-keyword">while</span>(k&lt;n):<br>      j=i<br>      <span class="hljs-keyword">while</span>(j&lt;n <span class="hljs-keyword">and</span> np.fabs(A[j,k])&lt;eps): j+=<span class="hljs-number">1</span><br>      <span class="hljs-keyword">if</span>(j != n): <span class="hljs-keyword">break</span><br>      k+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(k == n): <span class="hljs-keyword">return</span> i,px<br>    <span class="hljs-keyword">if</span>(i!=k):<br>      px[i],px[k] = px[k],px[i]<br>      A[:,[i,k]] = A[:,[k,i]]<br>    <span class="hljs-keyword">if</span>(j != i):<br>      b[[i,j]] = b[[j,i]]<br>      A[[i,j]] = A[[j,i]]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,n):<br>      ratio = A[j,i]/A[i,i]<br>      b[j] -= b[i]*ratio<br>      A[j,i:n] -= A[i,i:n]*ratio<br>  <span class="hljs-keyword">return</span> n,px<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trisolve</span>(<span class="hljs-params">A, b</span>):</span><br>  ans = b.copy()<br>  n = <span class="hljs-built_in">len</span>(A)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>    ans[i] = ans[i]/A[i,i]<br>    ans[:i] -= A[:i,i]*ans[i]<br>  <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve</span>(<span class="hljs-params">AA, bb, eps = <span class="hljs-number">1e-6</span></span>):</span><br><span class="hljs-comment"># 求解 Ax = b ，其中A是矩阵，b是列向量</span><br><span class="hljs-comment"># 答案是 ans[:,0] + k[1] ans[:,1] + ... + k[n-r] ans[n-r]</span><br>  <span class="hljs-comment">#一定要类型转化，不然会很惨！</span><br>  A = AA.copy()<br>  b = bb.copy()<br>  A = A.astype(np.<span class="hljs-built_in">float</span>)<br>  b = b.astype(np.<span class="hljs-built_in">float</span>)<br>  n = <span class="hljs-built_in">len</span>(A)<br>  r,px = tri(A,b,eps)<br>  py = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): py[px[i]] = i<br>  <span class="hljs-keyword">if</span>(r == n): <span class="hljs-keyword">return</span> trisolve(A,b)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r,n):<br>    <span class="hljs-keyword">if</span>(np.fabs(b[i,<span class="hljs-number">0</span>])&gt;eps): <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>  ans = np.matrix(np.zeros([n,n-r+<span class="hljs-number">1</span>]))<br>  ans[:r,<span class="hljs-number">0</span>] = trisolve(A[:r,:r],b[:r])<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r,n):<br>    ans[:r,i-r+<span class="hljs-number">1</span>] = trisolve(A[:r][:r],-A[:r,i])<br>    ans[i,i-r+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> ans[py]<br><br>A = np.matrix(<span class="hljs-string">&#x27;1,2;3,4&#x27;</span>)<br>b = np.matrix(<span class="hljs-string">&#x27;2;4&#x27;</span>)<br>ans = solve(A,b)<br><span class="hljs-built_in">print</span>(ans)<br><span class="hljs-built_in">print</span>((b-A*ans[:,<span class="hljs-number">0</span>]))<br><span class="hljs-built_in">print</span>(A*ans[:,<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><h2 id="高斯消元法模素数版本之点灯问题-on3-求解">高斯消元法模素数版本之点灯问题 <span class="math inline">\(O(n^3)\)</span> 求解</h2><p>解的个数取 <span class="math inline">\(\log_2\)</span> 就是 <a href="http://oeis.org/search?q=A159257&amp;sort=&amp;language=&amp;go=Search">A159257</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># numpy 是用C写的，所以本质是强类型的，需要注意</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inv</span>(<span class="hljs-params">a,p</span>):</span> <span class="hljs-comment"># 0&lt;a&lt;p and gcd(a,p)=1</span><br>  <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>): <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> (p-p//a)*inv(p%a,p)%p<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trip</span>(<span class="hljs-params">A, b, p = <span class="hljs-number">2</span></span>):</span> <span class="hljs-comment"># 0 &lt;= A[i,j] &lt; p</span><br><span class="hljs-comment"># 使A上三角，并返回A的秩 和 列变换px</span><br>  n = <span class="hljs-built_in">len</span>(A)<br>  px = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    j,k = i,i<br>    <span class="hljs-keyword">while</span>(k&lt;n):<br>      j=i<br>      <span class="hljs-keyword">while</span>(j&lt;n <span class="hljs-keyword">and</span> A[j,k]==<span class="hljs-number">0</span>): j+=<span class="hljs-number">1</span><br>      <span class="hljs-keyword">if</span>(j != n): <span class="hljs-keyword">break</span><br>      k+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(k == n): <span class="hljs-keyword">return</span> i,px<br>    <span class="hljs-keyword">if</span>(i!=k):<br>      px[i],px[k] = px[k],px[i]<br>      A[:,[i,k]] = A[:,[k,i]]<br>    <span class="hljs-keyword">if</span>(j!=i):<br>      b[[i,j]] = b[[j,i]]<br>      A[[i,j]] = A[[j,i]]<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,n):<br>      ratio = A[j,i]*inv(A[i,i],p)%p<br>      b[j] = (b[j]-b[i]*ratio)%p<br>      A[j,i:n] = (A[j,i:n]-A[i,i:n]*ratio)%p<br>  <span class="hljs-keyword">return</span> n,px<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trisolvep</span>(<span class="hljs-params">A, b, p=<span class="hljs-number">2</span></span>):</span> <span class="hljs-comment"># 0 &lt;= A[i,j] &lt; p and 0&lt;A[i,i]&lt;p</span><br>  ans = b.copy()<br>  n = <span class="hljs-built_in">len</span>(A)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>    ans[i] = ans[i]*inv(A[i,i],p)%p<br>    ans[:i] = (ans[:i] - A[:i,i]*ans[i])%p<br>  <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solvep</span>(<span class="hljs-params">A, b, p=<span class="hljs-number">2</span></span>):</span><br><span class="hljs-comment"># 求解 Ax = b ，其中A是矩阵，b是列向量</span><br><span class="hljs-comment"># 答案是 a[0] + k[1] a[1] + ... + k[n-r] a[n-r]</span><br>  n = <span class="hljs-built_in">len</span>(A)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>      A[i,j]%=p<br>    b[i]%=p<br>  r,px = trip(A,b,p)<br>  py = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): py[px[i]] = i<br>  <span class="hljs-keyword">if</span>(r == n): <span class="hljs-keyword">return</span> trisolvep(A,b,p)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r,n):<br>    <span class="hljs-keyword">if</span>(b[i,<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>  ans = np.matrix(np.zeros([n,n-r+<span class="hljs-number">1</span>], dtype=np.<span class="hljs-built_in">int</span>))<br>  ans[:r,<span class="hljs-number">0</span>] = trisolvep(A[:r,:r],b[:r])<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r,n):<br>    ans[:r,i-r+<span class="hljs-number">1</span>] = trisolvep(A[:r,:r],(-A[:r,i])%p)<br>    ans[i,i-r+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> ans[py]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lighton</span>(<span class="hljs-params">x</span>):</span><br><span class="hljs-comment"># x 是行向量</span><br>  n = x.size<br>  ans = np.matrix(np.ones([n,n]),dtype = np.<span class="hljs-built_in">int</span>)<br>  ans[<span class="hljs-number">0</span>,:] = x<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>      <span class="hljs-keyword">if</span>(i-<span class="hljs-number">2</span>&gt;=<span class="hljs-number">0</span>): ans[i,j] ^= ans[i-<span class="hljs-number">2</span>,j]<br>      ans[i,j] ^= ans[i-<span class="hljs-number">1</span>,j]<br>      <span class="hljs-keyword">if</span>(j-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>): ans[i,j] ^= ans[i-<span class="hljs-number">1</span>,j-<span class="hljs-number">1</span>]<br>      <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;n): ans[i,j] ^= ans[i-<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">light</span>(<span class="hljs-params">n</span>):</span><br><span class="hljs-comment"># n 是整数</span><br>  <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>): <span class="hljs-keyword">return</span> [np.matrix(<span class="hljs-string">&#x27;1&#x27;</span>)]<br>  x = np.matrix(np.zeros([n,n+<span class="hljs-number">1</span>]),dtype = np.<span class="hljs-built_in">int</span>)<br>  y = np.matrix(np.zeros([n,n+<span class="hljs-number">1</span>]),dtype = np.<span class="hljs-built_in">int</span>)<br>  <span class="hljs-comment"># 先处理好第一二行</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    x[i,i] = <span class="hljs-number">1</span><br>    y[i,-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    y[i,:] -= x[i,:]<br>    <span class="hljs-keyword">if</span>(i-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>): y[i,:] -= x[i-<span class="hljs-number">1</span>,:]<br>    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;n):  y[i,:] -= x[i+<span class="hljs-number">1</span>,:]<br>  <span class="hljs-comment"># 第i行由它的前两行决定</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n):<br>    last = np.matrix(np.zeros([n,n+<span class="hljs-number">1</span>]),dtype = np.<span class="hljs-built_in">int</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): last[i,-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>      last[i,:] -= x[i,:]<br>      last[i,:] -= y[i,:]<br>      <span class="hljs-keyword">if</span>(i-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>): last[i,:] -= y[i-<span class="hljs-number">1</span>,:]<br>      <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;n):  last[i,:] -= y[i+<span class="hljs-number">1</span>,:]<br>    x = y<br>    y = last<br>  <span class="hljs-comment"># 此时 x为倒数第二行，y为倒数第一行，根据最后一行灯的情况列方程</span><br>  A = np.matrix(np.zeros([n,<span class="hljs-number">2</span>*n]),dtype = np.<span class="hljs-built_in">int</span>)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    A[i,i] = A[i,i+n]=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(i-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>): A[i,i-<span class="hljs-number">1</span>+n] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;n):  A[i,i+<span class="hljs-number">1</span>+n] = <span class="hljs-number">1</span><br>  A = A*np.vstack((x,y))<br>  b = np.matrix(np.ones([n,<span class="hljs-number">1</span>]),dtype = np.<span class="hljs-built_in">int</span>)<br>  ans = np.matrix(np.zeros([n,n]),dtype = np.<span class="hljs-built_in">int</span>)<br>  x = solvep(A[:,:n],b - A[:,-<span class="hljs-number">1</span>]).T<br>  <span class="hljs-comment"># x 是方程的解，也就是首行的点灯情况</span><br>  cnt = <span class="hljs-number">2</span>**(<span class="hljs-built_in">len</span>(x)-<span class="hljs-number">1</span>)<br>  ans = []<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cnt):<br>    <span class="hljs-comment"># 这里一定要用copy而不能直接等于</span><br>    x0 = np.copy(x[<span class="hljs-number">0</span>,:])<br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(i):<br>      index+=<span class="hljs-number">1</span><br>      <span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>): x0+=x[index,:]<br>      i&gt;&gt;=<span class="hljs-number">1</span><br>    ans.append(lighton(x0&amp;<span class="hljs-number">1</span>))<br>  <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):  <span class="hljs-comment"># n = 19 时方案数 2^16 = 65536，所以会比较慢</span><br>  n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;输入n：&#x27;</span>))<br>  m = light(n)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;方案数：&#x27;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(m)))<br>  <span class="hljs-built_in">print</span>(m)<br></code></pre></td></tr></table></figure><blockquote><p>没学 Python 之前这个操作我肯定是用 Matlab 做了。</p><p>不用 C 是因为操作矩阵的话用 C 还要写矩阵乘法。矩阵加法等操作，代码量大大提升。</p><p>不过没想到 Python 代码量也这么大，主要还是问题复杂或者说优化代码不可避免带来代码量的提高</p><p>高斯消元法对于行不满秩的情况也太繁琐了吧！怪不得它们都不实现。。。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典组合问题</title>
    <link href="/classicalCombination/"/>
    <url>/classicalCombination/</url>
    
    <content type="html"><![CDATA[<p>在此记录一些经典的组合问题，方便日后查阅。</p><blockquote><p>卡特兰数，斯特林数，放球问题，这篇<a href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan#">神作</a>，包含了几乎所有能遇到的经典组合问题</p></blockquote><span id="more"></span><h2 id="卡特兰catalan-数"><a href="https://baike.baidu.com/item/卡特兰数/6125746?fr=aladdin">卡特兰（Catalan ）数</a></h2><p><span class="math inline">\(n\)</span> 个 0 和 <span class="math inline">\(n\)</span> 个 1 组成的序列中始终要保持 <strong>任意前缀中</strong> 0 的个数不超过 1 的个数的序列个数为 <span class="math inline">\(\frac{1}{n+1} {2n \choose n }\)</span></p><blockquote><p>这个问题跟括号合理性等一系列问题合理性有关。</p></blockquote><p><span class="math inline">\(n\)</span> 个 0 和 <span class="math inline">\(m\)</span> 个 1 组成的序列（<span class="math inline">\(n \leq m\)</span>) 保持 <strong>任意前缀中</strong> 0 的个数不超过 1 的个数的序列个数为： <span class="math display">\[{n+m \choose n} - {n+m \choose n-1}\]</span></p><blockquote><p>把 0 当 <span class="math inline">\(x\)</span>-轴，1 当 <span class="math inline">\(y\)</span>-轴，不合理的情况必然经过 <span class="math inline">\(y = x+1\)</span>, 在第一次不合理时，后面的路径就开始与 <span class="math inline">\(y = x +1\)</span> 对称，最终结束点为 <span class="math inline">\((n-1, m+1)\)</span></p></blockquote><h2 id="斯特林stirling数"><a href="https://baike.baidu.com/item/斯特林数">斯特林（Stirling）数</a></h2><p>关于这个问题可以参考 <a href="https://www.cnblogs.com/gzy-cjoier/p/8426987.html">这篇博客</a></p><p>第一类斯特林数：长度为 <span class="math inline">\(n\)</span> 的排列恰好可以写成 <span class="math inline">\(m\)</span> 个轮换的排列个数一般简记为 <span class="math inline">\(\begin{bmatrix} n \\ m\end{bmatrix}\)</span>。递推关系式：</p><p><span class="math display">\[\begin{bmatrix} n \\ m\end{bmatrix} = \begin{bmatrix} n - 1 \\ m - 1 \end{bmatrix} + (n - 1) \begin{bmatrix} n - 1 \\ m\end{bmatrix}\]</span></p><blockquote><p>其它递推公式可以看<a href="https://www.zhihu.com/question/421861786/answer/1481845770">我在知乎上的回答</a></p></blockquote><p>第二类斯特林数： 将 <span class="math inline">\(n\)</span> 个不同的元素拆分成 <span class="math inline">\(m\)</span> 个非空集合的方案数 <span class="math inline">\(S(n,m)\)</span>。一般简记为<span class="math inline">\(\begin{Bmatrix} n \\ m\end{Bmatrix}\)</span> 显然有递推关系式： <span class="math display">\[S(n,m) = S(n-1,m-1)+mS(n-1,m)\]</span> 又我们知道： <span class="math display">\[m^n = \sum _{i=0} ^ m S(n,i) \times i! \times {m \choose i}\]</span> 将 <span class="math inline">\(n\)</span> 个任意的放在 <span class="math inline">\(m\)</span> 个不同盒子中。右边的枚举非空盒子数量 <span class="math inline">\(i\)</span>，<span class="math inline">\(i\)</span> 个盒子因为是不同的所以要乘 <span class="math inline">\(i!\)</span> （不用担心算多了，因为一旦分配好了，盒子本身即使无区别，放了东西就有区别了） <a href="../inverseFormulaAndItsMatrixForm">从我的这篇博文</a> 直接可知 (把 <span class="math inline">\(n\)</span> 看作常数）： <span class="math display">\[S(n,m) m! = \sum_{i=0}^m (-1)^{m-i} {m \choose i} i^n\]</span></p><p>改写成卷积形式也就是：</p><p><span class="math display">\[S(n,m)  = \sum_{i=0}^m \frac{(-1)^{i}}{i!} \frac{(m - i)^n}{(m - i)!}\]</span></p><blockquote><p>补充：知乎上 <a href="https://www.zhihu.com/people/hzy-46-50">Hongzy</a> 写了一篇 <a href="https://zhuanlan.zhihu.com/p/150779987">斯特林数入门</a> 的文章，写的甚好。包含了两类 Stirling 的关系以及上升幂和下降幂的关系。</p></blockquote><h2 id="正整数分拆数">正整数分拆数</h2><p>将正整数 <span class="math inline">\(n\)</span> 拆分成 <span class="math inline">\(m\)</span> 个非负整数之和的方案数 <span class="math inline">\(f(n,m)\)</span>： <span class="math display">\[f(n,m) = \left\{ \begin{array}{lr}1 &amp; n=m=1 \\f(n,n) &amp; n&lt;m \\1+f(n,n-1) &amp; n=m \\f(n,m-1)+f(n-m,m) &amp; n&gt;m&gt;1\end{array} \right.\]</span></p><blockquote><p>完整分拆可以用生成函数取 ln 再取 exp <span class="math inline">\(O(n \log n)\)</span> 复杂度<a href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan#">解决</a></p></blockquote><h2 id="正整数分拆成乘积数"><a href="https://oeis.org/A001055">正整数分拆成乘积数</a></h2><p>记 <span class="math inline">\(fcnt(n,m)\)</span> 表示 <span class="math inline">\(n\)</span> 的乘法分解都不超过 <span class="math inline">\(m\)</span> 的数 <span class="math display">\[fcnt(n,m) = \sum_{d|n} [d&lt;=m] fcnt(\frac{n}{d},d)\]</span></p><ul><li>打表时间复杂度 <span class="math inline">\(O(n^{\frac{5}{2}})\)</span>，空间复杂度 <span class="math inline">\(O(n^2)\)</span> 不推荐！</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10004</span>;<br><span class="hljs-keyword">int</span> fcnt[N][N]; <span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initFcnt</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;N;++i)  fcnt[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;N;++i)&#123;<br>    <span class="hljs-keyword">int</span> sn = <span class="hljs-built_in">sqrt</span>(i+<span class="hljs-number">0.2</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;d&lt;=sn;++d)&#123;<br>      <span class="hljs-keyword">if</span>(i%d) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = N<span class="hljs-number">-1</span>;j&gt;=d;--j)  fcnt[i][j]+=fcnt[i/d][d];<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=N<span class="hljs-number">-1</span>;j&gt;=i/d;--j)  fcnt[i][j]+=fcnt[d][i/d];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(sn*sn == i)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = N<span class="hljs-number">-1</span>;j&gt;=sn;--j)  fcnt[i][j]-=fcnt[sn][sn];<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getFcnt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(fcnt[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] != <span class="hljs-number">1</span>) <span class="hljs-built_in">initFcnt</span>();<br>  <span class="hljs-keyword">return</span> fcnt[n][n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-keyword">while</span>(cin&gt;&gt;n)&#123;<br>    <span class="hljs-keyword">time_t</span> now = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">getFcnt</span>(n)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Time used: &quot;</span>&lt;&lt;<span class="hljs-built_in">difftime</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>),now)&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归（推荐复杂度不好分析）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcnt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> m)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> sn = <span class="hljs-built_in">sqrt</span>(n+<span class="hljs-number">0.2</span>),ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;d&lt;=sn;++d)&#123;<br>    <span class="hljs-keyword">if</span>(n%d)  <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(d&lt;=m &amp;&amp; d&gt;<span class="hljs-number">1</span>)  ans += <span class="hljs-built_in">fcnt</span>(n/d,d);<br>    <span class="hljs-keyword">if</span>(n/d&lt;=m) ans+= <span class="hljs-built_in">fcnt</span>(d,n/d);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(sn*sn == n &amp;&amp; sn&lt;=m) ans-=<span class="hljs-built_in">fcnt</span>(sn,sn);<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-keyword">while</span>(cin&gt;&gt;n)&#123; <span class="hljs-comment">// n=98765432109876 = 9.8*10^13 用时 42s, N 大点，耗时会小点</span><br>    <span class="hljs-keyword">time_t</span> now = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">fcnt</span>(n,n)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Time used: &quot;</span>&lt;&lt;<span class="hljs-built_in">difftime</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>),now)&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="n-个球放在-m-个盒子中"><a href="https://blog.csdn.net/qq_39942341/article/details/80246780"><span class="math inline">\(n\)</span> 个球放在 <span class="math inline">\(m\)</span> 个盒子中</a></h2><p>球有相同和不同两种情况，盒子也是，还有盒子能空和不能空，一共八种情况：</p><ul><li><p>球同，盒同，非空</p><p>正整数拆分数之和 <span class="math inline">\(f(n,m) - f(n,m-1)\)</span></p></li><li><p>球同，盒同，能空</p><p>正整数拆分数 <span class="math inline">\(f(n,m)\)</span></p></li><li><p>球同，盒异，非空</p><p>等价于 <span class="math inline">\(x_1 + \cdots + x_m = n\)</span> 的正整数解，插空法知道 <span class="math inline">\(n-1 \choose m-1\)</span></p></li><li><p>球同，盒异，能空</p><p>同上，<span class="math inline">\(n+m-1 \choose m-1\)</span></p></li><li><p>球异，盒同，非空</p><p>第二类斯特林数： <span class="math inline">\(S(n,m)\)</span></p></li><li><p>球异，盒同，能空</p><p>同上， <span class="math inline">\(\sum_{i=1} ^m S(n,i)\)</span></p></li><li><p>球异，盒异，非空：<span class="math inline">\(m!S(n,m)\)</span></p></li><li><p>球异，盒异，能空：<span class="math inline">\(m^n\)</span></p></li></ul><h2 id="有限制的线性方程组的解">有限制的线性方程组的解</h2><p><span class="math inline">\(x_1+ \cdots +x_n = m, c_i &lt; x_i \leq d_i\)</span> 的正整数解的个数？（通过平移不妨设 <span class="math inline">\(c_i = 0\)</span>）</p><h3 id="m-较小时动态规划直接做复杂度-om2-n"><span class="math inline">\(m\)</span> 较小时，动态规划直接做复杂度 <span class="math inline">\(O(m^2 n)\)</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = d[i]; x &gt; c[i]; --x)&#123;<br>    dp[i][j] += dp[i<span class="hljs-number">-1</span>][j-x];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="n-较小时直接暴力做"><span class="math inline">\(n\)</span> 较小时，直接暴力做</h3><blockquote><p>首先化简为求解：<span class="math inline">\(x_1+ \cdots +x_n = m, 0 \leq x_i \leq a_i\)</span> 的正整数解的个数记作 f(n)</p></blockquote><p>我们先考虑 <span class="math inline">\(n = 2\)</span> 的情形，并且不妨设 <span class="math inline">\(a_1 &lt; a_2\)</span>，我们分情况讨论可得 <span class="math display">\[f(2) = \left\{ \begin{array}{ll}1 + m &amp; m \leq a_1 \\1 + a_1 &amp; a_1 &lt; m &lt; a_2 \\\max(1 + a_1 + a_2 - m, 0) &amp; a_2 \leq m\end{array} \right.\]</span> 记 <span class="math inline">\(g(m, x, y) = \max(0, 1 + \min(m, x) + \min(0, y - m)\)</span> (定义域：<span class="math inline">\(x \leq y\)</span>) 则显然此时有（不妨设 <span class="math inline">\(a_{2i + 1} &lt; a_{2i}\)</span>）：</p><p><span class="math inline">\(f(1) = 1\)</span>, <span class="math inline">\(f(2) = g(m, a_1, a_2)\)</span>, <span class="math inline">\(f(3) = \sum_{x_3 = 0}^{\min(k, a_3)} g(k - x_3, a_1, a_2)\)</span>, <span class="math inline">\(f(4) = \sum_{x = 0}^m g(x, a_1, a_2) \cdot g(m - x, a_3, a_4)\)</span>，可以一致这样搞下去（<span class="math inline">\(n = 5, 6\)</span> 可以依然可以用此方法），但是此时还不如直接用动态规划做法来做。</p><h3 id="d_i---c_i-为一个常数时用包容排斥原理"><span class="math inline">\(d_i - c_i\)</span> 为一个常数时，用包容排斥原理</h3><blockquote><p>不妨设 <span class="math inline">\(c_i = 0, d_i = k\)</span></p></blockquote><p><span class="math display">\[{m-1 \choose n-1} - {n \choose 1} {m-k-1 \choose n-1} + \cdots (-1)^n {n \choose n} {m-nk-1 \choose n-1} = \sum_{i=0} ^ n (-1)^i {n \choose i} {m-ik-1 \choose n-1}\]</span></p><h2 id="求和式">求和式</h2><p><span class="math display">\[\sum_{\sum c_i x_i = m} \frac{(\sum x_i)!}{\prod (x_i !)}\]</span></p><p>其中 <span class="math inline">\(m, c_i\)</span> 是正整数，<span class="math inline">\(x_i\)</span> 是待定非负整数。考虑其组合意义如下：</p><ul><li>首先特殊情况 <span class="math inline">\(c_i = 1\)</span>，此时可以理解为有 m 个洞，每个洞都要选择 n 个物体（每个物体占一个洞）中的一种的总方案数: <span class="math inline">\(n^m\)</span></li><li>一般情况，m 个洞，每个洞有且仅有一个物体覆盖（第 i 个物体的长度为 <span class="math inline">\(c_i\)</span>)的总方案数，直接 DP 即可（求和式表示洞中有 <span class="math inline">\(x_i\)</span> 个 <span class="math inline">\(i\)</span> 物体）</li></ul><p>复杂度：<span class="math inline">\(O(nm)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// \sum_&#123;\sum c_i x_i = m&#125; \frac&#123;(\sum x_i)!&#125;&#123;\prod (x_i !)&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNum</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; c, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> M)</span> </span>&#123;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>  dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : c) <span class="hljs-keyword">if</span> (x &lt;= i) &#123;<br>      dp[i] += dp[i - x];<br>      <span class="hljs-keyword">if</span> (dp[i] &gt;= M) dp[i] -= M;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> dp[m];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matsumura《Commutative Algebra》读书笔记</title>
    <link href="/commutativeAlgebraByMatsumura/"/>
    <url>/commutativeAlgebraByMatsumura/</url>
    
    <content type="html"><![CDATA[<p>在学习非交换环论的过程中, 发现交换环有些东西依然没搞清楚, 复习一下, 顺便再理一理 Matsumura 这本言简意赅的《Commutative Algebra》. 以下环都是指 <strong>含幺交换环(commutative ring with identity)</strong></p><span id="more"></span><h2 id="基本概念">基本概念</h2><p>可以说书中没一句废话, 开头直接给出下面概念, 并且叙述一些常见等价刻画:</p><ol type="1"><li><p>理想的 radical 的定义</p></li><li><p>prime ideal 的(等价)定义</p></li><li><p>primary ideal 的定义, 说明 primary ideal 的 radical 是 prime ideal (反之不尽然), 并给出一个理想成为 primary ideal 的充分条件: 包含某个极大理想的某次幂.</p></li><li><p>定义了环 <span class="math inline">\(A\)</span> 上的 Zariski 拓扑(素谱) <span class="math inline">\(Spec(A)\)</span>, 极大谱 <span class="math inline">\(\Omega(A)\)</span>, 包含某个集合的素理想全体构成闭集(容易验证确实构成拓扑空间), 给出素谱的基本开邻域基. 由于每个理想都包含在某个极大理想中, 极大理想都是素的, 因此 <span class="math inline">\(Spec(A) = \emptyset \Leftrightarrow A = 0\)</span>, 也就是说 <span class="math inline">\(Spec\)</span> 的定义是没有毛病的. <span class="math inline">\(Spec(A)\)</span> 连通当且仅当 <span class="math inline">\(A\)</span> 中无非平凡幂等元. <span class="math display">\[V(I) = V(J) \Longleftrightarrow \sqrt{I} = \sqrt{J}\]</span></p></li><li><p>说明环之间的同态映射 <span class="math inline">\(f: A \to B\)</span> 可以诱导 <span class="math inline">\(Spec(B) \to Spec(A)\)</span> 之间的连续映射, 也就是说 <span class="math inline">\(Spec\)</span> 定义了一个环范畴到拓扑空间范畴的一个逆变函子.</p></li><li><p>给出了一个关于素理想并的常见引理: 一个理想包含在最多两个不是素理想的理想的并中, 则它必然包含在其中一个理想中. 当然这也说明了任意两个真理想的并不会是整个环.</p></li><li><p>给出了两个理想互素的定义(和为整个环), 并说明此时它们的积等于交. 证明用到 <span class="math inline">\((I+J)(I \cap J) \subset IJ\)</span>.</p></li><li><p>定义乘闭子集 <span class="math inline">\(S\)</span> 准备做局部化, 应用 Zorn 引理说明与 <span class="math inline">\(S\)</span> 不相交的理想中任意极大元都是素理想, 由此可以证明: <span class="math inline">\(A\)</span> 中幂零元全体 <span class="math inline">\(nil(A)\)</span> 是 <span class="math inline">\(A\)</span> 中所有素理想的交, 也等于 <span class="math inline">\(A\)</span> 中所有极小素理想的交. 再由此结论, 可以说明每个理想 <span class="math inline">\(I\)</span> 的 radical: <span class="math inline">\(\sqrt{I}\)</span> 是所有包含 <span class="math inline">\(I\)</span> 的素理想的交.</p></li><li><p>定义环 <span class="math inline">\(A\)</span> 在 <span class="math inline">\(S\)</span> 处的局部化 <span class="math inline">\(S^{-1}A\)</span>. <span class="math inline">\(S^{-1}A = 0 \Leftrightarrow 0 \in S\)</span>. 并且我们有自然映射 <span class="math inline">\(\phi : A \to S^{-1}A, \quad a \mapsto a/1\)</span>, 它满足泛性质: 若 <span class="math inline">\(f: A \to B\)</span> 是环同态, 且 <span class="math inline">\(f(S)\)</span> 均为 <span class="math inline">\(B\)</span> 中可逆元, 那么有 <span class="math inline">\(g: S^{-1}A \to B\)</span> 使得 <span class="math inline">\(f = g \phi\)</span></p></li><li><p><span class="math inline">\(A\)</span> 中与 <span class="math inline">\(S\)</span> 不交的理想(素, 准素)和 <span class="math inline">\(S^{-1}A\)</span> 中的理想(素, 准素)有保序一一对应.</p></li><li><p>类似于环, 可以对模 <span class="math inline">\(M\)</span> 作局部化<span class="math inline">\(S^{-1}M \simeq S^{-1}A \otimes M\)</span>, 这个同构可以由两个自然的合理的互逆映射给出. 并且我们还有同构 <span class="math inline">\(S^{-1}(M \otimes N) = S^{-1} M \otimes S^{-1}N\)</span>. 由于张量函子右正合, 用定义可以证明 <span class="math inline">\(S^{-1}A \otimes -\)</span> 是正合函子. 也就是说 <span class="math inline">\(S^{-1}A\)</span> 是平坦 <span class="math inline">\(A\)</span>-模.</p></li><li><p>给出有限表示(finite presentation)的定义: 即一个有限生成模, 且其生成关系也是有限生成的. 等价于说有正合列: <span class="math inline">\(A^m \to A^n \to M \to 0\)</span> 此时我们有: <span class="math display">\[S^{-1}(\hom(M,N)) \simeq \hom(S^{-1}M, S^{-1}N)\]</span> 证明的关键在于对于自由模<span class="math inline">\(M=A^n\)</span>时有上述自然同构, 再由有限表示, 应用 five lemma 证明上式.</p></li><li><p><strong>局部整体关系</strong> <span class="math inline">\(M \to \prod_{\max p} M_{p}\)</span> 是单的. 其中 <span class="math inline">\(M_{p} = (A - p)^{-1} M\)</span>. 证明应用定义说明 <span class="math inline">\(Ann(x) = A\)</span> 即可.</p></li><li><p><strong>整环的特殊情形</strong> 当 <span class="math inline">\(A\)</span> 为整环时, <span class="math inline">\(A\)</span> 在任意乘闭子集处的局部化都可以看做它的分式域的子环, 实际上我们有 <span class="math display">\[A = \bigcap_{\max p} A_{p}\]</span> 证明类似整数作有理数. 定义 <span class="math inline">\(D = \lbrace a \in A \mid ax \in A \rbrace\)</span> 说明若 <span class="math inline">\(x \notin A\)</span> 可知 <span class="math inline">\(D \subset A\)</span> (真包含), 因此 <span class="math inline">\(D\)</span> 在某个极大理想 <span class="math inline">\(P\)</span> 中, 可推出 <span class="math inline">\(x \notin A_{P}\)</span>.</p></li><li><p>我们有自然的同构 <span class="math inline">\(A/I \otimes M \simeq M/IM\)</span>, 同构可由正合列 <span class="math inline">\(0 \to I \to A \to A/I \to 0\)</span>, 用 <span class="math inline">\(- \otimes M\)</span> 作用上去, 再由定义有 <span class="math inline">\(I \otimes M \to IM\)</span> 的自然满同态( <span class="math inline">\(M\)</span> 平坦时可以说明是同构), 得到正合列: <span class="math inline">\(0 \to IM \to M \to A/I \otimes M \to 0\)</span> 特别地, 我们有: <span class="math inline">\(S^{-1}(A/I) = S^{-1}A / I(S^{-1}A)\)</span></p></li><li><p><strong>Jacobson radical</strong>: <span class="math inline">\(rad(A) = \lbrace x \mid 1+xy \in U(A) \rbrace\)</span> 为所有极大理想的交.</p></li><li><p><strong>局部环</strong>: 若环 <span class="math inline">\(A\)</span> 只有一个极大素理想 <span class="math inline">\(\mathfrak{m}\)</span>, 则称 <span class="math inline">\(A\)</span> 为局部环, <span class="math inline">\(A/\mathfrak{m}\)</span> 称为 <span class="math inline">\(A\)</span> 的 residue field. 局部环之所以重要是因为, 任意环 <span class="math inline">\(A\)</span> 在素理想 <span class="math inline">\(p\)</span> 处作局部化都是一个局部环 <span class="math inline">\(A_p\)</span>. 此时 <span class="math inline">\(A_p\)</span> 的 residue field 记作 <span class="math inline">\(k(p)\)</span>. 它恰好是整环 <span class="math inline">\(A/p\)</span> 的分式域 <span class="math inline">\(K(A/p)\)</span>. 由 <span class="math inline">\(A \to A/p\)</span> 到 <span class="math inline">\(A_p \to K(A/p)\)</span> 因此, 我们有 <span class="math inline">\(k(p) \simeq K(A/p)\)</span></p></li><li><p><strong>局部映射</strong>: 若环 <span class="math inline">\((A, \mathfrak{m}, k)\)</span> 和 <span class="math inline">\((A’, \mathfrak{m}’, k’)\)</span> 为局部环, 且有环同态 <span class="math inline">\(\phi: A \to A’\)</span> 使得 <span class="math inline">\(\phi(\mathfrak{m}) \subseteq \mathfrak{m}’\)</span>, 则称为局部映射, 此时 <span class="math inline">\(\phi\)</span> 自然诱导了环同态 <span class="math inline">\(k \to k’\)</span>. 现在对任意环同态 <span class="math inline">\(\phi: A \to B\)</span>, 考虑连续映射 <span class="math display">\[\hat{\phi}: Spec(B) \to Spec(A), \quad P \to \phi^{-1}(P) = P \cap A = p\]</span> 此时 <span class="math inline">\(\phi(A-p) \subseteq B-P\)</span>, 即 <span class="math inline">\(\phi\)</span> 诱导了局部映射 <span class="math inline">\(\phi_P: A_p \to B_P\)</span>.</p></li><li><p><strong>半局部环</strong> 若环 <span class="math inline">\(A\)</span> 只有有限个极大理想 <span class="math inline">\(\mathfrak{m}_1, \mathfrak{m}_2, \cdots , \mathfrak{m}_r\)</span>, 则称 <span class="math inline">\(A\)</span> 为半局部环(semilocal ring). 由于不同极大理想必然互素, 因此 <span class="math display">\[rad(A) = \mathfrak{m}_1 \cap \cdots \cap \mathfrak{m}_r = \prod \mathfrak{m}_i\]</span></p></li><li><p><strong>NAK lemma</strong> 设 <span class="math inline">\(I\)</span> 是环 <span class="math inline">\(A\)</span> 的理想, <span class="math inline">\(M\)</span> 是有限生成(f.g.) <span class="math inline">\(A\)</span>-模. 若 <span class="math inline">\(IM = M\)</span>, 则存在 <span class="math inline">\(t \in I\)</span> 使得 <span class="math inline">\((1+t)M = 0\)</span>, 特别地, 若还有 <span class="math inline">\(I \subseteq rad(A)\)</span>, 则 <span class="math inline">\(M=0\)</span>. <strong>Proof</strong>: 设 <span class="math inline">\(M=Am_1 + \cdots + Am_s\)</span>, 对 <span class="math inline">\(s\)</span> 数学归纳, <span class="math inline">\(s=0\)</span> 时, 结论显然, 设 <span class="math inline">\(M’ = M / Am_s\)</span>, 则由归纳假设, <span class="math inline">\(\exists x \in I\)</span> 使得 <span class="math inline">\((1+x)M’=0\)</span>, 即 <span class="math inline">\((1+x)M \subseteq Aw_s\)</span>, 由于 <span class="math inline">\(M = IM\)</span>, 我们有 <span class="math inline">\((1+x)M = I(1+x)M \subseteq I(Aw_s) = Iw_s\)</span>, 因此存在 <span class="math inline">\(y \in I\)</span> 使得 <span class="math inline">\((1+x)w_s = yw_s\)</span>. 所以 <span class="math inline">\((1+x-y)(1+x)M = 0\)</span>, <span class="math inline">\(t = x-y+x+(x-y)x\)</span> 即为所求. <strong>NAK lemma</strong> 常用如下应用形式: <span class="math inline">\(I\)</span> 为环 <span class="math inline">\(A\)</span> 的理想, <span class="math inline">\(N \subset M\)</span> 为 <span class="math inline">\(A\)</span>-模, 若 <span class="math inline">\(M = N + IM\)</span>, 且 <span class="math inline">\(I\)</span> 幂零或 <span class="math inline">\(M\)</span> 有限生成, 则 <span class="math inline">\(M=N\)</span>. <strong>Remark</strong>：不要以为有限生成, 理想幂零, 环是整环或者 reduced 条件很苛刻, 其实实际碰到的也都是这些环, 主要问题在于有没有丰富的结果, 这些条件在何时发挥着作用. 有限生成可以用数学归纳, 幂零理想可以用于幂次和根理想.</p></li><li><p>给定局部环 <span class="math inline">\((A, \mathfrak{m},k)\)</span> , <span class="math inline">\(M\)</span> 是 <span class="math inline">\(A\)</span>-模, 若 <span class="math inline">\(\mathfrak{m}\)</span> 幂零(例如 <span class="math inline">\(A\)</span> 是 Artinian)或者 <span class="math inline">\(M\)</span> 有限生成, 则 <span class="math inline">\(M\)</span> 的子集 <span class="math inline">\(G\)</span> 生成 <span class="math inline">\(M\)</span>, 当且仅当它在 <span class="math inline">\(M/\mathfrak{m}M = M \otimes k\)</span> 下像 <span class="math inline">\(\bar{G}\)</span> 生成 <span class="math inline">\(M \otimes k\)</span>. <strong>Remark</strong>: 由于 <span class="math inline">\(M \otimes k\)</span> 是域 <span class="math inline">\(k\)</span> 上的向量空间, 因此它的一组基提升之后就能生成 <span class="math inline">\(M\)</span>, 但是一般地并不能保证这些生成元线性无关.</p></li><li><p><span class="math inline">\(M\)</span>-regular: <span class="math inline">\(a \in A\)</span> 称为 <span class="math inline">\(M\)</span>-regular, 若 <span class="math inline">\(0 \to M \xrightarrow{a} M\)</span>, 显然, <span class="math inline">\(M\)</span>-regular 元全体构成了一个乘闭子集. 设 <span class="math inline">\(S_0\)</span> 为 <span class="math inline">\(A\)</span>-regular 元全体, 则 <span class="math inline">\(S_0^{-1}A\)</span> 称为 <span class="math inline">\(A\)</span> 的 total quotient ring. 此时 <span class="math inline">\(\phi: A \to S_0^{-1} A\)</span> 是环单同态.</p></li><li><p>若 <span class="math inline">\(M\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 上有限生成模,那么我们有投射表示: <span class="math display">\[\cdots \to X_i \to X_{i+1} \to \cdots X_0 \to M \to 0\]</span> 其中 <span class="math inline">\(X_i\)</span> 为有限自由 <span class="math inline">\(A\)</span>-模, 特别地, 此时 <span class="math inline">\(M\)</span> 是有限表示(finite presentation). 此时多项式环 <span class="math inline">\(A[x_1, \cdots, x_n]\)</span> 也是 Noetherian, 类似的形式幂级数环 <span class="math inline">\(A[[x_1, \cdots, x_n]]\)</span> 也是 Noetherian, <span class="math inline">\(A\)</span> 上的有限维代数也是 Noetherian. <strong>Remark</strong>: 任意环中, 理想链的长度不低于极大理想的个数.</p></li><li><p>环 <span class="math inline">\(A\)</span> 是 Artinian, 当且仅当它作为 <span class="math inline">\(A\)</span>-模是有限长的, 当且仅当它是 Noetherian, 并且它的素理想都是极大的.</p></li><li><p>设 <span class="math inline">\(\mathfrak{a}\)</span> 是环 <span class="math inline">\(A\)</span> 的理想, <span class="math inline">\(b \in A\)</span>, 若 <span class="math inline">\(\mathfrak{a} + bA\)</span> 和 <span class="math inline">\(\mathfrak{a}:bA\)</span> 都有限生成, 则 <span class="math inline">\(\mathfrak{a}\)</span> 有限生成. <strong>Proof</strong>: 设 <span class="math inline">\(a_i \in \mathfrak{a},\quad b_j \in A\)</span> 使得 <span class="math inline">\(\mathfrak{a} + bA = \sum a_iA + bA\)</span> 且 <span class="math inline">\(\mathfrak{a} : bA = \sum c_j A\)</span>. 设 <span class="math inline">\(\mathfrak{a}’ = \sum a_iA + \sum bc_j A \subseteq \mathfrak{a}\)</span>. 对任意 <span class="math inline">\(a \in \mathfrak{a}\)</span>, 我们有 <span class="math inline">\(a \in \mathfrak{a}’ + bA\)</span>, 即 <span class="math inline">\(a \equiv rb \mod \mathfrak{a}’\)</span>. 因此 <span class="math inline">\(rb \in \mathfrak{a}\)</span>. 即 <span class="math inline">\(r \in \mathfrak{a}: bA\)</span>, <span class="math inline">\(rb \in \mathfrak{a}’\)</span>, 因此 <span class="math inline">\(a \in \mathfrak{a}’\)</span>, 即 <span class="math inline">\(\mathfrak{a} = \mathfrak{a}’\)</span>.</p></li><li><p>(Cohen)环 <span class="math inline">\(A\)</span> 是 Noetherian, 当且仅当它的每个素理想都是有限生成的. <strong>Proof</strong>: 记 <span class="math inline">\(A\)</span> 中所有非有限生成理想构成的集合为 <span class="math inline">\(F\)</span>, 取 <span class="math inline">\(F\)</span> 中极大元 <span class="math inline">\(\mathfrak{a}\)</span> (Zorn 引理保证可行性), 那么由条件知道 <span class="math inline">\(\mathfrak{a}\)</span> 不是素理想, 因此存在 <span class="math inline">\(a,b \in A\)</span>, 使得 <span class="math inline">\(a, b \notin \mathfrak{a}\)</span> 且 <span class="math inline">\(ab \in \mathfrak{a}\)</span>. 又因为 <span class="math inline">\(\mathfrak{a}\)</span> 的极大性知: <span class="math inline">\(\mathfrak{a}+bA\)</span> 和 <span class="math inline">\(\mathfrak{a}:bA\)</span> 有限生成, 所以 <span class="math inline">\(\mathfrak{a}\)</span> 有限生成, 所以 <span class="math inline">\(F = \emptyset\)</span>.</p></li><li><p>定义 <span class="math inline">\(Supp(M) = \lbrace p \in Spec(A) \mid M_p \neq 0 \rbrace\)</span>. 若 <span class="math inline">\(M\)</span> 有限生成, 则 <span class="math inline">\(Supp(M) = V(Ann(M))\)</span>. 此时 <span class="math inline">\(Supp(M)\)</span> 就是零化 <span class="math inline">\(M\)</span> 的理想的闭包, 没毛病, 完美.</p></li></ol><h2 id="平坦性flatness">平坦性(Flatness)</h2><p>设 <span class="math inline">\(S: \quad \cdots \to N \to N’ \to N’’ \to \cdots\)</span> 是任意 <span class="math inline">\(A\)</span>-模序列. 称 <span class="math inline">\(A\)</span>-模 <span class="math inline">\(M\)</span> 是平坦的, 如果 <span class="math inline">\(S\)</span> 正合, 则 <span class="math inline">\(S \otimes M\)</span> 正合. 称 <span class="math inline">\(M\)</span> 忠实平坦的(faithful flat), 如果 <span class="math inline">\(S\)</span> 正合当且仅当 <span class="math inline">\(S \otimes M\)</span> 正合. 例子: 投射模是平坦的, 自由模是忠实平坦的.</p><h3 id="平坦模的等价刻画">平坦模的等价刻画</h3><ol type="1"><li><span class="math inline">\(M\)</span> 是平坦的.</li><li>若 <span class="math inline">\(0 \to N \to N’\)</span> exact, 则 <span class="math inline">\(0 \to N \otimes M \to N’ \otimes M\)</span> exact.</li><li>对任意(有限生成)理想 <span class="math inline">\(I\)</span>, <span class="math inline">\(0 \to I \otimes M \to M\)</span> exact. 即 <span class="math inline">\(I \otimes M \simeq IM\)</span>.</li><li><span class="math inline">\(Tor_1 ^A(M,A/I) = 0\)</span> 对任意(有限生成)理想 <span class="math inline">\(I\)</span> 成立.</li><li><span class="math inline">\(Tor_1 ^A(M,N) = 0\)</span> 对任意(有限生成)模 <span class="math inline">\(N\)</span> 成立.</li><li>若 <span class="math inline">\(\sum a_i x_i = 0\)</span>, 则存在 <span class="math inline">\(b_{ij} \in A, y_j \in M\)</span> 使得 <span class="math inline">\(\sum a_i b_{ij} = 0\)</span> 且 <span class="math inline">\(x_i = \sum b_{ij}y_j\)</span>.</li></ol><h3 id="平坦模的基本性质">平坦模的基本性质</h3><p><strong>Transitivity</strong>: 设 <span class="math inline">\(\phi: A \to B\)</span> 是平坦环同态(即 <span class="math inline">\(B\)</span> 看做 <span class="math inline">\(A\)</span>-模是平坦的), 那么平坦 <span class="math inline">\(B\)</span>-模 <span class="math inline">\(N\)</span> 也是平坦 <span class="math inline">\(A\)</span>-模. (直接用定义证明即可)</p><p><strong>Change of base</strong>: 设 <span class="math inline">\(\phi: A \to B\)</span> 是环同态, 若 <span class="math inline">\(M\)</span> 是平坦 <span class="math inline">\(A\)</span>-模, 则 <span class="math inline">\(M \otimes B\)</span> 是平坦 <span class="math inline">\(B\)</span>-模.</p><p><strong>Localization</strong>: <span class="math inline">\(S^{-1}A\)</span> 是平坦 <span class="math inline">\(A\)</span>-模. (直接用元素定义可证)</p><p><strong>Tor 函子和张量函子交换</strong>: 设 <span class="math inline">\(\phi: A \to B\)</span> 是平坦同态, <span class="math inline">\(M,N\)</span> 是 <span class="math inline">\(A\)</span>-模, 则有 <span class="math display">\[Tor_i ^A(M,N) \otimes_A B = Tor_i ^B(M \otimes_A B,N \otimes_A B)\]</span> 当 <span class="math inline">\(A\)</span> Noetherian 且 <span class="math inline">\(M\)</span> 有限生成, 则 <span class="math display">\[Ext_i ^A(M,N) \otimes _A B = Ext_i ^B(M \otimes_A B,N \otimes_A B)\]</span> <strong>Proof</strong>: 给定 <span class="math inline">\(M\)</span> 的一个投射(自由)表示: <span class="math inline">\(\cdots \to X_1 \to X_0 \to M \to 0\)</span>. 由于 <span class="math inline">\(B_A\)</span> 平坦, 我们得到 <span class="math inline">\(M \otimes_A B\)</span> 的投射表示: <span class="math inline">\(\cdots \to X_1 \otimes_A B \to X_0 \otimes_A B \to M \otimes_A B \to 0\)</span>. 因此我们有: <span class="math display">\[Tor_i ^B(M \otimes_A B,N \otimes_A B) = H_i(X. \otimes_A N \otimes_A B) = H_i(X. \otimes_A N)\otimes_A B = Tor_i ^A(M,N) \otimes_A B\]</span> 当 <span class="math inline">\(A\)</span> Noetherian 且 <span class="math inline">\(M\)</span> 有限生成时, 我们可以给 <span class="math inline">\(M\)</span> 的一个有限自由表示, 再由 <span class="math inline">\(B\)</span> 平坦得到了, <span class="math inline">\(M \otimes _A B\)</span>的有限自由表示: <span class="math inline">\(\cdots \to X_1 \otimes_A B \to X_0 \otimes_A B \to M \otimes_A B \to 0\)</span> 由此得到复形: <span class="math display">\[0 \to \hom_B(M \otimes_A B, N \otimes _A B) \to  \hom_B(X_0 \otimes_A B, N \otimes _A B) \to \hom_B(X_1 \otimes_A B, N \otimes _A B) \to \cdots\]</span> 由于 <span class="math inline">\(X_i\)</span> 是有限自由模, 因此 <span class="math inline">\(\hom_B(X_i \otimes B, N \otimes B) = \hom_A(X_i, N) \otimes _A B\)</span>. 所以 <span class="math display">\[Ext_i ^B(M \otimes_A B,N \otimes_A B) = H_i(\hom_A(X_i, N) \otimes_A B) = H_i(\hom_A(X_i, N)) \otimes_A B = Ext_i ^A(M,N) \otimes_A B\]</span></p><blockquote><p>特别地, 去 <span class="math inline">\(B = S^{-1}A\)</span>.</p></blockquote><p>设 <span class="math inline">\(M\)</span> 是平坦 <span class="math inline">\(A\)</span>-模, 则 <span class="math inline">\(A\)</span>-regular 元都是 <span class="math inline">\(M\)</span>-regular 元. 这只因为 <span class="math inline">\(0 \to A \xrightarrow{a} A\)</span> 可推出 <span class="math inline">\(0 \to M \xrightarrow{a}M\)</span>.</p><h4 id="局部环上有限生成模是自由模">局部环上有限生成模是自由模</h4><p><span class="math inline">\((A,\mathfrak{m},k)\)</span> 是局部环, <span class="math inline">\(M\)</span> 是平坦 <span class="math inline">\(A\)</span>-模, 若 <span class="math inline">\(\mathfrak{m}\)</span> 幂零或 <span class="math inline">\(M\)</span> 有限生成, 则 <span class="math inline">\(M\)</span> 是自由模. 在<strong>基本概念 21</strong>中, <span class="math inline">\(G\)</span> 生成了 <span class="math inline">\(M\)</span>, 如果 <span class="math inline">\(G\)</span> 中元素线性无关, 那么 <span class="math inline">\(G\)</span> 自然就是 <span class="math inline">\(M\)</span> 的一组基(从而是自由模), 也就是说, 我们只需证明 <span class="math inline">\(G =\lbrace x_1 \cdots x_n \rbrace\)</span>在 <span class="math inline">\(M/mM = M \otimes k\)</span>下的象线性无关, 则由 <span class="math inline">\(G\)</span> 线性无关. 而<strong><span class="math inline">\(\mathfrak{m}\)</span> 幂零或 <span class="math inline">\(M\)</span> 有限生成</strong>这个条件本质上是保证 <span class="math inline">\(M/mM \neq 0\)</span> (由 NAK lemma). 然后对 <span class="math inline">\(n\)</span> 应用数学归纳, 并利用 <strong>平坦模等价刻画 6</strong> 说明线性无关性. 从而命题得证.</p><blockquote><p>局部环上的投射模都是自由模</p></blockquote><h4 id="平坦模">平坦模</h4><p>设 <span class="math inline">\(A \to B\)</span> 是平坦同态, 设 <span class="math inline">\(I,J\)</span> 是 <span class="math inline">\(A\)</span> 是理想, 则</p><ol type="1"><li><span class="math inline">\((I \cap J)B = IB \cap JB\)</span></li><li><span class="math inline">\((I : J)B = IB : JB\)</span>, 其中<span class="math inline">\(J\)</span>是有限生成的.</li></ol><p><strong>Proof</strong>: 由正合列: <span class="math inline">\(0 \to I \cap J \to A \to A/I \otimes A/J\)</span>, 张量上 <span class="math inline">\(B\)</span>得到 <span class="math inline">\(0 \to (I \cap J)B \to B \to B/IB \otimes B/JB\)</span>. 因此 <span class="math inline">\((I \cap J)B = IB \cap JB\)</span>. 当 <span class="math inline">\(J\)</span> 有限生成时, 只需证明 <span class="math inline">\(J = aA\)</span> 的形式: 由正合列 <span class="math inline">\(0 \to (I :aA) \to A \xrightarrow{f} \to A/I\)</span>. 其中 <span class="math inline">\(f(x) = ax \mod I\)</span>. 张量上 <span class="math inline">\(B\)</span> 即可得到结论, 对于一般情况应用 <span class="math display">\[(I: \sum_{i=1} ^n a_i A) = \bigcap_{i=1} ^n (I : a_i A)\]</span></p><blockquote><p>平坦映射讲一个保持理想的交, 一种反映平坦的地方吧.</p></blockquote><h4 id="平坦的局部整体性">平坦的局部整体性</h4><p>设 <span class="math inline">\(f: A \to B\)</span> 是环同态(即 <span class="math inline">\(B\)</span> 是交换结合 <span class="math inline">\(A\)</span> 代数), 那么下面条件等价:</p><ol type="1"><li><span class="math inline">\(B\)</span> 作为 <span class="math inline">\(A\)</span>-模平坦.</li><li><span class="math inline">\(B_P\)</span> 作为 <span class="math inline">\(A_p\)</span>-模平坦, 其中 <span class="math inline">\(p = P \cap A, \quad P \in Spec(B)\)</span></li><li><span class="math inline">\(B_P\)</span> 作为 <span class="math inline">\(A_p\)</span>-模平坦, 其中 <span class="math inline">\(p = P \cap A, \quad P \in \omega(B)\)</span> <strong>Proof</strong>: <span class="math inline">\(1 \to 2 \to 3\)</span> 显然, <span class="math inline">\(3 \to 1\)</span>, 只需证明 <span class="math inline">\(Tor_1 ^A(B,N)=0\)</span>. 由<span class="math inline">\(Tor_1 ^{A_p}(B_P, N_p) = 0, P \in \omega(B)\)</span>. 知道结论成立.</li></ol><h3 id="忠实平坦-faithful-flat-f.f.">忠实平坦 faithful flat (f.f.)</h3><p>一个自然的问题, 平坦模何时成为忠实平坦模呢? 设 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(A\)</span>-模, 下面条件等价</p><ol type="1"><li><span class="math inline">\(M\)</span> 是 f.f. <span class="math inline">\(A\)</span>-模;</li><li><span class="math inline">\(M\)</span> 是平坦 <span class="math inline">\(A\)</span>-模, 且对任意 <span class="math inline">\(A\)</span>-模 <span class="math inline">\(N \neq 0\)</span>, <span class="math inline">\(N \otimes M \neq 0\)</span>;</li><li><span class="math inline">\(M\)</span> 是平坦 <span class="math inline">\(A\)</span>-模, 且对任意 <span class="math inline">\(A\)</span> 的极大理想 <span class="math inline">\(\mathfrak{m}\)</span>, <span class="math inline">\(mM \neq M\)</span>. <strong>Proof</strong>: <span class="math inline">\(1 \to 2\)</span>: 由 <span class="math inline">\(0 \to N \to 0\)</span> 和 <span class="math inline">\(0 \to N \otimes M \to 0\)</span> 同时正合性证毕. <span class="math inline">\(2 \to 3\)</span>: 由于 <span class="math inline">\(A/\mathfrak{m} \neq 0\)</span>, 所以 <span class="math inline">\(M/\mathfrak{m} M \simeq A/\mathfrak{m} \otimes M \neq 0\)</span>. <span class="math inline">\(3 \to 2\)</span>: 对任意 <span class="math inline">\(0 \neq x \in N\)</span>, 存在 <span class="math inline">\(I\)</span> 使得 <span class="math inline">\(Ax \simeq A/I\)</span>, 设 <span class="math inline">\(\mathfrak{m}\)</span> 为包含 <span class="math inline">\(I\)</span> 的一个极大理想, 于是 <span class="math inline">\(IM \subseteq \mathfrak{m}M \subset M\)</span>, 从而 <span class="math inline">\((A/I)\otimes M = M/IM \neq 0\)</span>. 又由 <span class="math inline">\(M\)</span> 平坦知: <span class="math inline">\(0 \to (A/I) \otimes M \to N \otimes M\)</span> 正合, 所以 <span class="math inline">\(N \otimes M \neq 0\)</span>. <span class="math inline">\(2 \to 1\)</span>: 设 <span class="math inline">\(S: N’ \xrightarrow{f} N \xrightarrow{g} N’’\)</span> 为 <span class="math inline">\(A\)</span>-模序列. 若 <span class="math inline">\(S \otimes M : N’\otimes M \xrightarrow{\hat{f}} N \otimes M \xrightarrow{\hat{g}} N’’\otimes M\)</span>. 由于 <span class="math inline">\(- \otimes M\)</span> 函子正合. <span class="math inline">\(Im(gf) \otimes M = Im(\hat{f}\hat{g})=0\)</span>. 从而<span class="math inline">\(Im(gf)=0\)</span>, 即 <span class="math inline">\(S\)</span> 是复形, <span class="math inline">\(H(S) \otimes M = H(S \otimes M) = 0\)</span>, 从而 <span class="math inline">\(H(S) = 0\)</span>, 证毕.</li></ol><h4 id="局部环中平坦和忠实平坦">局部环中平坦和忠实平坦</h4><p>设 <span class="math inline">\((A,\mathfrak{m}), (B,\mathfrak{n})\)</span> 是局部环, <span class="math inline">\(\phi: A \to B\)</span> 是局部同态, 若 <span class="math inline">\(M \neq 0\)</span> 是有限 <span class="math inline">\(B\)</span>-模或 <span class="math inline">\(\mathfrak{n}\)</span> 幂零，则 <span class="math display">\[M \text{是平坦模} \Longleftrightarrow M \text{是忠实平坦模}\]</span> 由 <span class="math inline">\(\mathfrak{m} M \subseteq \mathfrak{n}M \neq M\)</span> (NAK lemma), 从而由忠实平坦模的等价刻画知结论成立. 推论 1: <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 上平坦等价于忠实平坦.(取 <span class="math inline">\(M=B\)</span>) 推论 2: 若 <span class="math inline">\(M\)</span> 是有限生成 <span class="math inline">\(A\)</span>-模或 <span class="math inline">\(\mathfrak{m}\)</span> 幂零, 则 <span class="math inline">\(M\)</span> 平坦等价于忠实平坦(其实本结论可以由 <strong>局部环上有限生成模是自由模</strong> 小节直接推出).</p><h4 id="忠实平坦模的性质">忠实平坦模的性质</h4><p>类似于平坦模, transitive, change of base 都成立. 并且它还满足 descent property: 若 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span>-代数, <span class="math inline">\(M\)</span> 是忠实平坦 <span class="math inline">\(B\)</span>-模, 也是忠实平坦 <span class="math inline">\(A\)</span>-模, 那么 <span class="math inline">\(B\)</span>也是忠实平坦 <span class="math inline">\(A\)</span>-模. <strong>忠实平坦在环扩张中起了很重要的作用</strong> 设 <span class="math inline">\(\phi: A \to B\)</span> 是 f.f. 同态 则:</p><ol type="1"><li>对任意 <span class="math inline">\(A\)</span>-模 <span class="math inline">\(N\)</span>, <span class="math inline">\(N \to N \otimes B, \quad x \mapsto x \otimes 1\)</span> 是单的. 特别地, <span class="math inline">\(\phi\)</span> 是单的, 因此 <span class="math inline">\(A\)</span> 可以看做 <span class="math inline">\(B\)</span> 的子环.</li><li>对任意 <span class="math inline">\(A\)</span> 的理想 <span class="math inline">\(I\)</span>, 我们有 <span class="math inline">\(IB \cap A = I\)</span></li><li><span class="math inline">\(\hat{\phi}: Spec(B) \to Spec(A)\)</span> 是满的.</li></ol><p><strong>Proof</strong>:</p><ol type="1"><li><p><span class="math inline">\(0 \neq x \in N\)</span>, 则 <span class="math inline">\(0 \neq Ax \subset N\)</span>. 因此 <span class="math inline">\(Ax \otimes B \in N \otimes B\)</span>(<span class="math inline">\(B\)</span>平坦). 又 <span class="math inline">\(Ax \otimes B = (x \otimes 1)(A \otimes B) = (x \otimes 1)B\)</span>. 由 <span class="math inline">\(B\)</span> 忠实平坦知 <span class="math inline">\(x \otimes 1 \neq 0\)</span>.</p></li><li><p>由于 <span class="math inline">\(B \otimes _A (A/I) = B/IB\)</span> 在 <span class="math inline">\(A/I\)</span>上 忠实平坦, 因此 <span class="math inline">\(A/I \subseteq B/IB\)</span>. 因此 <span class="math inline">\(IB \cap A \subset I\)</span>. 又反方向显然, 证毕.</p></li><li><p>设 <span class="math inline">\(p \in Spec(A)\)</span>. <span class="math inline">\(B_p = B \otimes A_p\)</span> 在 <span class="math inline">\(A_p\)</span> 上忠实平坦, 因此 <span class="math inline">\(pB_p \neq B_p\)</span> <strong>(这是关键的一步)</strong>. 取 <span class="math inline">\(B_p\)</span> 中一个包含 <span class="math inline">\(pB_p\)</span> 的极大理想 <span class="math inline">\(\mathfrak{m}\)</span>. 则 <span class="math inline">\(pA_p \subseteq \mathfrak{m} \cap A_p\)</span>, 因此 <span class="math inline">\(pA_p = \mathfrak{m} \cap A_p\)</span>. 设 <span class="math inline">\(P = \mathfrak{m} \cap B\)</span>. 则 <span class="math display">\[P \cap A = \mathfrak{m} \cap B \cap A = \mathfrak{m} \cap A = \mathfrak{m} \cap A_p \cap A = pA_p \cap A = p\]</span> 要理解上面式子关键在于 <span class="math inline">\(0 \to A \to A_p \to B_p = A_p \otimes B\)</span>. 最后 <span class="math inline">\(\mathfrak{m}\)</span> 被拉回之后就在 <span class="math inline">\(B\)</span> 中了.</p></li></ol><h4 id="忠实平坦的等价刻画">忠实平坦的等价刻画</h4><p>之前已经给了一些平坦的等价可以, 都是与张量积有关, 下面给出的都与谱有关. 即与素理想有关. 设 <span class="math inline">\(\phi: A \to B\)</span> 是平坦映射, 以下结论等价:</p><ol type="1"><li><span class="math inline">\(\phi\)</span> 是忠实平坦的;</li><li><span class="math inline">\(\phi\)</span> 是平坦的, 且 <span class="math inline">\(\hat{\phi}: Spec(B) \to Spec(A)\)</span> 是满的;</li><li><span class="math inline">\(\phi\)</span> 是平坦的, 且对任意 <span class="math inline">\(A\)</span> 中极大理想 <span class="math inline">\(\mathfrak{m}\)</span>,存在 <span class="math inline">\(B\)</span> 中极大理想 <span class="math inline">\(\mathfrak{m}’\)</span> 使得 <span class="math inline">\(\mathfrak{m}’ \cap A = \mathfrak{m}\)</span>.</li></ol><blockquote><p>这注定了它和 NAK lemma 之间密切的联系.</p></blockquote><p><span class="math inline">\(1 \to 2\)</span> 已证, <span class="math inline">\(2 \to 3\)</span> 是因为存在 <span class="math inline">\(p’ \in Spec(B)\)</span> 使得 <span class="math inline">\(p’ \cap A = \mathfrak{m}\)</span>. 找一个包含 <span class="math inline">\(p’\)</span> 的极大理想 <span class="math inline">\(\mathfrak{m}’\)</span>. 则 <span class="math inline">\(\mathfrak{m} \cap A = \mathfrak{m}\)</span> (由于 <span class="math inline">\(\mathfrak{m}\)</span> 极大). <span class="math inline">\(3 \to 1\)</span> 是因为此时 <span class="math inline">\(\mathfrak{m}B \subseteq \mathfrak{m}’B = \mathfrak{m} \subset B\)</span>. 因此 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 上忠实平坦.</p><h4 id="忠实平坦上的平坦">忠实平坦上的平坦</h4><p>设 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 上的忠实平坦 <span class="math inline">\(A\)</span>-代数. <span class="math inline">\(M\)</span> 是 <span class="math inline">\(A\)</span>-模. 则 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(A\)</span> 上的(忠实)平坦模 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(M\)</span> 是 <span class="math inline">\(B\)</span> 上的(忠实)平坦模。</p><p><span class="math inline">\(\Longrightarrow\)</span> 就是 change of base 的结果. <span class="math inline">\(\Longleftarrow\)</span> 成立是因为一般地我们有: <span class="math display">\[(S \otimes_A M) \otimes_A B = (S \otimes_A B) \otimes_B (M \otimes_A B)\]</span></p><h4 id="整环上的忠实平坦">整环上的忠实平坦</h4><p>设 <span class="math inline">\(A\)</span> 设整环, 整环 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(A \subseteq B \subseteq Q(A)\)</span>, 其中 <span class="math inline">\(Q(A)\)</span> 是 <span class="math inline">\(A\)</span> 的分式域. 则 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 上忠实平坦当且仅当 <span class="math inline">\(B=A\)</span>. <strong>Proof</strong>: 若 <span class="math inline">\(B \neq A\)</span>, 则对任意 <span class="math inline">\(0 \neq x \in B \backslash A\)</span>, <span class="math inline">\(x = y/s,\quad y,s \in A, s \notin U(A)\)</span>, 从而 <span class="math inline">\(sB \cap A = A \neq sA\)</span>. 因此 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 上不忠实平坦, 所以 <span class="math inline">\(B = A\)</span>.</p><blockquote><p>但是 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(Q(A)\)</span> 之间的任意环都是平坦的(这可以由 <strong>平坦模的等价刻画 6</strong> 得到)</p></blockquote><h3 id="going-up-and-going-down">Going-up and Going-down</h3><p>在这里还是重提以下 Going-up 和 Going-down 是什么鬼吧, 这部分之前一直糊里糊涂的过了.</p><p>设 <span class="math inline">\(\phi: A \to B\)</span> 是环同态. 我们说 Going-up 条件成立是指: 对任意 <span class="math inline">\(p \subset p’ \in Spec(A)\)</span>, 对任意在理想 <span class="math inline">\(p\)</span> 上的 <span class="math inline">\(P \in Spec(B)\)</span>(即<span class="math inline">\(P \cap A = p\)</span>). 都存在 <span class="math inline">\(P’ \in Spec(B)\)</span>, 使得 <span class="math inline">\(P’ \cap A = p’\)</span> 且 <span class="math inline">\(P \subset P’\)</span></p><blockquote><p>上面 <span class="math inline">\(p \subset p’\)</span> 是真包含, 若上述 <span class="math inline">\(P’\)</span> 存在, 包含关系必然也是真包含的.</p></blockquote><p>类似地, 我们说 Going-down 条件成立是指: 对任意 <span class="math inline">\(p \subset p’ \in Spec(A)\)</span>, 对任意在理想 <span class="math inline">\(p’\)</span> 上的 <span class="math inline">\(P’ \in Spec(B)\)</span>(即 <span class="math inline">\(P’ \cap A = p’\)</span>). 都存在 <span class="math inline">\(P \in Spec(B)\)</span>, 使得 <span class="math inline">\(P \cap A = p\)</span> 且 <span class="math inline">\(P \subset P’\)</span>. 这等价于: 对任意 <span class="math inline">\(p \in Spec(A)\)</span>, 对任意包含 <span class="math inline">\(pB\)</span> 的极小素理想 <span class="math inline">\(P\)</span> 都有 <span class="math inline">\(P \cap A = p\)</span>.</p><blockquote><p>上面 <span class="math inline">\(p \subset p’\)</span> 是真包含, 若上述 <span class="math inline">\(P\)</span> 存在, 包含关系必然也是真包含的.</p></blockquote><h4 id="平坦-going-down">平坦 Going-down</h4><p>设 <span class="math inline">\(\phi: A \to B\)</span> 是平坦映射, 则 <span class="math inline">\(\phi\)</span> 满足 Going-down 条件. <strong>Proof</strong>: 设 <span class="math inline">\(p’ \subset p \in Spec(A)\)</span>, <span class="math inline">\(P \in Spec(B)\)</span> 使得 <span class="math inline">\(P \cap A = p\)</span>. 则 <span class="math inline">\(B_P = B_p\)</span> 在局部环 <span class="math inline">\(A_p\)</span> 上平坦, 因此忠实平坦, 所以 <span class="math inline">\(Spec(B_P) \to Spec(A_p)\)</span> 是满的, 设 <span class="math inline">\(P^{\star} \ subset B_P\)</span> 满足 <span class="math inline">\(P^{\star} \cap A_p = p’A_p\)</span>. 则 <span class="math inline">\(P’ = P^{\star} \cap B\)</span> 即为所求.</p><h4 id="整-going-up">整 Going-up</h4><p>设 <span class="math inline">\(A \subset B\)</span> 是环, 且 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 上整. 则:</p><ol type="1"><li><span class="math inline">\(Spec(B) \to Spec(A)\)</span> 是满的</li><li><span class="math inline">\(B\)</span> 中在某个 <span class="math inline">\(Spec(A)\)</span> 上的所有素理想互不包含.</li><li>Going-up 条件成立.</li><li>若 <span class="math inline">\(A\)</span> 是局部环, <span class="math inline">\(p\)</span> 是唯一极大理想, 则 <span class="math inline">\(B\)</span> 中在 <span class="math inline">\(p\)</span> 上的素理想都是极大理想.</li></ol><p>先证<span class="math inline">\(4\)</span>: 设 <span class="math inline">\(\mathfrak{n}\)</span> 为 <span class="math inline">\(B\)</span> 的一个极大理想, 设 <span class="math inline">\(\mathfrak{m} = \mathfrak{n} \cap A\)</span>. <span class="math inline">\(\bar{B} = B / \mathfrak{n}\)</span> 是域, 并且在环 <span class="math inline">\(\bar{A} = A/\mathfrak{m}\)</span> 上整, 对 <span class="math inline">\(A\)</span> 中任意非零元 <span class="math inline">\(x\)</span>. <span class="math inline">\(1/x \in \bar{B}\)</span>. 因此 <span class="math display">\[(1/x)^n + a_1 (1/x)^{n-1} + \cdots a_n = 0\]</span> 所以 <span class="math inline">\(\frac{1}{x} = -(a_1 + a_2 x + a_n x^{n-1} \in A\)</span>. 即 <span class="math inline">\(\bar{A}\)</span> 是域, <span class="math inline">\(\mathfrak{m} = p\)</span> 为 <span class="math inline">\(A\)</span> 的唯一极大理想. 设 <span class="math inline">\(P \in Spec(B)\)</span> 使得 <span class="math inline">\(P \cap A = p\)</span>. 则 <span class="math inline">\(\bar{B} = B/P\)</span> 是整环, 且在域 <span class="math inline">\(\bar{A} = A/p\)</span> 上整, 易知 <span class="math inline">\(\bar{B}\)</span>也是域, 即 <span class="math inline">\(P\)</span> 是极大理想. 再证 <code>1, 2</code>: 对任意 <span class="math inline">\(p \in Spec(A)\)</span>. <span class="math inline">\(B_p = B \otimes _A A_p = (A-p)^{-1}B\)</span> 在 <span class="math inline">\(A_p\)</span> 上整且包含 <span class="math inline">\(A_p\)</span>. 又因为 <span class="math inline">\(B\)</span> 中在 <span class="math inline">\(p\)</span> 上的素理想与 <span class="math inline">\(B_p\)</span> 中在 <span class="math inline">\(pA_p\)</span> 的素理想一一对应, 在由 <code>4</code> 知道 它对应于 <span class="math inline">\(B_p\)</span> 中的极大理想, 因此 <code>1, 2</code>得证. 最后证明 <code>3</code>: 设 <span class="math inline">\(p \subset p’ \in Spec(A)\)</span>, <span class="math inline">\(P \in Spec(B)\)</span> 使得 <span class="math inline">\(P \cap A = p\)</span>, <span class="math inline">\(B/P\)</span> 包含 <span class="math inline">\(A/p\)</span> 且在其上整. 由 <span class="math inline">\(1\)</span> 知, 存在 <span class="math inline">\(P’/P\)</span> 使得 <span class="math inline">\(P’/P \cap A/p = p’/p\)</span>. 所以 <span class="math inline">\(P’ \in Spec(B)\)</span> 满足 <span class="math inline">\(P’ \cap B = p’\)</span>.</p><blockquote><p>一个有用的结论: 整环 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 上整, 则 <span class="math inline">\(B\)</span> 是域当且仅当 <span class="math inline">\(A\)</span> 是域.</p></blockquote><h3 id="代数几何中的-constructible-set">代数几何中的 Constructible Set</h3><h4 id="noetherian-空间">Noetherian 空间</h4><p>称一个拓扑空间 <span class="math inline">\(X\)</span> 为 Noetherian, 如果它满足闭集的降链条件, 等价于开集的升链条件. 显然有限个 Noetherian 空间的并还是 Noetherian 空间, Noetherian 空间的子空间还是 Noetherian 空间. Noetherian 空间是紧的.</p><blockquote><p>由于 Noetherian 环 <span class="math inline">\(A\)</span> 满足素理想的降链条件, 此时 <span class="math inline">\(Spec(A)\)</span> 是 Noetherian 空间.</p></blockquote><h4 id="不可约闭集irreducible-closed-set">不可约闭集(irreducible closed set)</h4><p>一个闭集称为不可约的, 如果它不能写成两个真闭子集的并.</p><blockquote><p>在 Noetherian 空间中, 每个闭集都可以写成有限个不可约闭子集的并. 并且这些不可约子集互不包含, 称每一个都为这个闭集的不可约部分.</p></blockquote><h4 id="局部闭集locally-closed">局部闭集(locally closed)</h4><p>一个集合 <span class="math inline">\(Z\)</span> 称为 locally closed 如果 <span class="math inline">\(\forall z \in Z, \quad \exists U_z\)</span> 使得 <span class="math inline">\(U_z \cap Z\)</span> 是开邻域 <span class="math inline">\(U_z\)</span> 中的闭集. 这等价于说 <span class="math inline">\(Z\)</span> 是拓扑空间 <span class="math inline">\(X\)</span> 中某个开集和闭集的交. 特别地, 开集和闭集都是 locally closed.</p><h4 id="noetherian-空间中-constructible-集">Noetherian 空间中 constructible 集</h4><p>设 <span class="math inline">\(X\)</span> 是一个 Noetherian 空间, 称集合 <span class="math inline">\(Z \subseteq\)</span> 是一个 constructible 集, 如果它是有限个 locally close 集合的并. (非 Noetherian 空间中也可以定义 constructible 集, 但是很复杂) 显然 constructible 集关于交并差都是封闭的.</p><p>设 <span class="math inline">\(X\)</span> 是一个 Noetherian 空间, 称集合 <span class="math inline">\(Z \subseteq\)</span> 是一个 pro-constructible(对应的 ind-constructible)集, 如果它是任意一族 constructible 集的交(对应的并).</p><p><strong>constructible 集</strong> 判定方法, Noetherian 空间 <span class="math inline">\(X\)</span> 的子集 <span class="math inline">\(Z\)</span> 称为 constructible 集的充要条件是: 对任意不可约闭子集 <span class="math inline">\(X_0 \subseteq X\)</span>, 若 <span class="math inline">\(X_0 \cap Z\)</span> 在 <span class="math inline">\(X_0\)</span> 中稠密, 则 <span class="math inline">\(X_0 \cap Z\)</span> 包含 <span class="math inline">\(X_0\)</span> 中某个非空开集. <strong>Proof</strong>: 必要性: 若 <span class="math inline">\(Z\)</span> 是 constructible 集, 则 <span class="math display">\[X_0 \cap Z = \bigcup _{i=1} ^m (U_i \cap F_i)\]</span> 其中 <span class="math inline">\(U_i\)</span> 是 <span class="math inline">\(X\)</span> 中开集, <span class="math inline">\(F_i\)</span> 是 <span class="math inline">\(X\)</span> 中不可约闭子集(这是可以做到的是因为 Noetherian 空间中闭集都可以写成有限个不可约闭集的并), 且 <span class="math inline">\(U_i \cap F_i\)</span> 是非空的(如果空就直接踢掉了). 则 <span class="math inline">\(\bar{U_i \cap F_i} = F_i\)</span>(这是因为否则 <span class="math inline">\(\bar{U_i \cap F_i} \cup (c(U_i) \cap F_i) = F_i\)</span>, 但是 <span class="math inline">\(F_i\)</span> 是不可约闭集). 因此 <span class="math display">\[X_0 = \bar{X_0 \cap Z} = \bigcup _{i=1} ^m F_i\]</span> 因此必有某个 <span class="math inline">\(F_i = X_0\)</span>. 从而 <span class="math inline">\(U_i \cap X_0 = U_i \cap F_i\)</span> 是 <span class="math inline">\(X_0\)</span> 中的一个非空开集. 充分性: 我们对 <span class="math inline">\(\bar{Z}\)</span> 进行应用所谓的超限数学归纳. 首先, <span class="math inline">\(\emptyset\)</span> 是 constructible 集, 其次假设 <span class="math inline">\(\bar{Z}\)</span> 中所有满足条件且 <span class="math inline">\(\bar{Z’} \subset \bar{Z}\)</span>(严格包含)的 <span class="math inline">\(Z’\)</span> 都是 constructible 集. 我们证明此时 <span class="math inline">\(Z\)</span> 也是 constructible 集: 设 <span class="math inline">\(\bar{Z} = F_1 \cup \dots \cup F_r\)</span> 是 <span class="math inline">\(\bar{Z}\)</span> 的不可约分解. 那么 <span class="math inline">\(\bar{F_1 \cap Z} = F_1\)</span>(毕竟不可约闭集). 因此, 由条件存在 <span class="math inline">\(F_1\)</span> 中的真子集 <span class="math inline">\(F_1’\)</span> 使得 <span class="math inline">\(\emptyset \neq F_1 - F_1’ \subseteq Z\)</span>. 此时定义 <span class="math inline">\(F^{\star} = F_1’ \cap F_2 \cap cdots \cap F_r\)</span>. 那么 <span class="math inline">\(Z = (F_1 - F_1’) \cup (Z \cap F^{\star})\)</span>. 由于 <span class="math inline">\(F_1 - F_1’\)</span> 是 locally closed, 又因为 <span class="math inline">\(Z \cap F^{\star}\)</span> 满足条件: 若 <span class="math inline">\(X_0\)</span> 是不可约闭集且 <span class="math inline">\(X_0 = \bar{Z \cap F^{\star} \cap X_0} \subseteq \bar{F^{\star}} = F^{\star}\)</span>, 从而 <span class="math inline">\(Z \cap F^{\star} \cap X_0 = Z \cap X_0\)</span> 从而包含 <span class="math inline">\(X_0\)</span> 中的一个非空开集. 并且 <span class="math inline">\(\bar{Z \cap F^{\star}} \subseteq F^{\star} \subset Z\)</span>. 由数学归纳知 <span class="math inline">\(Z \cap F^{\star}\)</span> 是 constructible 集. 从而 <span class="math inline">\(Z = (F_1 - F_1’) \cup (Z \cap F^{\star})\)</span> 是 constructible 集.</p><blockquote><p>以上结果对一般地 Noetherian 空间都成立.</p></blockquote><h4 id="考察上述定义在-speca-上的具体表现">考察上述定义在 <span class="math inline">\(Spec(A)\)</span> 上的具体表现</h4><p><strong><span class="math inline">\(Spec(A)\)</span> 中的不可约闭集</strong>: 设 <span class="math inline">\(F\)</span> 是 <span class="math inline">\(Spec(A)\)</span> 中的闭集, 则 <span class="math inline">\(F\)</span> 不可约当且仅当, <span class="math inline">\(F = V(p)\)</span>, 其中 <span class="math inline">\(p \in Spec(A)\)</span>, 可以看出此时 <span class="math inline">\(p\)</span> 由 <span class="math inline">\(F\)</span> 唯一决定。 充分性由 <span class="math inline">\(p \in V(p)\)</span> 显然. 必要性. <span class="math inline">\(F = V(I)\)</span>. 若 <span class="math inline">\(I\)</span> 不是素理想, 则存在 <span class="math inline">\(a, b \notin I, ab \in I\)</span>, 即<span class="math inline">\(F = (F \cap V(a)) \cup (F \cap V(b))\)</span>. 矛盾于 <span class="math inline">\(F\)</span> 不可约.设 <span class="math inline">\(\phi: A \to B\)</span> 是环同态, 设 <span class="math inline">\(X = Spec(A), Y = Spec(B)\)</span>, 由自然的 <span class="math inline">\(f: Y \to A\)</span>. 那么 <span class="math inline">\(f(Y)\)</span> 在 <span class="math inline">\(X\)</span> 中稠密, 当且仅当 <span class="math inline">\(\ker(\phi) \subseteq nil(A)\)</span>. 特别地, 当 <span class="math inline">\(A\)</span> reduce 时, <span class="math inline">\(f(Y)\)</span> 在 <span class="math inline">\(X\)</span> 中稠密, 当且仅当 <span class="math inline">\(\phi\)</span> 是单同态. 证明 <span class="math inline">\(\bar{f(Y)} = V(I)\)</span>, 其中 <span class="math inline">\(I = \bigcap_{p \in Y} \phi^{-1}(p) = \phi^{-1}(\bigcap_{p \in Y} p) = \phi^{-1}(nil(B))\)</span>. 显然 <span class="math inline">\(\ker(\phi) \subseteq I\)</span>. 若 <span class="math inline">\(f(Y)\)</span> 在 <span class="math inline">\(X\)</span> 中稠密, 则 <span class="math inline">\(V(I) = X\)</span>. 因此 <span class="math inline">\(I \subseteq nil(A)\)</span>, 从而 <span class="math inline">\(\ker(\phi) \subseteq nil(A)\)</span>. 另一方面, 若 <span class="math inline">\(\ker(\phi) \subseteq nil(A)\)</span>, 则 <span class="math inline">\(I = \phi^{-1}(nil(B)) \subseteq nil(A)\)</span>. 从而 <span class="math inline">\(\bar{f(Y)} = X\)</span>.</p><blockquote><p>之前提到了, <span class="math inline">\(Spec\)</span> 是环范畴到拓扑范畴的逆变函子, 现在是说, 这个拓扑空间的一些性质可以与环的一些性质有一个对应关系, 这个函子保持了很好的性质.</p></blockquote><p>之前关于 constructible 集的定义都是在 Noetherian 空间中考虑的, 因此我们下面考虑的环一般是 Noetherian 环:</p><p><strong>(Chevalley)</strong> 设 <span class="math inline">\(A\)</span> 是 Noetherian 环, <span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 上的有限生成代数(从而也是 Noetherian 环). 设 <span class="math inline">\(\phi: A \to B\)</span> 是自然映射, 记 <span class="math inline">\(X = Spec(A), Y = Spec(B)\)</span> 则 <span class="math inline">\(f: Y \to X\)</span>. 则 <span class="math inline">\(f\)</span> 将 <span class="math inline">\(Y\)</span> 中 constructible 集 映成 <span class="math inline">\(X\)</span> 中的 constructible 集.</p><blockquote><p>先证明 <span class="math inline">\(f(Y)\)</span> 是 constructible 集, 在利用下面的引理.</p></blockquote><p>另一方面设 <span class="math inline">\(A\)</span> 是 Noetherian 环, <span class="math inline">\(X’\)</span> 是 <span class="math inline">\(X = Spec(A)\)</span>中的 constructible 集, 那么存在 <span class="math inline">\(A\)</span> 的有限生成代数 <span class="math inline">\(B\)</span> 使得 <span class="math inline">\(Spec(B)\)</span> 在 <span class="math inline">\(Spec(A)\)</span> 中的像恰好是 <span class="math inline">\(X’\)</span>.</p><blockquote><p>对于 <span class="math inline">\(X’ = D(a) \cap V(I)\)</span>, 然后考虑 <span class="math inline">\(B = \lbrace 1,a,a^2,\cdots \rbrace ^{-1} (A/I)\)</span>, 然后考虑 constructible 集.</p></blockquote><p><strong>pro-constructible 集</strong> 设 <span class="math inline">\(A\)</span> 是 Noetherian 环, <span class="math inline">\(\phi: A \to B\)</span>, <span class="math inline">\(\bar{\phi}(Spec(B))\)</span> 是 <span class="math inline">\(Spec(A)\)</span> 中的 pro-constructible 集.</p><h4 id="f-specb-to-speca成为开闭连续映射"><span class="math inline">\(f: spec(B) \to Spec(A)\)</span>成为(开,闭)连续映射</h4><p>设<span class="math inline">\(A\)</span>是 Noetherian 环, <span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 上的有限生成代数, 假设它们之间的自然映射 <span class="math inline">\(\phi: A \to B\)</span> 满足 Going-down 条件, 则对应的自然映射 <span class="math inline">\(f: Spec(B) \to Spec(A)\)</span> 是开(连续)映射.</p><blockquote><p>设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(Spec(B)\)</span> 中开集, 则 <span class="math inline">\(f(U)\)</span> 是 constructible 集, 再由 Going-down 条件知道 <span class="math inline">\(Spec(A) - f(U)\)</span> 是闭集.</p></blockquote><p>设 <span class="math inline">\(\phi: A \to B\)</span> 满足 Going-up 条件, 且 <span class="math inline">\(B\)</span> 是 Noetherian 环, 则 <span class="math inline">\(f: Spec(B) \to Spec(A)\)</span> 是闭映射.</p><h3 id="noetherian-环上的-associated-primes">Noetherian 环上的 Associated Primes</h3><p>给定一个 Noetherian 环上的模 <span class="math inline">\(M\)</span>, 我们称 <span class="math inline">\(A\)</span> 的一个素理想为 <span class="math inline">\(M\)</span> 的 associated prime, 如果它满足下面等价的条件:</p><ol type="1"><li><span class="math inline">\(\exists x \in M\)</span> 使得 <span class="math inline">\(Ann(x) = p\)</span>;</li><li><span class="math inline">\(M\)</span> 包含一个子模同构于 <span class="math inline">\(A/p\)</span>.</li></ol><p>我们把 <span class="math inline">\(M\)</span> 中所有的 associated prime ideal 记为 <span class="math inline">\(Ass(M)\)</span>. 有时也用 <span class="math inline">\(Ass_A(M)\)</span> 来防止歧义.</p><blockquote><p>由下面三个结论说明, <span class="math inline">\(Ass(M)\)</span> 确实是 <span class="math inline">\(M\)</span> 的一个重要不变量.</p><p>(本节)环默认为 Noetherian 环.</p></blockquote><h4 id="annx-全体中的极大元在-assm-中"><span class="math inline">\(Ann(x)\)</span> 全体中的极大元在 <span class="math inline">\(Ass(M)\)</span> 中</h4><p>设 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\lbrace Ann(X) \mid 0 \neq x \in M \rbrace\)</span>. 则 <span class="math inline">\(p \in Ass(M)\)</span></p><p>由上, 显然可知道 <span class="math inline">\(Ass(M) = \emptyset \Longleftrightarrow M=0\)</span>. 即 <span class="math inline">\(Ass(M)\)</span> 是元素是十分丰富的. <span class="math inline">\(M\)</span> 中的零因子是 <span class="math inline">\(Ass(M)\)</span> 中元素的并.</p><h4 id="assm-与局部化可交换"><span class="math inline">\(Ass(M)\)</span> 与局部化可交换</h4><p>给定一个乘闭子集 <span class="math inline">\(S\)</span>, 记 <span class="math inline">\(A’ = S^{-1}A, M’ = S^{-1} B\)</span>, 则 <span class="math display">\[Ass_A(M’) = f(Ass_{A’}(M’) = Ass_A(M) \cap \lbrace p \mid p \cap S = \emptyset \rbrace\]</span> 其中 <span class="math inline">\(f: Spec(A’) \to Spec(A)\)</span> 为自然映射.</p><h4 id="suppm-的极小元全体等于-assm-的极小元全体"><span class="math inline">\(Supp(M)\)</span> 的极小元全体等于 <span class="math inline">\(Ass(M)\)</span> 的极小元全体</h4><p><span class="math inline">\(Ass(M) \subset Supp(M)\)</span> 且 <span class="math inline">\(Supp(M)\)</span> 中的极小元在 <span class="math inline">\(Ass(M)\)</span> 中(从而 <span class="math inline">\(Supp(M)\)</span> 的极小元全体等于 <span class="math inline">\(Ass(M)\)</span> 的极小元全体). <strong>Proof</strong>: 设 <span class="math inline">\(p \in Ass(M)\)</span>, 则由正合列 <span class="math inline">\(0 \to A/p \to M\)</span>, 从而 <span class="math inline">\(0 \to A_p/pA_p \to M_p\)</span> 正合. 由 <span class="math inline">\(A_p/pA_p \neq 0\)</span>, 从而 <span class="math inline">\(M_p \neq 0\)</span>, 从而 <span class="math inline">\(p \in Supp(M)\)</span>. 设 <span class="math inline">\(p \in Supp(M)\)</span>, 由于局部化和 <span class="math inline">\(Ass(M)\)</span> 可交换, <span class="math inline">\(p \in Ass_A(M)\)</span> 等价于 <span class="math inline">\(pA_p \in Ass_{A_p}(M_p)\)</span>. 因此, 我们不妨设 <span class="math inline">\((A, p)\)</span> 是局部环, <span class="math inline">\(M \neq 0\)</span>. 且对任意 <span class="math inline">\(q \subset p, M_q = 0\)</span>, 即 <span class="math inline">\(Supp(M) = \lbrace p \rbrace\)</span>. 由于 <span class="math inline">\(Ass(M)\)</span> 非空, 且包含于 <span class="math inline">\(Supp(M)\)</span> 中, 因此 <span class="math inline">\(p \in Ass(M)\)</span>.</p><blockquote><p>设 <span class="math inline">\(I\)</span> 是 <span class="math inline">\(A\)</span> 的理想, 则 <span class="math inline">\(Ass(A/I)\)</span> 中的极小元全体为包含 <span class="math inline">\(I\)</span> 的极小素理想全体. 从而 <span class="math inline">\(\bigcap _{p \in Ass(A/I)} p = \sqrt{I}\)</span></p></blockquote><p>若 <span class="math inline">\(0 \to M’ \to M \to M’’\)</span> 是 <span class="math inline">\(A\)</span>-模正合列, 则 <span class="math inline">\(Ass(M) \subset Ass(M’) \cup Ass(M’’)\)</span> <strong>Proof</strong>: 设 <span class="math inline">\(p \in Ass(M)\)</span>, 则存在 <span class="math inline">\(N \subseteq M\)</span> 使得 <span class="math inline">\(N \simeq A/p\)</span>. 若 <span class="math inline">\(N \cap M’ = 0\)</span>(本质上是和 <span class="math inline">\(f(M’)\)</span> 的交). 则 <span class="math inline">\(N\)</span> 同构于 <span class="math inline">\(M’’\)</span> 的一个子模, 因此 <span class="math inline">\(p \in Ass(M’’)\)</span>. 若 <span class="math inline">\(N \cap M’ \neq 0\)</span>, 则任取 <span class="math inline">\(0 \neq x \in N \cap M’\)</span>, 则 <span class="math inline">\(Ann(x) = p\)</span>.</p><p>设 <span class="math inline">\(M \neq 0\)</span> 是 Noetherian 环上的有限生成模, 则存在(长为 <span class="math inline">\(n\)</span> 的)子模链 <span class="math inline">\((0) = M_0 \subset \cdots \subset M_{n-1} \subset M_n = M\)</span> 使得 <span class="math inline">\(M_i / M_{i-1} = A/p_i\)</span>, 其中 <span class="math inline">\(p_i \in Spec(A)\)</span>. 从而 <span class="math inline">\(Ass(M) \subset \lbrace p_1 \cdots p_n \rbrace\)</span> 是有限集. <strong>Proof</strong>: 由 <span class="math inline">\(M \neq 0\)</span> 则 <span class="math inline">\(Ass(M) \neq \emptyset\)</span>, 选择 <span class="math inline">\(M_1 \subseteq M\)</span>, 使得 <span class="math inline">\(M_1 \simeq A/p_1\)</span>, 若 <span class="math inline">\(M_1 \neq M\)</span>, 再对 <span class="math inline">\(M/M_1\)</span> 做同样的事情, 由于 <span class="math inline">\(M\)</span> 是 Noetherian 的, 因此次过程在有限步后终止. 又因为 <span class="math display">\[Ass(M) \subseteq Ass(M_1) \cup Ass(M_2/M_1) \cup \cdots \cup Ass(M_n /M_{n-1})\]</span> 再由 <span class="math inline">\(Ass(M_i/M_{i-1}) = Ass(A/p_i)=p_i\)</span> 知结论成立.</p><h3 id="primary-decomposition准素分解">Primary Decomposition(准素分解)</h3><blockquote><p>本节设 <span class="math inline">\(M\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 上的模.</p></blockquote><p>称一个 <span class="math inline">\(A\)</span>-模是 <strong>co-primary</strong> 如果它仅有一个 associated prime ideal. <span class="math inline">\(N \subseteq M\)</span> 称为 <span class="math inline">\(M\)</span> 的 primary 子模, 如果 <span class="math inline">\(M/N\)</span> 是 co-primary. 若 <span class="math inline">\(Ass(M/N) = \lbrace p \rbrace\)</span>, 则称 <span class="math inline">\(N\)</span> 为 <span class="math inline">\(p\)</span>-primary 或称 <span class="math inline">\(N\)</span> 属于 <span class="math inline">\(p\)</span>(的 primary submodule).</p><h4 id="co-primary-等价刻画">co-primary 等价刻画</h4><p><span class="math inline">\(M\)</span> 是 co-primary 的, 当且仅当 <span class="math inline">\(M \neq 0\)</span>, 且若 <span class="math inline">\(a \in A\)</span> 是 <span class="math inline">\(M\)</span> 的零因子, 则 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(M\)</span> 上 locally nilpotent(<span class="math inline">\(\forall x \in M, \exists n\)</span>, such that <span class="math inline">\(a^n x = 0\)</span>). <strong>Proof</strong>: 若 <span class="math inline">\(Ass(M) = \lbrace p \rbrace\)</span>, 则对任意 <span class="math inline">\(x \in M\)</span>, <span class="math inline">\(Ass(Ax) \subseteq Ass(M) = \lbrace p \rbrace\)</span>, 若 <span class="math inline">\(Ass(Ax) = \emptyset\)</span>(取 <span class="math inline">\(n = 1\)</span> 即可), 若 <span class="math inline">\(Ass(Ax) = \lbrace p \rbrace\)</span>. 因此 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(Supp(Ax) = V(Ann(x))\)</span> 中唯一的极小元素. 即 <span class="math inline">\(p = \sqrt{Ann(x)}\)</span>. 另一方面, 定义 <span class="math inline">\(p = \lbrace a \in A \mid a \text{在} M \text{上 locally nilpotent} \rbrace\)</span>. 它显然是一个理想. 对任意 <span class="math inline">\(q \in Ass(M)\)</span>, 存在 <span class="math inline">\(x \in M\)</span> 使得 <span class="math inline">\(q = Ann(x)\)</span>. 因此 <span class="math inline">\(p \subseteq \sqrt{q} = q\)</span>. 另一方面由于 <span class="math inline">\(p\)</span> 为所有 associated prime 理想的并, 因为 <span class="math inline">\(q \subseteq p\)</span>. 从而 <span class="math inline">\(Ass(M) = \lbrace p \rbrace\)</span>.</p><blockquote><p>当 <span class="math inline">\(M = A/q\)</span> 时, 上述条件恰好就是 <span class="math inline">\(q\)</span> 为准素理想的定义.</p></blockquote><h4 id="p-primary-的交依然是-p-primary">p-primary 的交依然是 p-primary</h4><p>设 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(A\)</span> 的素理想, <span class="math inline">\(Q_1, Q_2\)</span> 是 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(p\)</span>-primary 子模. 则 <span class="math inline">\(Q_1 \cap Q_2\)</span> 也是 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(p\)</span>-primary 子模.</p><blockquote><p>由 <span class="math inline">\(0 \to M / Q_1 \cap Q_2 \to M/Q_1 \oplus M/Q_2\)</span> 显然</p></blockquote><h4 id="准素分解闪亮登场">准素分解闪亮登场</h4><p>设 <span class="math inline">\(N\)</span> 是 <span class="math inline">\(M\)</span> 的一个子模, 我们称 <span class="math inline">\(N = Q_1 \cap \cdots \cap Q_r\)</span> 是 <span class="math inline">\(N\)</span> 的一个准素分解, 如果 <span class="math inline">\(Q_i\)</span> 是 <span class="math inline">\(M\)</span> 中的 primary 子模. 我们称一个准素分解是 irredundant 如果每个准素子模都不能去掉, 并且 <span class="math inline">\(Ass(M/Q_i)\)</span> 各不相同. 对于任意准素分解, 我们都可以通过有限次剔除之后使得它的每一个准素子模都不可去掉, 而如果有两个准素子模属于相同的 associated prime <span class="math inline">\(p\)</span>, 则我们可以把它们交起来构成一个新的准素子模, 从而可知</p><blockquote><p>任意准素分解都可以化成 irredundant 准素分解.</p></blockquote><p>设 <span class="math inline">\(N = Q_1 \cap \cdots \cap Q_r\)</span> 是 <span class="math inline">\(N\)</span> 的一个 irredundant 准素分解, 若 <span class="math inline">\(Q_i\)</span> 属于 <span class="math inline">\(p_i\)</span>. 则 <span class="math inline">\(Ass(M/N) = \lbrace p_1 \cdots p_r \rbrace\)</span>. <strong>Proof</strong>: 由自然单同态 <span class="math inline">\(0 \to M/Q_1 \oplus \cdots \oplus M/Q_r\)</span>. 因此 <span class="math inline">\(M/N \subseteq \cup Ass(M/Q_i) = \lbrace p_1 \cdots p_r \rbrace\)</span>. 另一方面 <span class="math inline">\((Q_2 \cap \cdots \cap Q_r)/N\)</span> 同构于 <span class="math inline">\(M/Q_1\)</span> 的子模, 从而 <span class="math inline">\(Ass(Q_2 \cap \cdots \cap Q_r)/N) = \lbrace p_1 \rbrace\)</span>. 从而 <span class="math inline">\(p_1 \in Ass(M)\)</span>. 其它的类似.</p><p>设 <span class="math inline">\(N\)</span> 是 <span class="math inline">\(M\)</span> 的一个 <span class="math inline">\(p\)</span>-primary 子模. 设 <span class="math inline">\(q\)</span> 是一个理想. 若 <span class="math inline">\(p \subseteq q\)</span>, 则 <span class="math inline">\(N = M \cap N_q\)</span>, 反之 <span class="math inline">\(N_q = M_q\)</span>. <strong>Proof</strong>: 由于 <span class="math inline">\(Ass(M/N) = \lbrace p \rbrace\)</span>. 若 <span class="math inline">\(p \subseteq q\)</span>, 则 <span class="math inline">\(A-q\)</span> 中无 <span class="math inline">\(M/N\)</span> 的零因子, 即 <span class="math inline">\(M/N \to (M/N)_q = M_q / N_q\)</span> 是单射, 从而 <span class="math inline">\(N = M \cap N_q\)</span>. 反之 <span class="math inline">\(Ass(M_q/N_q) = Ass(M/N) \cap \lbrace \text{包含于} p \text{的素理想} \rbrace = \emptyset\)</span>. 从而 <span class="math inline">\(M_q/N_q = 0\)</span>.</p><blockquote><p>推论 1: 若 <span class="math inline">\(N = Q_1 \cap \cdots \cap Q_r\)</span> 是 <span class="math inline">\(N\)</span> 的一个 irredundant 准素分解, 其中 <span class="math inline">\(p_1\)</span> 是 <span class="math inline">\(Ass(M/N)\)</span> 中的极小素理想. 则 <span class="math inline">\(Q_1 = M \cap N_{p_1}\)</span> 由 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(p_1\)</span> 决定. 推论 2: 设 <span class="math inline">\(I\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 的理想 <span class="math inline">\(N = \sqrt{I}\)</span>(有限生成). 则存在 <span class="math inline">\(n \in \mathbb{N}\)</span> 使得 <span class="math inline">\(N^n \subseteq I\)</span>. 特别地若 <span class="math inline">\(Q\)</span> 是 <span class="math inline">\(R\)</span> 的 <span class="math inline">\(p\)</span> 准素理想, 则存在 <span class="math inline">\(n \in \mathbb{N}\)</span> 使得 <span class="math inline">\(P^n \subseteq Q \subset P\)</span>.</p></blockquote><p><strong>准素分解</strong> 设 <span class="math inline">\(M\)</span> 是(Noetherian 环) <span class="math inline">\(A\)</span>-模. 对每个 <span class="math inline">\(p \in Ass(M)\)</span>, 我们可以选取 <span class="math inline">\(p\)</span>-primary 子模 <span class="math inline">\(Q(p)\)</span>, 使得 <span class="math display">\[(0) = \bigcap_{p \in Ass(M)} Q(p)\]</span> <strong>Proof</strong>: 给定一个 <span class="math inline">\(p \in Ass(M)\)</span>, 我们考虑 <span class="math inline">\(M\)</span> 的一些子模构成的集合: <span class="math inline">\(\mathfrak{N} = \lbrace N \subseteq M \mid p \notin Ass(N) \rbrace \neq \emptyset\)</span>( <span class="math inline">\((0)\)</span> 在其中). 由 Zorn 引理可知其存在极大元 <span class="math inline">\(Q(p) \neq M\)</span>. 由 <span class="math inline">\(Q(p)\)</span> 的极大性, 知道 <span class="math inline">\(Ass(M/Q(p) = \lbrace p \rbrace\)</span>. 从而 <span class="math display">\[Ass(\bigcap_{p \in Ass(M)} Q(p)) = \bigcap_{p \in Ass(M)} Ass(Q(p)) = \emptyset\]</span> 由上可知, 若 <span class="math inline">\(M\)</span> 有限生成, 则将上面定理应用于 <span class="math inline">\(M/N\)</span>, 再由 <span class="math inline">\(Ass(M/N)\)</span> 是有限集, 从而 <span class="math inline">\(N\)</span> 有 primary decomposition.</p><h3 id="分次环和分次模">分次环和分次模</h3><p><strong>分次环</strong>：称 <span class="math inline">\(A = \bigoplus _{n \geq 0} A_n\)</span> 是分次环, 如果 <span class="math inline">\(A_n\)</span> 是 <span class="math inline">\(A\)</span> 的加法子群, 且 <span class="math inline">\(A_n A_m \subseteq A_{m+n}\)</span>. 我们称 <span class="math inline">\(A_n\)</span> 中的非零元素 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(n\)</span> 次齐次元, 并记作 <span class="math inline">\(\deg x = n\)</span>.</p><blockquote><p><span class="math inline">\(A_0\)</span> 是 <span class="math inline">\(A\)</span> 的子环. 例子: <span class="math inline">\(A = F[x_1, \cdots x_m]\)</span>, 其中 <span class="math inline">\(A_i\)</span> 是 <span class="math inline">\(i\)</span> 次单项式生成的子空间, 此时 <span class="math inline">\(A\)</span> 成为了分次环.</p></blockquote><p><strong>分次模</strong>：称分次环 <span class="math inline">\(A = \bigoplus _{n \geq 0} A_n\)</span> 上的模 <span class="math inline">\(M\)</span> 称为分次 <span class="math inline">\(A\)</span>-模, 如果 <span class="math inline">\(M = \bigoplus _{n \geq 0} M_n\)</span> 满足 <span class="math inline">\(M_n\)</span> 是加群直和, 且 <span class="math inline">\(A_n M_m \subseteq M_{m+n}\)</span></p><p>设 <span class="math inline">\(A = \bigoplus _{n \geq 0} A_n\)</span>, 则</p><ol type="1"><li>环 <span class="math inline">\(A\)</span> 是 Noetherian 当且仅当 <span class="math inline">\(A_0\)</span> 是 Noetherian, 且 <span class="math inline">\(A\)</span> 作为 <span class="math inline">\(A_0\)</span> 代数式有限生成的.</li><li>若环 <span class="math inline">\(A\)</span> 是 Noetherian, <span class="math inline">\(M_A\)</span> 是有限生成分次 <span class="math inline">\(A\)</span>-模, 则对任意 <span class="math inline">\(n, M_n\)</span> 是有限生成 <span class="math inline">\(A_0\)</span>-模.</li></ol><p><strong>Proof</strong>:</p><ol type="1"><li>充分性显然, <span class="math inline">\(A_+ = \bigoplus_{n \geq 1} A_n\)</span> 是 <span class="math inline">\(A\)</span> 的一个理想, 且 <span class="math inline">\(A/A_+ \simeq A_0\)</span> 是环同构, 于是 <span class="math inline">\(A_0\)</span> 是 Noetherian 环. 由 <span class="math inline">\(A_+\)</span> 作为理想是有限生成的. 设 <span class="math inline">\(A_+ = Au_1 + \cdots + Au_m\)</span>, 其中每个 <span class="math inline">\(u_i\)</span> 都是齐次元. 下面用数学归纳法证明 <span class="math inline">\(A = A_0[u_1,\cdots,u_m]\)</span>, 从而 <span class="math inline">\(A\)</span> 是有限生成 <span class="math inline">\(A\)</span>-代数. 显然 <span class="math inline">\(A_0 \subseteq A_0[u_1,\cdots,u_m]\)</span>. 设 <span class="math inline">\(n &gt; 0, 0 \neq u \in A_n \subseteq A_+\)</span>, 从而可设 <span class="math inline">\(u = \sum_{i=1} ^m a_i u_i\)</span>, 通过比较次数, 不妨设 <span class="math inline">\(a_i\)</span> 都是齐次元, 且 <span class="math inline">\(\deg a_i + \deg u_i = n\)</span>. 于是 <span class="math inline">\(\deg a_i &lt; n\)</span>. 由归纳假设 <span class="math inline">\(a_i \in A_0[u_1, \cdots, u_m]\)</span>. 从而 <span class="math inline">\(u \in A_0[u_1, \cdots, u_m]\)</span>, 即 <span class="math inline">\(A_n \subseteq A_0[u_1, \cdots, u_m]\)</span>, 证毕.</li><li>由于 <span class="math inline">\(A=A_0[u_1, \cdots, u_m]\)</span>, 其中 <span class="math inline">\(u_i\)</span> 为齐次元. 设 <span class="math inline">\(M = Ay_1 + \cdots Ay_t\)</span>. 其中每个 <span class="math inline">\(y_i\)</span> 都是 <span class="math inline">\(M\)</span> 中的齐次元. 对任意 <span class="math inline">\(0 \neq m \in M_n\)</span>, 记 <span class="math inline">\(m = \sum_{i=1}^t a_i y_i\)</span>, 其中 <span class="math inline">\(a_i\)</span> 是齐次元. 且 <span class="math inline">\(\deg a_i + \deg y_i = n = \deg m\)</span>, 另一方面, 对任意 <span class="math inline">\(i\)</span>, <span class="math inline">\(A\)</span> 中阶为 <span class="math inline">\(n-\deg y_i\)</span> 的”单项式”(作为 <span class="math inline">\(u_1, \cdots, u_m\)</span> 的单项式)只有有限个, 又 <span class="math inline">\(M_n\)</span> 是 <span class="math inline">\(\lbrace f_i y_i \mid f_i \text{是} A \text{阶为} n - \deg y_i \text{单项式} \rbrace\)</span> 的 <span class="math inline">\(A_0\)</span> 线性组合. 所以 <span class="math inline">\(M_n\)</span> 是有限生成 <span class="math inline">\(A_0\)</span>-模.</li></ol><h4 id="次模的-poincare-数">次模的 Poincare 数</h4><p>设 <span class="math inline">\(A\)</span> 是分次 Noetherian 环, 且设 <span class="math inline">\(A_0\)</span> 是 Artinian 环. 如果 <span class="math inline">\(M_A\)</span> 是有限生成分次 <span class="math inline">\(A\)</span>-模, 则由上面结论知, 每一个 <span class="math inline">\(M_n\)</span> 都是有限生成 <span class="math inline">\(R_0\)</span>-模, 从而是有限长的. 记作 <span class="math inline">\(l(M_n)\)</span>. 记 <span class="math inline">\(P(M,t) = \sum_{n=0}^{\infty} l(M_n)t^n \in \mathbb{Z}[[t]]\)</span>, 称为 <span class="math inline">\(M\)</span> 的 Poincare 级数.</p><p>引理: 设 <span class="math inline">\(A\)</span> 是 Artin 环, 若 <span class="math inline">\(0 \to M_0 \to M_1 \to \cdots \to M_s \to 0\)</span> 是有限生成 <span class="math inline">\(A\)</span>-模正合列. 则 <span class="math inline">\(\sum_{i=1} ^s l(M_i) = 0\)</span> <strong>Proof</strong>: <span class="math inline">\(s=0,1\)</span> 时显然, <span class="math inline">\(s=2\)</span> 时, 由 <span class="math inline">\(0 \to M_0 \to M_1 \to M_2 \to 0\)</span>, 则有 <span class="math inline">\(l(M_1)=l(M_0)+l(M_2)\)</span>. 对于 <span class="math inline">\(M_i \to M_{i+1}\)</span> 有分解: <span class="math inline">\(M_i \to \text{Im} M_i \to 0\)</span> 以及 <span class="math inline">\(0 \to \text{Im} M_i \to M_{i+1}\)</span>. 于是有: <span class="math inline">\(l(M_k) = l(\text{Im} M_{k-1} + l(\text{Im} M_k)\)</span>. 累加可得到结论.</p><p>(Hilbert-Serre) 设 <span class="math inline">\(A\)</span> 是分次 Noetherian 环, <span class="math inline">\(A_0\)</span> 是 Artinian 环, 若 <span class="math inline">\(A = A_0[x_1, \cdots x_m]\)</span>, 其 <span class="math inline">\(deg x_i = e_i &gt; 0\)</span>, 则对任意有限生成分次 <span class="math inline">\(A\)</span>-模 <span class="math inline">\(M\)</span>, 存在某个多项式 <span class="math inline">\(f(t) \in \mathbb{Z}[t]\)</span>, 使得 <span class="math inline">\(P(M,t)\)</span> 为 <span class="math display">\[\frac{f(t)}{\prod_{i=1}^m (1-t^{e_{i}})}\]</span> 的有理展开. <img src="Hilbert.png" alt="证明过程" /></p><p><strong>(Hilbert-Serre)多项式</strong> 设 <span class="math inline">\(A\)</span> 是分次 Noetherian 环, <span class="math inline">\(A_0\)</span> 是 Artinian 环, 若 <span class="math inline">\(A = A_0[x_1, \cdots x_m]\)</span>, 其 <span class="math inline">\(deg x_i = 1\)</span>, 则对任意有限生成分次 <span class="math inline">\(A\)</span>-模 <span class="math inline">\(M\)</span>, 存在次数不超过 <span class="math inline">\(m-1\)</span> 的多项式 <span class="math inline">\(\bar{l}(t) \in \mathbb{Q}[t]\)</span>, 使得 <span class="math inline">\(n \gg 0\)</span> 时, <span class="math inline">\(\bar{l}(t) = l(M_n)\)</span>. <strong>Proof</strong>: 应用之前的结果, 以及 <span class="math inline">\(\frac{1}{(1-t)^k}\)</span> 的展开.</p><p>命题: 设 <span class="math inline">\(f(x) \in \mathbb{Q}[x]\)</span> 是一个 <span class="math inline">\(n\)</span> 次多项式. 则 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(n+1\)</span> 个相邻的整数取整数值当且仅当 <span class="math inline">\(f(x)\)</span> 是 <span class="math inline">\(C_x ^0 , C_x ^1, \cdots, C_x ^n\)</span> 的整线性组合. <strong>Proof</strong>: 设 <span class="math inline">\(f(x) = a_0 C_x ^0 + a_1 C_x ^1 + \cdots + a_n C_x ^n, a_i \in \mathbb{Q}\)</span>. 则 <span class="math inline">\(f(x+1) - f(x) = a_1 C_x ^0 + \cdots + a_n C_x ^{n-1}\)</span> 在 <span class="math inline">\(n\)</span> 个相邻的位置取整值. 由归纳假设可知 <span class="math inline">\(a_1, \cdots a_n \in \mathbb{Z}\)</span>, 从而 <span class="math inline">\(a_0 \in \mathbb{Z}\)</span>.</p><h4 id="ring-of-filtration">ring of filtration</h4><p>我们定义环<span class="math inline">\(A\)</span>的 filtration 为理想降链: <span class="math display">\[A = J_0 \supseteq J_1 \supseteq J_2 \supseteq \cdots\]</span> 满足<span class="math inline">\(J_n J_m \subseteq J_{n+m}\)</span>.</p><p>给定一个 filtration, 我们可以定义一个分次环 <span class="math inline">\(A’\)</span>(容易验证) <span class="math display">\[A’ = \oplus_{n=0} ^{\infty} J_n / J_{n+1}\]</span></p><p>特别地, 给定环 <span class="math inline">\(A\)</span> 的理想 <span class="math inline">\(I\)</span>, 它的幂定义了一个 filtration, 称为 <span class="math inline">\(I\)</span>-adic filtration, 对应的分次环记作 <span class="math inline">\(gr^I(A)\)</span>.</p><p>若 <span class="math inline">\(I\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 的一个理想, 则 <span class="math inline">\(gr^I(A)\)</span> 也是 Noetherian. <strong>Proof</strong>: 由于 <span class="math inline">\(I\)</span> 有限生成, <span class="math inline">\(I = a_1 A + \cdots a_r A\)</span>, <span class="math inline">\(A/I\)</span> Noetherian, 所以 <span class="math inline">\(gr^I(A) = A/I[\bar{a_1}, \cdots, \bar{a_r}]\)</span> 为 Noetherian.</p><h4 id="module-of-filtration">module of filtration</h4><p>设 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(A\)</span>-模, <span class="math inline">\(I\)</span> 是 <span class="math inline">\(A\)</span> 的理想, 定义 <span class="math inline">\(M\)</span> 的 filtration 为子模降链: <span class="math display">\[M = M_0 \supseteq M_1 \supseteq M_2 \supseteq \cdots \quad (\star)\]</span> 我们称 <span class="math inline">\((\star)\)</span> 为 <span class="math inline">\(I\)</span>-admissible 如果对任意 <span class="math inline">\(n\)</span> 成立 <span class="math inline">\(IM_n \subseteq M_{n+1}\)</span>. <span class="math inline">\(I\)</span>-adic 若 <span class="math inline">\(M_n = I^n M\)</span>, essential <span class="math inline">\(I\)</span>-adic 若 <span class="math inline">\((\star)\)</span> 是 <span class="math inline">\(I\)</span>-admissible 且存在 <span class="math inline">\(n_0\)</span>, 当 <span class="math inline">\(n &gt; n_0\)</span> 时, <span class="math inline">\(M_{n+1} = IM_n\)</span>.</p><p><strong>filtration topology</strong> 给定 <span class="math inline">\(M\)</span> 的一个 filtration <span class="math inline">\((\star)\)</span>, 我们可以定义 <span class="math inline">\(M\)</span> 上的拓扑: 对任意 <span class="math inline">\(x \in M\)</span>, <span class="math inline">\(x\)</span> 的领域基为 <span class="math inline">\(\lbrace x +M_n \mid n&gt;0 \rbrace\)</span>.</p><blockquote><p>显然上述拓扑是 Hausdorff 的当且仅当 <span class="math inline">\(\bigcap M_n = (0)\)</span>.</p></blockquote><p>若上述 filtration <span class="math inline">\((\star)\)</span> 是 <span class="math inline">\(I\)</span>-adic 的, 则称上述拓扑为 <span class="math inline">\(I\)</span>-adic 拓扑. 显然一个 essential <span class="math inline">\(I\)</span>-adic 拓扑也定义了 <span class="math inline">\(M\)</span> 上的一个 <span class="math inline">\(I\)</span>-adic 拓扑.</p><h4 id="rees-环">Rees 环</h4><p>设 <span class="math inline">\(I\)</span> 是 <span class="math inline">\(A\)</span> 的理想. 记 <span class="math inline">\(T(I) = A + Ix + I^2x^2 + \cdots \leq A[x]\)</span>. 称 <span class="math inline">\(T(I)\)</span> 为由理想 <span class="math inline">\(I\)</span> 决定的 Rees 环可看作是 <span class="math inline">\(A[x]\)</span> 的子代数</p><p>引理: 若 <span class="math inline">\(A\)</span> 是 Noetherian. 则 <span class="math inline">\(T(I)\)</span> 是 Noetherian. <strong>Proof</strong>: <span class="math inline">\(I = a_1 A + \cdots + a_r A\)</span>. 于是作为 <span class="math inline">\(A[x]\)</span> 的 <span class="math inline">\(A\)</span> 子代数. <span class="math inline">\(T(I) = A[a_1 x, \cdots, a_r x]\)</span> 是 <span class="math inline">\(A[x_1, \cdots, x_r]\)</span> 的商代数, 由 Hilbert 基定理, <span class="math inline">\(T(I)\)</span> 是 Noetherian 环。</p><h4 id="rees-模">Rees 模</h4><p>对于 <span class="math inline">\(M_A\)</span>, <span class="math inline">\(A[x] \otimes_A M\)</span> 是 <span class="math inline">\(A[x]\)</span>-模, 其中元素可以唯一表示 <span class="math inline">\(\sum_i x^i \otimes m_i\)</span>(和为有限和). 另一方面 <span class="math inline">\(M[x] = \lbrace \sum_i m_i x^i \text{ (有限和) } \mid m_i \in M \rbrace\)</span>. 于是 <span class="math inline">\(M[x]\)</span> 可自然地看做 <span class="math inline">\(A[x]\)</span>-模. 并且作为 <span class="math inline">\(R[x]\)</span>-模, 有同构 <span class="math display">\[M[x] = R[x] \otimes_R M, \quad \sum_i m_i x^i \mapsto \sum_i x^i \otimes m_i\]</span> 记 <span class="math inline">\(T_I(M) = M + MIx + MI^2x^2 \cdots \leq M[x]\)</span>. 作为 <span class="math inline">\(T(I)\)</span>-模, <span class="math inline">\(T_I(M)\)</span>可由 <span class="math inline">\(M\)</span> 生成, <span class="math inline">\(M = \sum_{j=1} ^s m_jA\)</span> 是有限生成 <span class="math inline">\(A\)</span>-模, 则 <span class="math inline">\(T_I(M) = \sum_{j=1} ^s m_j T(I)\)</span>是有限生成 <span class="math inline">\(T(I)\)</span>-模. 从而若 <span class="math inline">\(A\)</span> 是 Noetherian, <span class="math inline">\(M_R\)</span> 是有限生成模, 则 <span class="math inline">\(T_I(M)\)</span> 是 Noetherian <span class="math inline">\(T(I)\)</span>-模.</p><h4 id="artin-rees-引理">Artin-Rees 引理</h4><p>设 <span class="math inline">\(I\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 的理想, <span class="math inline">\(M\)</span> 是有限生成 <span class="math inline">\(A\)</span>-模. <span class="math inline">\(M_1, M_2\)</span> 是 <span class="math inline">\(M\)</span> 的子模. 则存在 <span class="math inline">\(k \in \mathbb{N}\)</span> 使得对任意 <span class="math inline">\(n \geq k\)</span>, <span class="math display">\[I^n(M_1 \cap M_2) \subseteq I^nM_1 \cap M_2 = I^{n-k}(I^k M_1 \cap M_2) \subseteq I^{n-k}(M_1 \cap M_2)\]</span> <strong>Proof</strong>: 只需证明存在 <span class="math inline">\(k\)</span> 使得对任意 <span class="math inline">\(n \geq k\)</span>, <span class="math inline">\(I^nM_1 \cap M_2 \subseteq I^{n-k}(I^k M_1 \cap M_2)\)</span>(其它都包含关系显然). 考虑 Rees 环 <span class="math inline">\(T(I)\)</span> 及 Rees 模 <span class="math inline">\(T_I(M)\)</span>, 以及 <span class="math inline">\(T_I(M)\)</span> 的子模 <span class="math inline">\(N = M_1 \cap M_2 + (IM_1 \cap M_2)x + \cdots + (I^n M_1 \cap M_2)+ \cdots\)</span>. 由 <span class="math inline">\(T_I(M)\)</span> 是 Noetherian 模, <span class="math inline">\(N_{T(I)}\)</span>是有限生成模. 不妨设 <span class="math inline">\(N = T(I)u_0 + T(I)u_1 x + \cdots T(I) u_k x^k\)</span>, 其中 <span class="math inline">\(u_j \in I^j M_1 \cap M_2\)</span>. 对任意 <span class="math inline">\(n \geq k, u \in I^n M_1 \cap M_2\)</span> 我们有 <span class="math inline">\(ux^n \in (I^n M_1 \cap M_2)x^n \subseteq N\)</span>. 于是存在 <span class="math inline">\(f_j \in T(I)\)</span>, 使得 <span class="math inline">\(ux^n = \sum_{j=1} ^k f_j u_j x^j\)</span>. 比较 <span class="math inline">\(x^n\)</span> 的系数, 得到 <span class="math inline">\(u = \sum_{j=1} ^k f_j’ u_j\)</span>. 其中 <span class="math inline">\(f_j’ \in I^{n-j}\)</span>. 由于 <span class="math display">\[I^{n-j}(I^jM_1 \cap M_2 = I^{n-k}I^{k-j}(I^jM_1 \cap M_2 \subseteq I^{n-k}(I^k M_1 \cap M_2)\]</span> 从而 <span class="math inline">\(u \in I^{n-k}(I^k M_1 \cap M_2)\)</span>. 证毕.</p><blockquote><p>取 <span class="math inline">\(M_1 = M, M_2 = N \leq M\)</span> 我们可以得到: 设 <span class="math inline">\(I\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 的理想, <span class="math inline">\(N\)</span> 是有限生成模 <span class="math inline">\(M\)</span> 的子模, 则存在 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\(n \geq k\)</span> 时, <span class="math display">\[I^n N \subseteq I^n M \cap N = I^{n-k}(I^k M \cap N) \subset I^{n-k}N\]</span></p></blockquote><p><strong>Krull 交定理</strong>：设 <span class="math inline">\(I\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 的理想, <span class="math inline">\(M\)</span> 是有限生成 <span class="math inline">\(A\)</span>-模, 记 <span class="math inline">\(I^w M = \cap {n=1} ^{\infty} I^n M\)</span>, 则 <span class="math inline">\(I(I^w M) = I^w M\)</span>, 从而 <span class="math inline">\(I^w M = \lbrace x \in M \mid \exists b \in I, x = bx \rbrace\)</span>. 取 <span class="math inline">\(M_1 = M, M_2 = I^w M\)</span>, 则存在 <span class="math inline">\(k\)</span>, 使得当 <span class="math inline">\(n \geq k\)</span> 时 <span class="math display">\[I^w M =  I^n M \cap I^w M = I^{n-k}(I^k M \cap I^w M) = I^{n-k} (I^w M)\]</span> 所以 <span class="math inline">\(I^w M = I(I^w M)\)</span>. 显然 <span class="math inline">\(\lbrace x \in M \mid \exists b \in I, x = bx \rbrace \subseteq I^w M\)</span>. 另一方面 <span class="math inline">\(I^w M = I(I^w M)\)</span> 当且仅当 <span class="math inline">\(I + Ann(I^w M) = A\)</span>. 这是存在 <span class="math inline">\(b \in I\)</span>, 使得 <span class="math inline">\(1-b \in Ann(I^w M)\)</span>. 即对任意 <span class="math inline">\(x \in I^w M , x=bx\)</span>.</p><blockquote><p>当 <span class="math inline">\(A\)</span> 是 Noetherian 整环时, <span class="math inline">\(I^w M = \cap {n=1} ^{\infty} I^n M =(0)\)</span> 当 <span class="math inline">\(I \subseteq J(A)\)</span> 时, <span class="math inline">\(I^w M = \cap {n=1} ^{\infty} I^n M =(0)\)</span> 特别地, 当 <span class="math inline">\(A\)</span> 是 Noetherian, <span class="math inline">\(\cap {n=1} ^{\infty} J^n = 0\)</span>. 当 <span class="math inline">\(A\)</span> 不是 Noetherian 环时, 上述结果可能不成立, 例如实数 <span class="math inline">\(\mathbb{R}\)</span> 上在 <span class="math inline">\(0\)</span>处无穷次可导的函数全体 <span class="math inline">\(A\)</span>. <span class="math inline">\(J\)</span> 是在 <span class="math inline">\(A\)</span> 中在 <span class="math inline">\(0\)</span> 处取值为 <span class="math inline">\(0\)</span> 的函数全体(<span class="math inline">\(A\)</span>的唯一极大理想), 则 <span class="math inline">\(e^{-\frac{1}{x^2}} \in A\)</span></p><p>非交换环有一个著名的 Jacobson 猜想: <span class="math inline">\(R\)</span> 是左右 Noetherian 环, 则 <span class="math inline">\(\cap_{n=1} ^{\infty} J(R) = 0\)</span>.</p></blockquote><h3 id="dimension-theroy">Dimension Theroy</h3><p>设 <span class="math inline">\(A\)</span> 是环, <span class="math inline">\(n+1\)</span> 个素理想构成的序列 <span class="math inline">\(p_0 \supset p_1 \supset \cdots \supset p_n\)</span> 称为长为 <span class="math inline">\(n\)</span> 的素理想链. 对任意 <span class="math inline">\(p \in Spec(A)\)</span>, 满足 <span class="math inline">\(p = p_0\)</span> 的最长素理想链的称为 <span class="math inline">\(p\)</span> 的高度, 记作 <span class="math inline">\(ht(p)\)</span>. 显然 <span class="math inline">\(ht(p) = 0\)</span>表 示 <span class="math inline">\(p\)</span> 为 <span class="math inline">\(A\)</span> 的极小素理想. <strong>理想的高度</strong>：设 <span class="math inline">\(I\)</span> 为 <span class="math inline">\(A\)</span> 的真理想, 定义 <span class="math inline">\(I\)</span> 的高度为包含 <span class="math inline">\(I\)</span> 的所有素理想高度的最小值. <span class="math display">\[ht(I) = \inf \lbrace ht(p) \mid p \supset I \rbrace = ht(\sqrt{I})\]</span> <strong>环的 Krull 维数</strong>：<span class="math inline">\(A\)</span> 的维数定义为最长的素理想链的长度.即 <span class="math display">\[\dim(A) = \sup \lbrace ht(p) \mid p \in Spec(A) \rbrace\]</span> PID has Dimension <span class="math inline">\(\leq 1\)</span>. <strong>Proof</strong>: 若 <span class="math inline">\((p) \supset (q) \supset (0)\)</span>. 则存在 <span class="math inline">\(b \neq 0\)</span> 使得<span class="math inline">\(q = pb\)</span>, 从而 <span class="math inline">\((p)(b) \subset (q)\)</span>, 所以 <span class="math inline">\((b) \subseteq (q)\)</span>, 所以存在 <span class="math inline">\(c\)</span> 使得 <span class="math inline">\(b = cpb\)</span>, 因此 <span class="math inline">\(cp = 1\)</span>(domain 中), 从而<span class="math inline">\((p)=A\)</span>. 证毕.</p><p>由上述定义可知: 对任意 <span class="math inline">\(p \in Spec(A), ht(p) = \dim(A_p)\)</span>, 对任意理想 <span class="math inline">\(I\)</span>, <span class="math inline">\(\dim(A/I) + ht(I) \leq \dim(A)\)</span>.</p><p><strong>模的 Krull 维数</strong>：设 <span class="math inline">\(M \neq 0\)</span> 是 <span class="math inline">\(A\)</span>-模. 定义 <span class="math inline">\(M\)</span> 的维数为: <span class="math display">\[\dim(M) = \dim(A/Ann(M))\]</span> 当 <span class="math inline">\(M = 0\)</span> 时, 记 <span class="math inline">\(\dim(M) = -1\)</span>.</p><p>若 <span class="math inline">\(M \neq 0\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 上的有限生成模, 则下列条件等价:</p><ol type="1"><li><span class="math inline">\(M\)</span> 是有限长的.</li><li>环 <span class="math inline">\(A/Ann(M)\)</span> 是 Artinian.</li><li><span class="math inline">\(\dim(M) = 0\)</span>.</li></ol><p>由 Noetherian 环成为 Artin 环的充要条件知 <span class="math inline">\(2 \leftrightarrow 3\)</span>. 再由有限生成 Artinian 模是有限长的可知 <span class="math inline">\(2 \to 1\)</span>. 现在证明 <span class="math inline">\(1\to 3\)</span>: 我们不妨考虑 <span class="math inline">\(Ann(M) = (0)\)</span> 的情形, 若 <span class="math inline">\(l(M)\)</span> 有限, 若 <span class="math inline">\(\dim(A) &gt; 0\)</span>, 则存在极小素理想 <span class="math inline">\(p\)</span> 不是极大素理想. 由于 <span class="math inline">\(M\)</span> 是有限生成的, 且 <span class="math inline">\(Ann(M)=(0)\)</span>, <span class="math inline">\(M_p \neq 0\)</span>, 即 <span class="math inline">\(p \in Supp(M)\)</span> 是极小素理想, 因此 <span class="math inline">\(p \in Ass(M)\)</span>. 即 <span class="math inline">\(M\)</span> 中包含一个同构于 <span class="math inline">\(A/p\)</span> 的子模. 由于 <span class="math inline">\(\dim(A/p) &gt; 0\)</span>, 我们有 <span class="math inline">\(l(A/p) = \infty\)</span>(这是因为有限长, 则为 Artinian, 从而维数为 0), 从而矛盾于 <span class="math inline">\(l(M)\)</span> 有限长.</p><h4 id="noetherian-半局部环">Noetherian 半局部环</h4><p>众所周知的几个关于维数的等价刻画本来是在 Noetherian 局部环中考虑的, 这里可以推广到 Noetherian 半局部环.</p><p>设 <span class="math inline">\(A\)</span> 是 Noetherian semi-local 环, <span class="math inline">\(\mathfrak{m} = J(A)\)</span>. <span class="math inline">\(A\)</span> 的理想被称为<strong>ideal of definition(IOD)</strong>，如果存在 <span class="math inline">\(k&gt;0\)</span> 使得 <span class="math inline">\(\mathfrak{m}^k \subseteq I \subseteq \mathfrak{m}\)</span>.</p><blockquote><p>当 <span class="math inline">\(A\)</span> 是局部环时, IOD 就是 <span class="math inline">\(J\)</span>-准素理想.</p></blockquote><p><span class="math inline">\(I\)</span> 是 IOD 的等价定义</p><ol type="1"><li><span class="math inline">\(I \subseteq \mathfrak{m}\)</span> 且 <span class="math inline">\(A/I\)</span> 是 Artinian.</li><li><span class="math inline">\(I \subseteq \mathfrak{m}\)</span> 且 <span class="math inline">\(\dim(A/I)=0\)</span>. <strong>Proof</strong>: <span class="math inline">\(1 \leftrightarrow\)</span> 显然, 若 <span class="math inline">\(I\)</span> 是 IOD, 即存在 <span class="math inline">\(k&gt;0\)</span> 使得 <span class="math inline">\(\mathfrak{m}^k \subseteq I subseteq \mathfrak{m}\)</span>. 从而包含 <span class="math inline">\(I\)</span> 的素理想必然是极大理想, 从而 <span class="math inline">\(\dim(A) = 0\)</span>. 另一方面, 若 <span class="math inline">\(I \subseteq \mathfrak{m}\)</span> 且 <span class="math inline">\(A/I\)</span> 是 Artinian. 则 <span class="math inline">\(J(A/I) = \mathfrak{m}/I\)</span> 幂零, 从而 <span class="math inline">\(\mathfrak{m}^n \subseteq I\)</span>.</li></ol><blockquote><p>由于此时 <span class="math inline">\(A/I\)</span> 是 Artinian, 所以就可以由 Poincare 数, 以及 Hilbert-Serre 多项式. 完美的一 P.</p></blockquote><p>设 <span class="math inline">\(I\)</span> 是 IOD, <span class="math inline">\(M\)</span> 是一个有限生成 <span class="math inline">\(A\)</span>-模. 设 <span class="math inline">\(A^{\star} = gr^I(A) = \otimes I^n / I^{n+1}\)</span>，<span class="math inline">\(M^{\star} = gr^I(M) = \otimes I^n M / I^{n+1} M\)</span></p><p>设 <span class="math inline">\(I = A x_1 + \cdots Ax_r\)</span>. 那么 <span class="math inline">\(A^{\star}\)</span> 是 <span class="math inline">\(B=A/I[X_1, \cdots, X_r]\)</span> 的同态像. 因此 <span class="math inline">\(F_{M^{\star}}(n) = l(I^n M/ I^{n+1} M)\)</span> 是关于 <span class="math inline">\(n\)</span> 的次数不超过 <span class="math inline">\(r-1\)</span> 的多项式(由 Hilbert-Serre 的结果). 从而 ​ <span class="math display">\[\chi(M, I;n) \triangleq l(M/ I^{n+1} M) = \sum_{j=1} ^ {n-1}F_{M^{\star}}(j)\]</span> 是一个次数不超过 <span class="math inline">\(r\)</span> 的多项式. 对于不同的 IOD <span class="math inline">\(I’\)</span>, 存在 <span class="math inline">\(s, s’\)</span> 使得 <span class="math inline">\((I’)^s \subseteq I, I^{s’} \subseteq I’\)</span>. 从而 <span class="math inline">\(deg chi(M, I;n) = chi(M, I’;n)\)</span>. 即 <span class="math inline">\(chi(M, I;n)\)</span> 是 <span class="math inline">\(M\)</span> 的一个不变量, 记作 <span class="math inline">\(d(M)\)</span>.</p><blockquote><p>若有一个 IOD 被 <span class="math inline">\(r\)</span> 个元素生成, 则 <span class="math inline">\(d(M) \leq r\)</span>.</p></blockquote><p>引理 0: 设 <span class="math inline">\(I\)</span> 是 Noetherian 半局部环 <span class="math inline">\(A\)</span> 的一个 IOD, 给定有限生成模的一个短正合列: <span class="math inline">\(0 \to M’ \to M \to M’’ \to 0\)</span>. 则 <span class="math inline">\(d(M) = \max(d(M’),d(M’’))\)</span> 更进一步, 当 <span class="math inline">\(n \gg 0\)</span> 时, <span class="math inline">\(\chi(M,I;n) - \chi(M’,I;n) - \chi(M’’,I;n)\)</span> 的次数小于 <span class="math inline">\(d(M’)\)</span></p><p><strong>Proof</strong>: 由于 <span class="math inline">\(l(M’’/I^n M’’) = l(M/M’+I^n M) \leq l(M/I^M)\)</span>, 从而 <span class="math inline">\(d(M’’) \leq d(M)\)</span>. 更进一步, <span class="math inline">\(\chi(M,I;n)-\chi(M’’,I;n) = l(M’+I^n M/I^n M) = l(M’/M’ \cap I^n M)\)</span>. 因此由 Artin-Rees 引理, 存在 <span class="math inline">\(r\)</span> 使得 <span class="math inline">\(M’ \cap I^n M \subseteq I^{n-r} M’\)</span>, 从而 <span class="math inline">\(l(M’/I^n M’) \geq l(M’/M’ \cap I^n M) \geq l(M’/I^{n-r} M’)\)</span>. 从而 <span class="math inline">\(\chi(M,I;n)-\chi(M’’,I;n)\)</span> 与 <span class="math inline">\(\chi(M’,I;n)\)</span> 有相同的最高次项.</p><p><strong>引理 1</strong>: 设 <span class="math inline">\(A\)</span> 是 Noetherian 半局部环, 则 <span class="math inline">\(d(A) \geq dim(A)\)</span> 对 <span class="math inline">\(d(A)\)</span> 进行数学归纳. 若 <span class="math inline">\(d(A)=0\)</span>, 则存在 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\(\mathfrak{m}^k = \mathfrak{m}^{k+1} \cdots\)</span>. 由 <strong>Krull 交定理</strong> 知 <span class="math inline">\(\mathfrak{m}^k=(0)\)</span>. 从而 <span class="math inline">\(l(A)\)</span> 是有限长的, <span class="math inline">\(\dim(A)=0\)</span>. 若 <span class="math inline">\(d(A) &gt; 0\)</span>. 不妨设 <span class="math inline">\(r = \dim(A)&gt;0\)</span>, 设 <span class="math inline">\(p_0 \supset \cdots p_r = p\)</span> 是长为<span class="math inline">\(r\)</span> 的素理想链. 任取 <span class="math inline">\(x \in p_{r-1} \backslash p\)</span>. 则 <span class="math inline">\(\dim(A/xA+p) \geq r-1\)</span>. 再由正合序列 <span class="math display">\[0 \to A/p \xrightarrow{x} A/p \to A/xA+p \to 0\]</span> 我们有 <span class="math inline">\(d(A/xA+p) &lt; d(A/p) \leq d(A)\)</span>(这个严格小是因为上面”更进一步”的结论). 因此, 由数学归纳 <span class="math inline">\(r-1 \leq \dim(A/xA+p) \leq d(A/xA+p) &lt; d(A)\)</span>, 证毕.</p><blockquote><p>上述引理表明 Noetherian 半局部环的维数有限, 且对于任意 Noetherian 及其素理想 <span class="math inline">\(p, ht(p) = \dim(A_p)\)</span> 有限, 从而 <strong>Noetherian 环满足素理想的降链条件</strong>, 当然 Noetherian 也可以由无限 Krull 维数, 例如: <img src="NagataNoether.png" alt="Nagata example" /> <img src="NoetherJudge.png" alt="补充" /></p></blockquote><p><strong>引理 2</strong>: 设 <span class="math inline">\(M \neq 0\)</span> 是 Noetherian 半局部环 <span class="math inline">\(A\)</span> 上的有限生成模. <span class="math inline">\(x \in J(A)\)</span>. 则 <span class="math display">\[d(M) \geq d(M/xM) \geq d(M)-1\]</span> 取 IOD <span class="math inline">\(I \ni x\)</span>. 则 <span class="math inline">\(\chi(M/xM,I;n) = l(M/xM+I^n M) = l(M/I^nM) - l(xM + I^n M/I^n M)\)</span> 且 <span class="math inline">\(xM + I^n M /I^n M \simeq xM/xM \cap I^n M \simeq M/(I^n M:x)\)</span>, 又因为 <span class="math inline">\(I^{n-1} \subseteq (I^n M:x)\)</span> 从而 <span class="math display">\[\chi(M/xM,I;n) \geq l(M/I^nM) - l(M/I^{n-1}M) = \chi(M,I;n) - \chi(M,I;n-1)\]</span></p><p><strong>引理 3</strong>: 设 <span class="math inline">\(M \neq 0\)</span> 是 Noetherian 半局部环 <span class="math inline">\(A\)</span> 上的有限生成模. 设 <span class="math inline">\(\dim(A) = r\)</span>. 那么存在 <span class="math inline">\(r\)</span> 个元素 <span class="math inline">\(x_1, \cdots, x_r \in J(A)\)</span> 使得 <span class="math inline">\(l(M/x_1 M + \cdots x_r M) \leq \infty\)</span>. <strong>Proof</strong>: 应用数学归纳法, 并说明在 <span class="math inline">\(J(A)\)</span> 不包含在 <span class="math inline">\(Ann(M)\)</span> 的任意极小素理想即可.</p><p><strong>维数等价定理</strong>：设 <span class="math inline">\(M \neq 0\)</span> 是 Noetherian 半局部环 <span class="math inline">\(A\)</span> 上的有限生成模. 则 <span class="math inline">\(d(M) = dim(M)\)</span> 为使得 <span class="math inline">\(l(M/x_1 M + \cdots x_r M) \leq \infty\)</span> 的最小的 <span class="math inline">\(r\)</span>. 其中 <span class="math inline">\(x_1, \cdots x_r \in M\)</span>. 若 <span class="math inline">\(l(M/x_1 M + \cdots x_r M) \leq \infty\)</span> 则由引理 2 知, <span class="math inline">\(d(M) \leq r\)</span>. 当 <span class="math inline">\(r\)</span>满足条件的最小值, 由引理 3 知, <span class="math inline">\(r \leq \dim(M)\)</span>. 从而只需证明 <span class="math inline">\(\dim(M) \leq d(M)\)</span>. 取 <span class="math inline">\(M\)</span> 的一个子模链 <span class="math inline">\(M = M_1 \supset M_2 \supset \cdots \supset M_{k+1} = 0\)</span>. 使得 <span class="math inline">\(M/M_{i+1} \simeq A/p_i, p_i \in Spec(A)\)</span>. 那么 <span class="math inline">\(p_i \supseteq Ann(M)\)</span>. 且 <span class="math inline">\(Ass(M) \subseteq \lbrace p_1, \cdots, p_k \rbrace\)</span>(这些之前就证明过了). 从而 <span class="math inline">\(Supp(M) = V(Ann(M))\)</span>. 包含 <span class="math inline">\(Ann(M)\)</span> 的极小素理想是 <span class="math inline">\(Supp(M)\)</span> 的极小素理想, 从而在 <span class="math inline">\(Ass(M)\)</span> 中, 从而在 <span class="math inline">\(\lbrace p_1, \cdots, p_k \rbrace\)</span>. 即 <span class="math inline">\(Ass(M) = \lbrace p_1, \cdots, p_k \rbrace\)</span>. 因此(其中第一个等号要对 <span class="math inline">\(M\)</span> 的降链应用引理 0) <span class="math display">\[d(M) = \max d(A/p_i) \geq \max \dim(A/p_i) = \dim(A/Ann(M)) = \dim(M)\]</span></p><p><strong>广义 Krull 维数定理</strong>：<span class="math inline">\(I=(a_1, \cdots, a_r)\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 的理想. 则任意包含 <span class="math inline">\(p\)</span> 的极小素理想 <span class="math inline">\(p\)</span> 的高度不超过 <span class="math inline">\(r\)</span>. 特别地, <span class="math inline">\(h(I) \leq r\)</span>. <strong>Proof</strong>: 由于 <span class="math inline">\(pA_p\)</span> 是 <span class="math inline">\(A_p\)</span> 中包含 <span class="math inline">\(IA_p\)</span> 的唯一素理想, 因此 <span class="math inline">\(\dim(A_p/IA_p)=0\)</span>. 从而环 <span class="math inline">\(A_p/(a_1 A_p + \cdots a_rA_p)\)</span> 是 Artinian. 因此 <span class="math inline">\(ht(p) = \dim(A_p) \leq r\)</span>.</p><h4 id="noetherian-局部环和-regular-local-ring正则局部环">Noetherian 局部环和 regular local ring(正则局部环)</h4><p>设 <span class="math inline">\((A, \mathfrak{m},k)\)</span> 是维数为 <span class="math inline">\(d\)</span> 的 Noetherian 局部环. 此时 IOD 和属于 <span class="math inline">\(\mathfrak{m}\)</span> 的准素理想是一回事. 我们知道 IOD 的生成元个数至少为 <span class="math inline">\(d\)</span> 并且存在 IOD 的生成元个数恰好为 <span class="math inline">\(d\)</span>, 若 <span class="math inline">\(\lbrace x_1, \cdots, x_d \rbrace\)</span> 生成了一个 IOD 则称为 <strong>system of parameters</strong>(SOP). 若一个 SOP 生成了唯一极大理想 <span class="math inline">\(\mathfrak{m}\)</span>. 则我们称 <span class="math inline">\(A\)</span> 为 <strong>正则局部环</strong></p><p>由于 <span class="math inline">\(\mathfrak{m}\)</span> 的极小基个数等于 <span class="math inline">\(\text{rank}_k \mathfrak{m}/\mathfrak{m}^2\)</span>. 因此一般地我们有 <span class="math display">\[\dim(A) \leq \text{rank}_k \mathfrak{m}/\mathfrak{m}^2\]</span> 等号取得, 当且仅当 <span class="math inline">\(A\)</span> 是 Noetherian 局部环.</p><p>设<span class="math inline">\((A, \mathfrak{m})\)</span>是 Noetherian 局部环, <span class="math inline">\(\lbrace x_1, \cdots, x_d \rbrace\)</span> 是一个 <span class="math inline">\(SOP\)</span>. 则 <span class="math display">\[\dim(A/(x_1, \cdots, x_i) = d-i = \dim(A) - i\]</span></p><p>设 <span class="math inline">\(A\)</span> 是 Noetherian 环, 则 <span class="math inline">\(\dim A[x_1, \cdots, x_n] = \dim A + n\)</span>. <strong>Proof</strong>: 对 <span class="math inline">\(B = A[x]\)</span> 证明即可. 对任意 <span class="math inline">\(p \in Spec(A)\)</span>, 选择 <span class="math inline">\(P\)</span> 为满足 <span class="math inline">\(P \cap A = p\)</span> 中极大元. 则 <span class="math inline">\(ht(P/pB) = 1\)</span>. 又 <span class="math inline">\(ht(P) = ht(p) + ht(P/pB) = ht(p)+1\)</span>. 再由 <span class="math inline">\(Spec(B) \to Spec(A)\)</span> 是满的. 因此 <span class="math inline">\(\dim(B) = \dim(A) + 1\)</span>.</p><p>推论: 设 <span class="math inline">\(k\)</span> 是域, 则 <span class="math inline">\(\dim k[x_1, \cdots, x_n] = n\)</span>. 理想 <span class="math inline">\((x_1, \cdots, x_i)\)</span> 是高度为 <span class="math inline">\(i\)</span> 的素理想. <strong>Proof</strong>: 由于 <span class="math inline">\((0) \supset (x_1) \supset (x_1,x_2) \supset \cdots \supset (x_1, \cdots, x_i)\)</span> 是长为 <span class="math inline">\(n\)</span> 的素理想链. 在由 <span class="math inline">\(\dim k[x_1, \cdots, x_n] = n\)</span> 知结论成立.</p><h2 id="depth">Depth</h2><h3 id="m-regular-sequence"><span class="math inline">\(M\)</span>-regular sequence</h3><p>我们称 <span class="math inline">\(a_1, \cdots, a_r\)</span> 是一个 <strong><span class="math inline">\(M\)</span>-regular sequence</strong>: 如果它满足:</p><ol type="1"><li><p><span class="math inline">\(\forall 1 \leq i \leq r, a_i\)</span> 不是 <span class="math inline">\(M/(a_1, \cdots, a_{i-1})M\)</span> 的零因子;</p></li><li><p><span class="math inline">\((a_1, \cdots, a_r)M \neq M\)</span>.</p></li></ol><blockquote><p>上述定义与 <span class="math inline">\(a_1, \cdots, a_r\)</span> 的次序有关, 例如 <span class="math inline">\(k\)</span> 为域, <span class="math inline">\(A=k[x, y,z], a_1 = X(Y-1), a_2 = Y, a_3= Z(Y-1)\)</span> 是 <span class="math inline">\(A\)</span>-regular sequence, 但 <span class="math inline">\(a_1, a_3, a_2\)</span>不是.</p></blockquote><p>类似地, 可以定义一个理想 <span class="math inline">\(I\)</span> 上的(极大) <span class="math inline">\(M\)</span>-regular sequnence.</p><p><strong>引理 1</strong>: 假设 <span class="math inline">\(a_1, \cdots, a_r\)</span> 是 <span class="math inline">\(M\)</span>-regular 且 <span class="math display">\[a_1 \xi_1 + \cdots a_r \xi_r = 0\]</span> 则 <span class="math inline">\(\xi_i \in (a_1, \cdots, a_r)M\)</span>.</p><p><strong>引理 2</strong>: 假设 <span class="math inline">\(a_1, \cdots, a_r\)</span> 是 <span class="math inline">\(M\)</span>-regular, 则 <span class="math inline">\(a_1 ^{n_1} + \cdots a_r ^{n_r}\)</span> 也是.</p><p>若 <span class="math inline">\(a_1, a_2, \cdots \in A\)</span> 是一个 <span class="math inline">\(M\)</span>-regular sequence. 则由严格子模升链 <span class="math inline">\(a_1 M \subset (a_1, a_2)M \subset \cdots\)</span>. 因此有理想严格升链 <span class="math inline">\(a_1 \subset (a_1, a_2) \subset \cdots\)</span>. 从而若 <span class="math inline">\(A\)</span> 是 Noetherian 环, 则 <span class="math inline">\(M\)</span>-regular sequence 的长度总是有限的, 因此每个理想 <span class="math inline">\(I\)</span> 上 <span class="math inline">\(M\)</span>-regular sequence 都可以推展为一个极大 <span class="math inline">\(M\)</span>-regular sequence.</p><p>定理: 设 <span class="math inline">\(M\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 上的有限生成模. <span class="math inline">\(I\)</span> 是 <span class="math inline">\(A\)</span>的理想, 满足 <span class="math inline">\(IM \neq M\)</span>. <span class="math inline">\(n\)</span> 为给定正整数. 则下列条件等价:</p><ol type="1"><li><span class="math inline">\(\text{Ext}_A ^i(N, M) = 0 (i&lt;n)\)</span> 对任意满足 <span class="math inline">\(Supp(N) \subseteq V(I)\)</span> 的有限生成 <span class="math inline">\(A\)</span>-模成立;</li><li><span class="math inline">\(\text{Ext} _A ^i(A/I, M) = 0 (i&lt;n)\)</span>;</li><li>存在一个满足 <span class="math inline">\(Supp(N) = V(I)\)</span> 的有限生成模 <span class="math inline">\(N\)</span> 使得 <span class="math inline">\(\text{Ext}_A ^i(N, M) = 0 (i&lt;n)\)</span>;</li><li><span class="math inline">\(I\)</span> 中存在长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(M\)</span>-regular sequence <span class="math inline">\(a_1, \cdots, a_n\)</span>.</li></ol><p><strong>Proof</strong>: <span class="math inline">\(1 \to 2 \to 3\)</span> 显然, <span class="math inline">\(3 \to 4\)</span>: 我们有 <span class="math inline">\(Ext_A ^0 (N,M) = \hom_A (N,M) = 0\)</span>. 若 <span class="math inline">\(I\)</span> 中无元素是 <span class="math inline">\(M\)</span>-regular, 则 <span class="math inline">\(I\)</span> 包含在 <span class="math inline">\(Ass(M)\)</span> 全体的 (Noetherian 所以有限)并中, 从而 <span class="math inline">\(I\)</span> 包含于某个素理想 <span class="math inline">\(P\)</span> 中, 从而由单射 <span class="math inline">\(A/P \to M\)</span>. 在 <span class="math inline">\(P\)</span> 处作局部化, 我们有 <span class="math inline">\(\hom_{A_P}(k, M_P) \neq 0\)</span>, 其中 <span class="math inline">\(k = A_P / P A_P\)</span>. 由于 <span class="math inline">\(P \in V(I) = Supp(N)\)</span>. 从而 <span class="math inline">\(N_P \neq 0\)</span>, 从而由 <strong>NAK lemma</strong> <span class="math inline">\(N \otimes k = N_P / PN_P \neq 0\)</span>. 从而 <span class="math inline">\(\hom(N \otimes k, k) \neq 0\)</span>. 从而 <span class="math inline">\(\hom_{A_P}(N_P, M_P) \neq 0\)</span>. (三个映射的复合, 第一个满第三个单). 然而它 <span class="math inline">\(\hom_A(N,M)=0\)</span> 在 <span class="math inline">\(P\)</span> 处局部化的结果, 矛盾. 从而 <span class="math inline">\(\exists a_1 \in I\)</span>, 若 <span class="math inline">\(n&gt;1\)</span>, 取 <span class="math inline">\(M_1 = M/a_1 M\)</span>. 由模的短正合列 <span class="math display">\[0 \to M \xrightarrow{a_1} M \to M_1 \to 0\]</span> 得到同调群的长正合列: <span class="math display">\[\cdots \to Ext_A ^i (N,M) \to Ext_A ^i (N,M_1) \to Ext_A ^{i+1} (N,M) \to \cdots\]</span> 这说明 <span class="math inline">\(Ext_A ^i(N,M_1) =0 (i&lt;n-1)\)</span>, 因此 <span class="math inline">\(a_1^r\)</span> 也零化 <span class="math inline">\(Ext_A^i(N,M)\)</span>. 从而 <span class="math inline">\(Ext_A(N,M) = 0 (i &lt;n)\)</span></p><p>我们将上述 <span class="math inline">\(I\)</span> 中最长的 <span class="math inline">\(M\)</span>-regular 序列称为 <span class="math inline">\(I\)</span>-depth of <span class="math inline">\(M\)</span>. 记作 <span class="math inline">\(depth_I(M)\)</span>. 上述定理表明 <span class="math display">\[depth_I(M) = \min \lbrace i \mid Ext_A ^i(A/I,M) \neq 0 \rbrace\]</span> 当 <span class="math inline">\((A, \mathfrak{m})\)</span> 是(Noetherian 局部环时), 我们用 <span class="math inline">\(depth(M), depth_A(M)\)</span> 来表示 <span class="math inline">\(depth_{\mathfrak{m}}(M)\)</span> 称作 <span class="math inline">\(M\)</span> 的深度.</p><p>对任意 <span class="math inline">\(P \in Spec(A)\)</span>, <span class="math inline">\(depth M_P = 0 \Longleftrightarrow PA_P \in Ass_{A_P}(M_P) \Longleftrightarrow P \in Ass(M) \to depth_p(M) = 0\)</span>. 一般地, 由于局部化函子正合, 因此 <span class="math inline">\(depth_{A_P} (M_p) \geq depth_P (M)\)</span></p><p>若 <span class="math inline">\(M = 0\)</span>, 定义 <span class="math inline">\(depth_I(M) = 0\)</span>; 若 <span class="math inline">\(IM = M \neq 0\)</span>, 定义 <span class="math inline">\(depth_I(M) = \infty\)</span>.</p><h4 id="grade">Grade</h4><p>设 <span class="math inline">\(M\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 上的有限生成模. 定义 <span class="math inline">\(M\)</span> 的 garde 为: <span class="math display">\[grade M = \inf \lbrace i \mid Ext_A ^i (M,A) \neq 0 \rbrace\]</span> 由上面定义知: <span class="math display">\[grade M = depth_I(A), \quad I = Ann(M)\]</span> 同理, 由定义知: <span class="math inline">\(grade M \leq proj.dim M\)</span></p><p>对于 <span class="math inline">\(A\)</span> 中任意理想 <span class="math inline">\(I\)</span>, <span class="math inline">\(depth_I(A)\)</span> 为 <span class="math inline">\(I\)</span> 中最长的 <span class="math inline">\(A\)</span>-sequence 序列 <span class="math inline">\(a_1, \cdots, a_r\)</span> 的长度. 又此时 <span class="math inline">\(ht(a_1, \cdots, a_r) = r\)</span>. 从而 <span class="math inline">\(depth_I(A) \leq ht(I)\)</span></p><p><strong>引理 1</strong>: 设 <span class="math inline">\(M \neq 0 ,N\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 上的有限生成模, 若 <span class="math inline">\(grad M = k\)</span>, <span class="math inline">\(proj. dim N = l &lt; k\)</span>. 则 <span class="math inline">\(Ext_A ^i(M,N) = 0 (i &lt; k-l)\)</span> <strong>Proof</strong>: 对 <span class="math inline">\(l\)</span> 数学归纳, <span class="math inline">\(l=0\)</span> 时, <span class="math inline">\(N\)</span> 为自由 <span class="math inline">\(A\)</span>-模的直和因子, 因此结论成立. <span class="math inline">\(l&gt;0\)</span> 时, 由正合列: <span class="math inline">\(0 \to N’ \to L \to N \to 0\)</span>, 其中 <span class="math inline">\(L\)</span> 自由, 于是<span class="math inline">\(\dim N’ = l-1\)</span>. 由归纳法得证.</p><p><strong>引理 2</strong>: (<strong>Ischebeck</strong>) 设 <span class="math inline">\((A, \mathfrak{m})\)</span> 是 Noetherian 局部环, <span class="math inline">\(M \neq 0 \neq N\)</span> 是有限生成 <span class="math inline">\(A\)</span>-模. 若 <span class="math inline">\(depth M = k, \dim N = r\)</span>. 则 <span class="math display">\[Ext _A ^i (N,M) = 0 \quad (i&lt; k-r)\]</span> <strong>Proof</strong>: 对 <span class="math inline">\(r\)</span> 归纳法证明.(并不简单, 都是用模的短正合列, (再由投射分解, 得到复形的短正合列, 从而)导出同调群之间的长正合列, 然后应用数学归纳得出结论)</p><p>定理: 设 <span class="math inline">\((A,\mathfrak{m})\)</span> 是 Noetherian 半局部环, 且 <span class="math inline">\(M \neq 0\)</span> 是有限生成 <span class="math inline">\(A\)</span>-模. 那么对任意 <span class="math inline">\(p \in Spec(A), \quad depth M \leq \dim(A/p)\)</span>. <strong>Proof</strong>: 由于 <span class="math inline">\(\hom(A/p,M) \neq 0\)</span>, 上面引理反证即可.</p><p><strong>引理 3</strong>: 设 <span class="math inline">\(M,N\)</span> 是局部环 <span class="math inline">\((A,\mathfrak{m},k)\)</span> 上的有限生成模, 则 <span class="math display">\[M \otimes_A N \neq 0 \Longleftrightarrow M \neq 0 \neq N\]</span> 若 <span class="math inline">\(M \neq 0 \neq N\)</span>, 则由 <strong>NAK lemma</strong> 知: <span class="math inline">\(M \otimes k = M/\mathfrak{m}M \neq 0 \neq N \otimes k\)</span>. 由于 <span class="math inline">\(k\)</span> 是域. <span class="math inline">\((M \otimes N) \otimes k = (E \otimes k) \otimes_k (F \otimes k) \neq 0\)</span>. 从而 <span class="math inline">\(M \otimes N \neq 0\)</span>.</p><p><strong>引理 4</strong>: 设 <span class="math inline">\(E,F\)</span> 是环 <span class="math inline">\(A\)</span> 上的有限生成模, 则 <span class="math inline">\(Supp(E \otimes F) = Supp(E) \cap Supp(F)\)</span>. <strong>Proof</strong>: 对任意 <span class="math inline">\(p \in Spec(A,\quad (E \otimes F)_p = (E_p \otimes_{A\p} F_p)\)</span>. 由引理 3, <span class="math inline">\((E \otimes F)_p \neq 0 \Longleftrightarrow E_p \neq 0 \neq F_p\)</span>.</p><p><strong>引理 5</strong>: 设 <span class="math inline">\(M \neq 0\)</span> 是 Noetherian 局部环 <span class="math inline">\(A\)</span> 上的有限生成模, <span class="math inline">\(a_1, \cdots, a_r\)</span> 是 <span class="math inline">\(M\)</span>-regular 序列. 那么 <span class="math display">\[\dim M/(a_1, \cdots, a_r)M =  \dim M -r\]</span> <strong>Proof</strong>: 首先由于此时 <span class="math inline">\(\dim M = d(M)\)</span>, 我们有 <span class="math inline">\(\dim M/(a_1, \cdots, a_r)M \geq \dim M -r\)</span>, 另一方面, 若 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(M\)</span>-regular 元, 那么由引理 4 <span class="math inline">\(Supp(M/xM) = Supp(M) \cap Supp(A/xA) = Supp(M) \cap V(x)\)</span>. 由因为 <span class="math inline">\(x\)</span> 不在 <span class="math inline">\(Supp(M) = V(Ann(M))\)</span> 的极小素理想中. 从而 <span class="math display">\[\dim(M/xM) = \dim(A/Ann(M)+xA) &lt; \dim(A/Ann(M)) = \dim(M)\]</span> <strong>引理 6</strong>: 设 <span class="math inline">\(M\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 上的有限生成模, <span class="math inline">\(I\)</span> 是 <span class="math inline">\(A\)</span>的理想, 则 <span class="math display">\[depth_I(M) = \inf \lbrace depth M_p \mid p \in V(I) \rbrace\]</span> <strong>Proof</strong>: 将等式右边记作 <span class="math inline">\(n\)</span>. 若 <span class="math inline">\(n=0\)</span>. 则存在 <span class="math inline">\(P \supseteq I\)</span> 使得 <span class="math inline">\(M_P = 0\)</span>. 从而 <span class="math inline">\(I \subseteq p \in Ass(M)\)</span>. 从而 <span class="math inline">\(depth_I(M) = 0\)</span>. 若 <span class="math inline">\(0 &lt; n &lt; \infty\)</span>. 此时 <span class="math inline">\(I\)</span> 不包含于任何 <span class="math inline">\(M\)</span> 的 associated 素理想中, 因此存在 <span class="math inline">\(M\)</span>-regular 元 <span class="math inline">\(a \in I\)</span>. 记 <span class="math inline">\(M’ = M/aM\)</span>. 则由 depth 和 <span class="math inline">\(M\)</span>-regular 的关系(上面定理)知 <span class="math inline">\(depth (M’)_P = depth M_P/aM_P = depth M_P -1, \text{ for } P \supset I\)</span>. 且 <span class="math inline">\(depth_I(M’) = depth_I(M)-1\)</span>. 从而归纳法知结论成立, 当 <span class="math inline">\(n = \infty\)</span> 时, 对任意 <span class="math inline">\(P \in V(I), \quad PM_P = M_P\)</span>. 若 <span class="math inline">\(IM \neq M\)</span>, 对任意 <span class="math inline">\(P \in Supp(M/IM) = V(I) \cap Supp(M)\)</span>, 我们有 <span class="math inline">\((M/IM)_P \neq 0\)</span>. 若 <span class="math inline">\(P\)</span> 是 <span class="math inline">\(Supp(M/IM)\)</span> 中的极小素理想, 则 <span class="math inline">\(Supp_{A_P}(M/IM)_P = \lbrace PA_P \rbrace\)</span>. 因此 <span class="math inline">\((M/IM)_P = M_P/IM_P\)</span> 在 <span class="math inline">\(M_P\)</span> 中 coprimary. 又因为 <span class="math inline">\(P\)</span> 是 <span class="math inline">\(M_P\)</span> 的零因子且有限生成, 所以存在 <span class="math inline">\(s&gt;0\)</span> 使得 <span class="math inline">\(P^s \subseteq IM_P\)</span>. 因此 <span class="math inline">\(PM_P \neq M_P\)</span> 矛盾. 从而 <span class="math inline">\(IM = M, \quad depth_I(M) = \infty\)</span>.</p><h3 id="cohen-macaulay-rings">Cohen-Macaulay Rings</h3><p>设 <span class="math inline">\(M\)</span> 是 Noetherian 环 <span class="math inline">\(A\)</span> 上的有限生成模, 当 <span class="math inline">\(M\neq 0\)</span> 时, <span class="math inline">\(\hom(M,M) \neq 0\)</span>, 从而由引理 2(Ischebeck) 知 <span class="math inline">\(depth M \leq \dim M\)</span>. 我们称 <span class="math inline">\(M\)</span> 是<strong>Cohen-Macaulay</strong>(C.M.), 如果 <span class="math inline">\(M = 0\)</span> 或 <span class="math inline">\(depth M = \dim M\)</span>. 若 <span class="math inline">\(A\)</span> 作为 <span class="math inline">\(A\)</span>-模是 <span class="math inline">\(C.M.\)</span>, 则称 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(C.M.\)</span>环.</p><p>设 <span class="math inline">\((A,\mathfrak{m})\)</span> 是局部环, <span class="math inline">\(M\)</span> 是有限生成 <span class="math inline">\(A\)</span>-模. 则:</p><ol type="1"><li>若 <span class="math inline">\(M\)</span> 是 C.M. 模, <span class="math inline">\(p \in Ass(M)\)</span>, 则 <span class="math inline">\(depth(M) = \dim(A/P)\)</span>. 从而 <span class="math inline">\(Ass(M)\)</span> 中元素没有包含关系.</li><li>若 <span class="math inline">\(a_1, \cdots, a_r\)</span> 是 <span class="math inline">\(\mathfrak{m}\)</span>中的 <span class="math inline">\(M\)</span>-regular 序列, 取 <span class="math inline">\(M’ = M/(a_1, \cdots, a_r)M\)</span>. 则 <span class="math inline">\(M\)</span> 是 C.M. 当且仅当 <span class="math inline">\(M’\)</span> 是 C.M.</li><li>若 <span class="math inline">\(M\)</span> 是 C.M. 模, 则对任意 <span class="math inline">\(P \in Spec(A)\)</span>, <span class="math inline">\(A_P\)</span> 模 <span class="math inline">\(M_P\)</span> 是 C.M. 模, 且当 <span class="math inline">\(M_P \neq 0\)</span> 时, <span class="math inline">\(depth_P(M) = depth _{A_P} M_P = \dim M_P\)</span></li></ol><p><strong>Proof</strong>:</p><ol type="1"><li><p>由于 <span class="math inline">\(Ass(M) \neq 0\)</span>, 所以 <span class="math inline">\(M \neq 0\)</span>, 因此 <span class="math inline">\(depth(M) = \dim M\)</span>. 又因为 <span class="math inline">\(P \in Supp(M)\)</span>, 我们有 <span class="math inline">\(\dim M \geq \dim A/P \geq depth M\)</span>. 证毕.</p></li><li><p>由 <strong>NAK lemma</strong>, 我们有 <span class="math inline">\(M = 0 \Longleftrightarrow M’ = 0\)</span>. 若 <span class="math inline">\(M \neq 0\)</span>. 则由引理 5 知 <span class="math inline">\(\dim M’=\dim M -r\)</span>. 由 <span class="math inline">\(depth\)</span> 的 <span class="math inline">\(M\)</span>-regular 序列刻画知, <span class="math inline">\(depth M’ = depth M - r\)</span>.</p></li><li><p>我们假定 <span class="math inline">\(M_P \neq 0\)</span>. 此时 <span class="math inline">\(P \supseteq Ann(M)\)</span>. 我们有 <span class="math inline">\(\dim M_P \geq depth_{A_P} M_P \geq depth_P(M)\)</span>. 对 <span class="math inline">\(depth_P(M)\)</span> 数学归纳, 若 <span class="math inline">\(depth_P(M) = 0\)</span>, 则 <span class="math inline">\(P\)</span> 包含于某个 <span class="math inline">\(P’ \in Ass(M)\)</span>. 因为 <span class="math inline">\(Ann(M) \subseteq P \subseteq P’\)</span>. 由 1)的结论, 包含 <span class="math inline">\(Ass(M)\)</span> 中的素理想是包含 <span class="math inline">\(Ann(M)\)</span> 的极小素理想, 从而 <span class="math inline">\(P = P’\)</span>. 从而 <span class="math inline">\(\dim M_P = 0\)</span>. 若 <span class="math inline">\(depth_P(M)&gt;0\)</span>, 取一个 <span class="math inline">\(M\)</span>-regular 元 <span class="math inline">\(a \in P\)</span>, 记 <span class="math inline">\(M_1 = M/aM\)</span>. 由于局部化函子是正合的, <span class="math inline">\(a\)</span> 也是 <span class="math inline">\(M_P\)</span>-regular. 因此 <span class="math inline">\(\dim (M_1)_P = \dim M_P/aM_P = \dim M_P-1\)</span> 且 <span class="math inline">\(depth_P(M_1) = depth_P(M) - 1\)</span>. 由 2) <span class="math inline">\(M_1\)</span> 是 C.M. 从而由归纳法, <span class="math inline">\(\dim (M_1)_P = depth_P(M_1)\)</span>, 证毕.</p></li></ol><p>引理 7: 设 <span class="math inline">\((A, \mathfrak{m})\)</span> 是 C.M. 局部环, 则对任意序列 <span class="math inline">\(a_1, \cdots, a_r \in \mathfrak{m}\)</span>, 下列条件等价:</p><ol type="1"><li><span class="math inline">\(a_1, \cdots, a_r\)</span> 是 <span class="math inline">\(A\)</span>-regular 序列</li><li><span class="math inline">\(ht(a_1, \cdots, a_i) = i (1 \leq i \leq r)\)</span></li><li><span class="math inline">\(ht(a_1, \cdots, a_r) = r\)</span></li><li>存在 <span class="math inline">\(a_{r+1} \cdots a_n \in \mathfrak{m}, (n = \dim A)\)</span> 使得 <span class="math inline">\(\lbrace a_1, \cdots a_n \rbrace\)</span> 是 SOP.</li></ol><p><strong>Proof</strong>: <span class="math inline">\(1 \to 2\)</span>: 由广义 Krull 定理: <span class="math inline">\(ht(a_1, \cdots, a_i) \leq i\)</span>, 再由 <span class="math inline">\(a_1, \cdots, a_r\)</span> 是 <span class="math inline">\(A\)</span>-regular 序列知 <span class="math inline">\(ht(a_1, \cdots, a_i) \geq i\)</span>. <span class="math inline">\(2 \to 3\)</span> 显然, <span class="math inline">\(3 \to 4\)</span>: 若 <span class="math inline">\(\dim A = r\)</span> 则结论是平凡的. 若 <span class="math inline">\(\dim A &gt; r\)</span>, 则可以找到 <span class="math inline">\(a_{r+1} \in \mathfrak{m}\)</span> 不在包含 <span class="math inline">\((a_1, \cdots, a_r)\)</span> 的极小素理想中, 从而 <span class="math inline">\(ht(a_1, \cdots, a_{r+1}) = r+1\)</span>. 于是一直这样进行下去即可. <span class="math inline">\(4 \to 1\)</span>: 只需证明每个 SOP <span class="math inline">\(x_1, \cdots, x_n\)</span> 都是 <span class="math inline">\(A\)</span>-regular 序列. 若 <span class="math inline">\(P \in Ass(A)\)</span>, 则 <span class="math inline">\(\dim A/P = n\)</span>. 因此 <span class="math inline">\(x_1 \notin P\)</span>(否则它在 <span class="math inline">\(A/P\)</span> 下的像怎么生成 <span class="math inline">\(\mathfrak{m}/P\)</span>). 因此 <span class="math inline">\(x_1\)</span> 是 <span class="math inline">\(A\)</span>-regular. 记 <span class="math inline">\(A’ = A/(x_1)\)</span>. 则 <span class="math inline">\(A’\)</span> 是 C.M. 维数为 <span class="math inline">\(n-1\)</span> 局部环. 由归纳法结论成立.</p><p>设 <span class="math inline">\(I\)</span> 是 C.M. 局部环 <span class="math inline">\((A, \mathfrak{m})\)</span> 的真理想, 则</p><ol type="1"><li><span class="math inline">\(ht(I) = depth_I(A) = \dim A - \dim(A/I)\)</span></li><li>对任意素理想 <span class="math inline">\(p \subset q, ht(q) = ht(p) + ht(q/p)\)</span>. <strong>Proof</strong>: 1. <span class="math inline">\(ht(I) = r\)</span>. 我们可以选择 <span class="math inline">\(a_1, \cdots, a_r \in I\)</span> 使得 <span class="math inline">\(ht(a_1, \cdots, a_i) = i \quad 1 \leq i \leq r\)</span>. 由引理 7, <span class="math inline">\(a_1, \cdots, a_r\)</span> 是 <span class="math inline">\(I\)</span> 中 <span class="math inline">\(A\)</span>-regular 序列. 从而 <span class="math inline">\(ht(I) \leq depth_I(A)\)</span>. 另一方面, 若 <span class="math inline">\(b_1, \cdots, b_s\)</span> 是 <span class="math inline">\(I\)</span> 中 <span class="math inline">\(A\)</span>-regular 序列, 则 <span class="math inline">\(ht(b_1, \cdots, b_s) = s \leq ht(I)\)</span>. 因此 <span class="math inline">\(ht(I) = depth_I(A)\)</span>. 由于 <span class="math inline">\(ht(I) = \inf \lbrace ht(P) \mid P \in V(I) \rbrace\)</span>, <span class="math inline">\(\dim(A/I) = \sup \lbrace \dim A/P \mid P \in V(I) \rbrace\)</span>. 若 <span class="math inline">\(ht(P) = \dim(A) - \dim(A/P)\)</span>, 对任意 <span class="math inline">\(P \in Spec(A)\)</span> 成立, 那么 <span class="math inline">\(ht(I) = \dim A - \dim(A/I)\)</span> 显然也成立. 由于 <span class="math inline">\(A_P\)</span> 是 C.M. 环, <span class="math inline">\(ht(P) = \dim(A_P) = depth_P(A)\)</span>. 从而我们可以找 <span class="math inline">\(P\)</span> 中一个 <span class="math inline">\(A\)</span>-regular 序列 <span class="math inline">\(a_1, \cdots, a_r\)</span>. <span class="math inline">\(A/(a_1, \cdots, a_r)\)</span> 是维数为 <span class="math inline">\(n-r\)</span> 的 C.M. 环, <span class="math inline">\(P\)</span> 是包含 <span class="math inline">\(a_1, \cdots, a_r\)</span> 的极小素理想. 从而 <span class="math inline">\(\dim(A/P) - n-r\)</span>(由上面的性质).</li><li>若 <span class="math inline">\(p supset q\)</span> 是 <span class="math inline">\(A\)</span> 的素理想, 则 <span class="math inline">\(A_q\)</span> 是 C.M. 环, 从而 <span class="math inline">\(\dim A_q = ht pA_q + \dim A_q / pA_q\)</span>. 即 <span class="math inline">\(ht(q) = ht(p) + ht(q/p)\)</span>.</li></ol><p><strong>Cohen-Macauly Ring</strong> 称一个 Noetherian 环 <span class="math inline">\(A\)</span> 是 Cohen-Macaulay 如果对任意 <span class="math inline">\(A_P \in Spec(A)\)</span>, <span class="math inline">\(A_P\)</span> 是 C.M. local ring. 实际上只要在对 <span class="math inline">\(A_P \in \omega(A)\)</span> 成立即可.</p><p>设 <span class="math inline">\(A\)</span> 是 Cohen-Macaulay 环, 则多项式环 <span class="math inline">\(A[x_1, \cdots, x_n]\)</span> 也是 Cohen-Macaulay 环.</p><h2 id="to-be-continue">To be Continue</h2>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>T.Y.Lam《Lecture on Modules and Rings》读书笔记</title>
    <link href="/LectureOnModuleAndRing/"/>
    <url>/LectureOnModuleAndRing/</url>
    
    <content type="html"><![CDATA[<p>为了把看过的知识变成自己的东西，在此理一下思路（导师建议学的东西记录一下，不然以后过不了多久又忘了，花了时间就要有收获）</p><span id="more"></span><h2 id="自由模">自由模</h2><p>给定一个环 <span class="math inline">\(R\)</span>，其上(右)自由模 <span class="math display">\[F_R = R^{(I)} = \bigoplus_{i \in I} R_i, \quad R_i = R\]</span></p><p>有两种等价刻画：</p><ol type="1"><li><p><span class="math inline">\(F_R\)</span> 有一组基 <span class="math inline">\(\lbrace e_i : i \in I \rbrace \subset F\)</span> 使得 <span class="math inline">\(F_R\)</span> 上任意元素都可以唯一的写成 <span class="math inline">\(e_i\)</span> 的 <span class="math inline">\(R\)</span>-线性组合</p></li><li><p><span class="math inline">\(F_R\)</span> 有一组基 <span class="math inline">\(\lbrace e_i : i \in I \rbrace \subset F\)</span> 满足“universal property”: 对 <span class="math inline">\(M_R\)</span> 中任意 <span class="math inline">\(\lbrace m_i : i \in I \rbrace\)</span> 有唯一的 <span class="math inline">\(R\)</span> 模同态 <span class="math inline">\(f: R_R \to M_R\)</span> 使得 <span class="math inline">\(f(e_i) = m_i ,i \in I\)</span></p><blockquote><p><span class="math inline">\(R^I\)</span> 表示 <span class="math inline">\(R\)</span> 的 <span class="math inline">\(I\)</span> 次积, 当指标集 <span class="math inline">\(I\)</span> 有限时, 积与直和(余积)等价,此时 <span class="math inline">\(R^{(I)}\)</span> 通常写成 <span class="math inline">\(R^n\)</span></p></blockquote></li></ol><h3 id="ibn-invariant-basis-number-性质">IBN (Invariant Basis Number) 性质</h3><p><strong>Generation Lemma</strong> 表明，对任意模，若 <span class="math inline">\({e_i : i \in I}\)</span> 是其一族极小生成集，且 <span class="math inline">\(I\)</span> 是无限集，则 <span class="math inline">\(M\)</span> 不能由基数小于 <span class="math inline">\(I\)</span> 的集合生成。</p><p>由 <strong>Generation Lemma</strong> 可知，若 <span class="math inline">\(R^{(I)} = R^{(J)}\)</span>,且 <span class="math inline">\(I\)</span> 无限，那么 <span class="math inline">\(|I| = |J|\)</span>，但是当 <span class="math inline">\(I\)</span> 有限时，结论并不一定成立，例如 <span class="math inline">\(R = End(_kV)\)</span>,其中 <span class="math inline">\(V\)</span> 为可数无穷维空间，则 <span class="math inline">\(R \simeq R^2\)</span>. 因此提出 <strong>IBN​</strong> 的概念：</p><p><strong>IBN (Invariant Basis Number)</strong> 称环 <span class="math inline">\(R\)</span> 满足 <strong>IBN</strong> 性质，如果对任意 <span class="math display">\[m,n \in \mathbb{N}, R^m \simeq R^n \Longrightarrow m=n\]</span> 由定义不难看出，<span class="math inline">\(R\)</span> 不满足 IBN 性质，当且仅当, 存在 <span class="math inline">\(R\)</span> 上 <span class="math inline">\(m×n\)</span> 矩阵 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(n×m\)</span> 矩阵 <span class="math inline">\(B\)</span> 使得 <span class="math display">\[AB = I_n, BA =I_m\]</span> 因此 IBN 性质是对称概念.</p><blockquote><p>由 IBN 上述等价定义知 <span class="math inline">\(f: R \to S \neq 0\)</span> 为环同态，则 <span class="math inline">\(S\)</span> 满足 IBN 性质可推出 <span class="math inline">\(R\)</span> 满足 IBN 性质。</p></blockquote><p>由上面的结论又可以给出很多满足 IBN 性质的例子： Divison rings, local rings, semilocal rings, nonzero commutative rings, finite rings.</p><h3 id="stably-finiteness">stably finiteness</h3><p>称环 <span class="math inline">\(R\)</span> 为 stably finite，如果对任意 <span class="math inline">\(n\)</span> <span class="math display">\[R^n \simeq R^n \oplus N \Longrightarrow N=0\]</span> 等价定义:</p><ol type="1"><li>对任意 <span class="math inline">\(n\)</span>, <span class="math inline">\(R^n\)</span> 是 hopfian</li><li>对任意 <span class="math inline">\(n\)</span>, <span class="math inline">\(M_n(R)\)</span> 是 Dedekind-finite 的.</li></ol><p>由 2 可知 stably finite 是对称概念.</p><blockquote><p>由 <span class="math inline">\(Mn(R)\)</span> Dedekind-finite 可知: 若 <span class="math inline">\(g:R→S\)</span> 是嵌入(单射)同态(不要求幺元映成幺元), 那么若<span class="math inline">\(S\)</span> stable finite, 则 <span class="math inline">\(R\)</span> 也是.</p></blockquote><p>由上可知: <span class="math display">\[\prod _{i \in I} R_i \quad \text{ stably finite } \iff R _i \quad \text{ stably finite for all } i\]</span> <strong>例子</strong>: Commutative Rings, Noetherian Rings</p><p><strong>性质</strong>: 若环 <span class="math inline">\(R\)</span> 不是 stably finite, 我们可以做一个最大的商环 <span class="math inline">\(\bar{R}\)</span> 使得 <span class="math inline">\(\bar{R}\)</span> stably finite. <span class="math inline">\(\bar{R}\)</span>可以如下构造, 并可以说明它确实 stably finite. 设 <span class="math inline">\(T\)</span> 为所有形式 <span class="math inline">\(I-YX\)</span> ( 方阵<span class="math inline">\(X\)</span>,<span class="math inline">\(Y\)</span>满足<span class="math inline">\(XY = I\)</span>的中元素生成的理想。可以证明: <span class="math inline">\(\bar{R} = R/T\)</span></p><p>自然地, 我们要问啥时候 <span class="math inline">\(\bar{R} = 0\)</span>? 这当且仅当存在 <span class="math inline">\(C,D \in M_m(R)\)</span>,行向量<span class="math inline">\(x\)</span>,列向量<span class="math inline">\(y\)</span> 使得 <span class="math display">\[x(I-DC)y = 1\]</span></p><h3 id="rank-condition">rank condition</h3><p>称环 <span class="math inline">\(R\)</span> 满足 rank condition, 如果对任意 <span class="math inline">\(n\)</span>, <span class="math inline">\(R_n\)</span> 中生成元的个数都大于<span class="math inline">\(n\)</span>. 等价定义 1: 任意满同态 <span class="math inline">\(f: R^m \to R^n\)</span>可推出 <span class="math inline">\(m \geq n\)</span>. 等价定义 2: 环 <span class="math inline">\(R\)</span> 不满足 rank condition, 当且仅当, 存在 <span class="math inline">\(n&gt;k \geq 1\)</span>, 那么存在 <span class="math inline">\(n \times k\)</span> 矩阵 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(k×n\)</span> 矩阵 <span class="math inline">\(B\)</span>使得<span class="math inline">\(AB=I_n\)</span></p><blockquote><p>由上面等价定义 2 知道 rank condition 是个对称的概念.</p></blockquote><p>若有环同态 <span class="math inline">\(f:R→S\)</span>, 其中 <span class="math inline">\(S\)</span> 满足 rank condition, 那么 <span class="math inline">\(R\)</span> 也满足.</p><p>rank condition 与 stably finite 以及 IBN 之间的关系 <span class="math inline">\(R \neq 0\)</span>: <span class="math display">\[\text{stably finite} \Longrightarrow \text{rank condition} \Longrightarrow \text{IBN}\]</span> 套用一下定义,以及它们各自的等价定义,逆反命题就可以证明.</p><blockquote><p>stably finite 与 rank conditon 的密切联系</p></blockquote><p>对任意环 <span class="math inline">\(R\)</span>, 下面结果等价:</p><ol type="1"><li><span class="math inline">\(R\)</span> 满足 rank condition</li><li><span class="math inline">\(\bar{R} \neq 0\)</span></li><li><span class="math inline">\(R\)</span> 有一个非零 stably finite 的同态像</li><li>对任意 <span class="math inline">\(n \in \mathbb{N}, \quad C,D \in M_n(R)\)</span>，若 <span class="math inline">\(CD=I_n\)</span>, 则对任意行向量 <span class="math inline">\(x\)</span> 和列向量 <span class="math inline">\(y\)</span>, <span class="math inline">\(x(I-DC)y \neq 1\)</span></li></ol><p>这里难点在于 1 推出 4, 可以用反证法, 用增广矩阵得到 <span class="math display">\[\begin{pmatrix} C \\ x(I-DC) \end{pmatrix} \left(D ,(I-DC)y \right) = \begin{pmatrix} CD &amp; 0 \\ 0 &amp; x(I-DC) \end{pmatrix} = I_{m+1}\]</span></p><blockquote><p>在 simple ring 中 stably finite 等价于 rank condition</p></blockquote><h3 id="strong-rank-condition">strong rank condition</h3><p>称环 <span class="math inline">\(R\)</span> 满足 right strong rank condition, 如果对任意 <span class="math inline">\(n\)</span>, <span class="math inline">\(R^n\)</span> 中任意线性相关的元素个数不超过 <span class="math inline">\(n\)</span>. 等价定义 1: 任意单同态 <span class="math inline">\(f: R^m \to R^n\)</span> 可推出 <span class="math inline">\(m \leq n\)</span> 等价定义 2: 任意 <span class="math inline">\(m\)</span>个未定元 <span class="math inline">\(n &lt; m\)</span> 个方程的线性方程组在 <span class="math inline">\(R\)</span> 中必有非零解.(用线性相关的定义可知)</p><blockquote><p>实际上 strong rank condition 不是对称概念, 所以严格上, 我们要指出 left, right.</p></blockquote><p>由 (strong) rank condition 的等价定义可知:</p><blockquote><p>由于 <span class="math inline">\(R^n\)</span> 是自由<span class="math inline">\(R\)</span>- 模,因此,可以推出 right strong rank condition 可推出 rank condition.</p></blockquote><p><strong>注意</strong> right strong rank condition 不像之前的满足 <span class="math inline">\(f: R \to S\)</span>, 满足”性质”, 则 <span class="math inline">\(R\)</span> 满足”性质”.</p><p><span class="math inline">\(A \times B\)</span> 满足 (right) strong rank condition (RSRC) 当且仅当 <span class="math inline">\(A\)</span> 或者 <span class="math inline">\(B\)</span> 满足 RSRC</p><p>由上面性质知道, stably finite 和 strong rank condition 是两个独立的概念, 彼此不搭嘎. 例如:</p><ol type="1"><li><span class="math inline">\(R = \mathbb{Q} &lt; x, y&gt;\)</span> 是 stably finite, 但不满足 RSRC.</li><li>而由上面性质知道, 我们只要构造一个满足 RSRC 和一个不满足 stably finite 的积即可.</li></ol><p>满足 RSRC 的例子: Noetherian rings, Commutative Rings.</p><blockquote><p>最后给出一个线性无关的等价定义:</p></blockquote><p><span class="math inline">\(u_1,\cdots,u_m\)</span> 在 <span class="math inline">\(M = R^n\)</span> 中线性无关, 当且仅当 <span class="math display">\[0 \neq u_1 \wedge \cdots \wedge u_m \in \bigwedge ^m (M)\]</span></p><h3 id="总结图">总结图</h3><p>自由模下的关系(任意箭头一般都不可逆):</p><figure><img src="MRing1.png" alt="MRing1" /><figcaption aria-hidden="true">MRing1</figcaption></figure><p>一般地, Dedekind finite + Rank condition 依然无法推出 stably finite. 例如:</p><p>设 <span class="math inline">\(R\)</span> 为由元素<span class="math inline">\(s,t,u,v;w,x,y,z\)</span> 生成的 <span class="math inline">\(k\)</span> 代数,设 <span class="math inline">\(A = \begin{pmatrix} s &amp; u \\ t &amp; v \end{pmatrix}, B = \begin{pmatrix} x &amp; y \\ z &amp; w \end{pmatrix}\)</span> ,其中生成元满足关系: <span class="math display">\[AB=I_2\]</span></p><p>由此可知, <span class="math inline">\(R\)</span> 是 domain, 但是一般地, <span class="math inline">\(BA \neq I_2\)</span> 因此 <span class="math inline">\(M_2(R)\)</span> 不是 Dedekind finite 的. 因此 <span class="math inline">\(R\)</span> 不满足 stably finite 条件. 定义 <span class="math inline">\(f: R \to k\)</span> 为 <span class="math inline">\(f(s)=f(v) = f(x) = f(w) = f(1) = 1\)</span>, <span class="math inline">\(f(u) = f(t) = f(y) = f(z) = 0\)</span>. 因此由 <span class="math inline">\(k\)</span> 满足 rank condition, so is <span class="math inline">\(R\)</span>.</p><h2 id="投射模">投射模</h2><h3 id="投射模的定义">投射模的定义</h3><p>称一个右 <span class="math inline">\(R\)</span>-模 <span class="math inline">\(P\)</span> 为 projective module（投射模）,如果 对任意 <span class="math inline">\(R\)</span> 模满同态 <span class="math inline">\(g:B\to C\)</span> 和任意 <span class="math inline">\(R\)</span> 模同态 <span class="math inline">\(h:P\to C\)</span>,存在 <span class="math inline">\(R\)</span> 模同态 <span class="math inline">\(h’: P \to B\)</span> 使得 <span class="math inline">\(h = gh’\)</span></p><blockquote><p>由定义显然自由模都是投射模.</p></blockquote><p>等价定义: 从右模范畴到 Abel 范畴 <span class="math inline">\(\hom(P,-)\)</span> 的函子是 exact functor(正合函子). 由定价定义易知:</p><p><span class="math display">\[\bigoplus_{i \in I} P_i \text{ 投射当且仅当 } P_i, i\in I \text{ 投射 }\]</span> 由之前说明的自由模都是投射模可知以下条件等价</p><ol type="1"><li><span class="math inline">\(P_R\)</span> 投射</li><li><span class="math inline">\(P_R\)</span> 是某个自由 <span class="math inline">\(R\)</span> 模的直和因子</li><li>任意满同态 <span class="math inline">\(B_R\to P_R\)</span> 可裂</li></ol><p>由此可知:(Eilenberg’s Trick) 若 <span class="math inline">\(P_R\)</span> 投射,则存在自由模 <span class="math inline">\(F_R\)</span> 使得 <span class="math inline">\(P \oplus F \simeq F\)</span></p><blockquote><p>Proof: 由 <span class="math inline">\(P_R\)</span> 投射模, 所以存在 <span class="math inline">\(Q_R\)</span> 使得 <span class="math inline">\(P \oplus F \simeq F\)</span> 为自由模, 取 <span class="math inline">\(F\)</span> 为 <span class="math inline">\(E\)</span> 的可数直和即可.</p></blockquote><p>不是投射 <span class="math inline">\(\mathbb{Z}\)</span> 模的例子: <span class="math display">\[\mathbb{Z} / 2 \mathbb{Z}, \quad M = \mathbb{Z} \times \mathbb{Z} \times \cdots\]</span> 一个有趣的结果: 设 <span class="math inline">\(P = \mathbb{Z} \oplus \mathbb{Z} \oplus \cdots \subset M\)</span>, 则 <span class="math inline">\(\hom_{\mathbb{Z}}(M/P,\mathbb{Z}) = 0\)</span> 证明关键点在于 <span class="math inline">\(M = A_2 + A_3\)</span>, 其中 <span class="math inline">\(A_k = \lbrace (k a_1,k^2 a_2,\cdots,k^n a_n,\cdots): a_i \in \mathbb{Z} \rbrace\)</span>, 然后说明 <span class="math inline">\(A_k\in P\)</span>, 且 <span class="math inline">\(f(M)=f(A_2)+f(A_3) \subset f(P)\)</span> 即可.</p><h3 id="dual-basis对偶基">Dual Basis(对偶基)</h3><p><span class="math inline">\(P_R\)</span> 是投射模, 当且仅当它有对偶基, 即存在一族元素 <span class="math inline">\(\lbrace a_i: i\in I \rbrace \subset P\)</span> 和线性函数 <span class="math inline">\(\lbrace f_i: i \in I \rbrace \subset P^{\star} = \hom(P,R)\)</span> 使得对任意 <span class="math inline">\(a \in P\)</span>, 只有有限个 <span class="math inline">\(f(a_i)\)</span> 非零, 且 <span class="math inline">\(a = \sum a_i f_i (a)\)</span>.</p><p>对任意 <span class="math inline">\(R\)</span>-模 <span class="math inline">\(M_R\)</span>, <span class="math inline">\(M^{\star} = \hom(M,R)\)</span> 是左 <span class="math inline">\(R\)</span>-模, <span class="math inline">\(M^{\star \star} = \hom(M^{\star} ,R)\)</span> 是右 <span class="math inline">\(R\)</span>-模, 我们有自然的右模同态, <span class="math inline">\(\epsilon: M \to M^{\star \star}\)</span> 定义为: <span class="math inline">\(\epsilon(a) = \hat{a}\)</span>, 其中 <span class="math inline">\(\hat{a} (f) = f(a)\)</span> 为求值函数.</p><blockquote><p>特别地, 当 <span class="math inline">\(M_R\)</span> 是投射的, <span class="math inline">\(\epsilon\)</span> 是单同态, <span class="math inline">\(M_R\)</span> 是有限生成投射时, <span class="math inline">\(\epsilon\)</span>为同构.</p></blockquote><p>例: <span class="math inline">\(e \in R\)</span> 为幂等元, 则 <span class="math inline">\(R = eR \oplus (1-e)R\)</span>, 所以, <span class="math inline">\(P = eR\)</span> 为有限生成投射模.</p><h3 id="invertible-modules-and-fractional-ideals可逆模可逆理想">Invertible Modules and Fractional Ideals(可逆模,可逆理想)</h3><blockquote><p>此小节中默认 <span class="math inline">\(R\)</span> 为交换环</p></blockquote><p>很大一类的交换环上的投射模是由环扩张 <span class="math inline">\(S \supset R\)</span> 得到的. 现在, 给定(交换)环扩张 <span class="math inline">\(S \supset R\)</span>. 考虑模 <span class="math inline">\(S\)</span> 的 <span class="math inline">\(R\)</span>-子模, 设 <span class="math inline">\(P,Q\)</span> 为模 <span class="math inline">\(S\)</span> 的 <span class="math inline">\(R\)</span>-子模, 定义: <span class="math display">\[PQ = \lbrace \sum p_i q_i : p_i \in P, q_i \in Q \rbrace, \quad Q:P = \lbrace s \in S: sP \in Q \rbrace,\quad P^{-1} = \lbrace s \in S : sP \subset R \rbrace = R:P\]</span> 注意到 <span class="math inline">\(P^{-1}\)</span> 依赖于环扩张 <span class="math inline">\(S\)</span> 的选取.</p><p>由上面定义,我们立即有下面引理(条件 <code>1,2</code> 等价):</p><ol type="1"><li>存在 <span class="math inline">\(S\)</span> 的 <span class="math inline">\(R\)</span>-子模 <span class="math inline">\(Q\)</span> 使得 <span class="math inline">\(PQ = R\)</span></li><li><span class="math inline">\(PP^{-1} = R\)</span></li></ol><p>由于上述定价,我们把满足条件的 <span class="math inline">\(P\)</span> 称为 <strong>Invertible <span class="math inline">\(R\)</span>-submodule</strong> of <span class="math inline">\(S\)</span> 在此条件下,我们有:</p><ol type="1"><li><span class="math inline">\(P\)</span> 是有限生成投射 <span class="math inline">\(R\)</span>-模 (利用 <span class="math inline">\(\sum p_i q_i = 1\)</span>)</li><li>任意 <span class="math inline">\(R\)</span>-子模 <span class="math inline">\(M \in S\)</span>, 自然映射 <span class="math inline">\(f: P \otimes _R M \to PM\)</span> 是 <span class="math inline">\(R\)</span>-模同构</li><li><span class="math inline">\(P^{\star} \simeq P^{-1}\)</span> (因此 <span class="math inline">\(P^{\star}\)</span> 可以成 <span class="math inline">\(S\)</span> 的子模)</li><li><span class="math inline">\(P_R\)</span>是自由模,当且仅当存在<span class="math inline">\(s \in R\)</span>使得<span class="math inline">\(P = sR\)</span>(此时<span class="math inline">\(s\)</span>必然是<span class="math inline">\(s\)</span>中的可逆元)</li></ol><blockquote><p>结论 4 经常用于说明一个模是投射模但不是自由模.</p></blockquote><p>下面有一个很精彩的例子: 设<span class="math inline">\(R \subset S\)</span> 为交换环, <span class="math inline">\(g \in S\)</span>满足 <span class="math inline">\(g^2,g^3 \in R\)</span>, 即 <span class="math inline">\(g^n \in R\)</span> 对 <span class="math inline">\(n&gt;1\)</span> 成立. 定义<span class="math inline">\(P_r = (1+rg, g^2)\)</span>, 那么 <span class="math display">\[P_r P_s = (1+rg,g^2)(1+sg,g^2) = (1+(r+s)g+rsg^2,g^2+sg^3,g^2+rg^3,g^4)\]</span> 显然上面集合包含 <span class="math inline">\(g^2(1+(r+s)g+rsg^2)-rsg^4 = g^2 +(r+s)g^3\)</span>, 因此包含 <span class="math inline">\(rg^3,sg^3,g^2,1+(r+s)g\)</span>, 因此 <span class="math display">\[P_r P_s = (1+(r+s)g,g^2,rg^3,sg^3)\]</span> 再由 <span class="math inline">\(g^3(1+(r+s)g) - (r+s)g^2g^2 = g^3\)</span> 可知:</p><p><span class="math display">\[P_r P_s = (1+(r+s)g,g^2) = P_{r+s}\]</span></p><p>因此 <span class="math inline">\(P_r P_{-r} = P_0 = (1, g^2) = R\)</span>, 即 <span class="math inline">\(\lbrace P_r: r \in R \rbrace\)</span> 是一族 Invertible <span class="math inline">\(R\)</span>-submodule of <span class="math inline">\(S\)</span>(因此投射), 且 <span class="math inline">\(P^{\star} = P_r^{-1} = P_{-r}\)</span>. <span class="math inline">\(P_r\)</span> 是 <span class="math inline">\(R\)</span>-free 当且仅当 <span class="math inline">\(u(1+rg) \in R\)</span> 对所有的 <span class="math inline">\(u \in U(R[g])\)</span></p><blockquote><p>之前说过 <span class="math inline">\(P^{-1}\)</span> 依赖于 <span class="math inline">\(R\)</span> 的扩张 <span class="math inline">\(S\)</span> 的选取,现在我们在 <span class="math inline">\(R\)</span> 的所有 regular element(正则元)这个乘闭子集 <span class="math inline">\(C_R\)</span> 上做局部化得到环 <span class="math inline">\(K\)</span>, 那么自然映射此时是单同态, 因此局部化得到的环可以看做 <span class="math inline">\(R\)</span> 的扩张(由 <span class="math inline">\(R\)</span> 唯一决定). 且对任意 <span class="math inline">\(k \in K\)</span>, 都存在 regular element <span class="math inline">\(u\)</span> 使得 <span class="math inline">\(u_k \in R\)</span>.</p></blockquote><p>称 <span class="math inline">\(K\)</span> 的 <span class="math inline">\(R\)</span>-子模为 <strong>fractional ideal(分次理想)</strong> 通常记为 <span class="math inline">\(\mathfrak{A}\)</span></p><p>引理: 对任意 fractional ideal <span class="math inline">\(\mathfrak{A} \subset K\)</span> 且 <span class="math inline">\(\mathfrak{A} \cap C_R \neq \emptyset\)</span>, 则有 <span class="math inline">\(\hom(\mathfrak{A}, K) \simeq K\)</span>.</p><p>Proof: 作映射 <span class="math inline">\(\lambda : K \to \hom_R(\mathfrak{A},K)\)</span> 为: <span class="math inline">\(\lambda(k)(a) = ka\)</span>, 证明单满即可.</p><p>对任意 fractional ideals <span class="math inline">\(\mathfrak{A},\mathfrak{B} \subset K\)</span>, 我们也有类似引理的证明: 当 <span class="math inline">\(\mathfrak{A} \cap C_R \neq \emptyset\)</span> <span class="math display">\[\hom_ R(\mathfrak{A},\mathfrak{B}) \simeq \mathfrak{B}:\mathfrak{A}\]</span></p><blockquote><p>特别地, 若 <span class="math inline">\(\mathfrak{A} \cap C_R \neq \emptyset\)</span>, 则 <span class="math inline">\(\mathfrak{A}^{\star} = \mathfrak{A} ^{-1} = R:\mathfrak{A}\)</span>.</p></blockquote><p>对任意 fractional ideal <span class="math inline">\(\mathfrak{A} \subset K\)</span>, 下面等价:</p><ol type="1"><li><span class="math inline">\(\mathfrak{A}\)</span> 是 invertible module(<span class="math inline">\(\mathfrak{A} \mathfrak{A}^{-1} = R\)</span>)</li><li><span class="math inline">\(\mathfrak{A}\)</span> 是投射模,且 <span class="math inline">\(\mathfrak{A} \cap C_R \neq \emptyset\)</span></li><li><span class="math inline">\(\mathfrak{A}\)</span> 是有限生成投射模,且 <span class="math inline">\(\mathfrak{A} \cap C_R \neq \emptyset\)</span> &gt; 此条件下 <span class="math inline">\(\mathfrak{A}\)</span> 自由模当且仅当 存在 <span class="math inline">\(s \in K\)</span> 使得 <span class="math inline">\(\mathfrak{A} = sR\)</span>(此时 <span class="math inline">\(s \in U(K)\)</span>)</li></ol><p>由上可知: 若 <span class="math inline">\(R \neq K\)</span>, 则 <span class="math inline">\(K\)</span> 不是投射模.</p><p>Proof: 如果是, 那么必然有限生成投射, 因此 <span class="math display">\[K= \sum _{i=1} ^n R c_i d _i ^{-1} (c_i \in R, d _i \in C_R)\]</span> 那么 <span class="math inline">\(d = d_1 \cdots d_n \subset U(K)\)</span>, 我们有 <span class="math inline">\(K = dK \subset R\)</span> 矛盾于条件.</p><blockquote><p>因此 <span class="math inline">\(\mathbb{Q}_{\mathbb{Z}}\)</span> 不是投射模.</p></blockquote><h3 id="交换环上的-picard-group">交换环上的 Picard Group</h3><p>实际上, 第二小节和第三小节中的 Invertible Module 都是”秩为 1”的有限生成投射模, 对于交换环, 秩的概念定义如下:</p><p>由于若 <span class="math inline">\(P,Q\)</span> 为<span class="math inline">\(R\)</span>-模, <span class="math inline">\(P \otimes Q\)</span> 也是 <span class="math inline">\(R\)</span>-模, 且当 <span class="math inline">\(P,Q\)</span> 投射时, <span class="math inline">\(P \otimes Q\)</span> 也是投射模.</p><p>当 <span class="math inline">\(P\)</span> 是有限生成投射<span class="math inline">\(R\)</span>-模时, 对于 <span class="math inline">\(R\)</span> 的任意素理想 <span class="math inline">\(\mathfrak{p}\)</span>, 在其上局部化得到 <span class="math inline">\(P_{\mathfrak{p}} = P \bigotimes_{R} R_{\mathfrak{p}}\)</span> 也是有限生成投射的. 由于 <span class="math inline">\(R_{P}\)</span> 交换局部环, 因此 <span class="math inline">\(P_{\mathfrak{p}}\)</span> 是自由的(交换局部环上有限生成投射模是自由模).因此就有秩, 也就是说我们有从 <span class="math inline">\(R\)</span> 的素谱到 <span class="math inline">\(\mathbb{Z}\)</span>(带离散拓扑)的一个连续映射. 当这个映射是常值映射时(这要求 <span class="math inline">\(R\)</span> 中无非平凡幂等元),就称这个常值为投射模 <span class="math inline">\(P\)</span> 的秩.</p><blockquote><p>注意到若 <span class="math inline">\(rk(P)=n,rk(Q)=m\)</span> 那么 <span class="math inline">\(rk(P^{\star})=n, rk(P \otimes Q) = mn\)</span></p></blockquote><p><strong>引理</strong> 设 <span class="math inline">\(R \subset S\)</span> 为交换环, 那么在任意 <span class="math inline">\(S\)</span> 的可逆 <span class="math inline">\(R\)</span>-子模都是秩为 1 的投射模.</p><p>Proof: 用一个 Invertible Module(可逆模)的定义, 以及成为自由模的条件, 即可证明.</p><p>设 <span class="math inline">\(Pic(R)\)</span> 为 <span class="math inline">\(R\)</span> 上所有秩为 1 的有限生成投射模的同构等价类. 将 <span class="math inline">\(P\)</span> 的等价类记作 <span class="math inline">\([P]\)</span> 我们定义乘法(满足结合律, 交换律): <span class="math display">\[[P][Q] = [P \otimes Q]\]</span> <span class="math inline">\([R]\)</span> 成为 <span class="math inline">\(Pic(R)\)</span> 中的幺元, <span class="math inline">\([P]^{-1} = [P^{\star}]\)</span>. 即 <span class="math inline">\(Pic(R)\)</span> 关于上述乘法构成 Abelian group. 称为交换环 <span class="math inline">\(R\)</span> 的 Picard group.</p><blockquote><p>实际上 “Pic” 还是交换环范畴到 Abelian group 范畴的函子.</p></blockquote><p>具体到 <span class="math inline">\(R \subset K\)</span>, <span class="math inline">\(K\)</span> 中所有 invertible fractional ideals 是 <span class="math inline">\(R\)</span> 上秩为 1 的有限生成投射模(记为 <span class="math inline">\(I_{R}\)</span>) 但是一般地 <span class="math inline">\(R\)</span> 上所有秩为 1 的有限生成投射模并不一定同构与某个 invertible fractional ideal.</p><p><strong>定理</strong> 对自然映射 <span class="math inline">\(f: R \to K\)</span>, 我们有正合列 <span class="math display">\[ 1 \to U(R) \to U(R) \to I_{R} \to Pic(R) \to Pic(K)\]</span></p><h3 id="semihereditary-rings">(semi)Hereditary Rings</h3><p>在交换环中, Dedekind (domain) ring 定义为交换整环 <span class="math inline">\(R\)</span>, 所有理想都是 Invertible Ideal(或者说投射的). 这说明 <span class="math inline">\(R\)</span> 必然是 Noetherian domain. 因此 Dedekind ring 也可以定义为 Noetherian domain 中整闭的 Krull 维数为小于等于 1 的环, 也可以定义为满足每个理想都是一些素理想的有限积的交换整环.</p><p>把上述 Dedekind ring 推广到非交换的情形, 我们有如下 <strong>Hereditary ring</strong> 的定义: A ring <span class="math inline">\(R\)</span> 称为右(左)Hereditary ring, 如果它的每个右(左)理想都是投射的, 如果它既为左又右,那么就成为 Hereditary ring.</p><p><strong>Kaplansky’s Theorem</strong> 设 <span class="math inline">\(R\)</span> 为 right Hereditary ring. 任意 <span class="math inline">\(R\)</span>-自由模的子模 <span class="math inline">\(P\)</span> 都同构于 <span class="math inline">\(R\)</span> 的一些理想的直和. 特别地, <span class="math inline">\(P\)</span> 是投射的.</p><p>由于每个模都可以看成自由模的同态像, 投射模是某个自由模的直和因子, 又由 Kaplansky 定理知:</p><ol type="1"><li>在一个 right hereditary <span class="math inline">\(R\)</span> 上, 一个 <span class="math inline">\(R\)</span>-模 <span class="math inline">\(P_R\)</span> 投射, 当且仅当它能嵌入到一个自由模中.</li><li>环 <span class="math inline">\(R\)</span> 投射, 当且仅当, 每个投射 <span class="math inline">\(R\)</span>-模的子模都是投射的.</li><li>若环 <span class="math inline">\(R\)</span> 是 PRID(principal right ideal domain), 那么每个自由 <span class="math inline">\(R\)</span>-模的子模都是自由的.</li></ol><p>类似于 Hereditary ring 的定义, 我们称一个环 <span class="math inline">\(R\)</span> 为 <strong>semihereditary ring</strong>:</p><p><span class="math inline">\(R\)</span> 称为右(左)semihereditary ring, 如果 <span class="math inline">\(R\)</span> 的每个 f.g.(finitely generate 有限生成)右(左)理想都是投射 <span class="math inline">\(R\)</span> 右(左)模. 如果既左又右, 称为 semihereditary ring. 我们称交换的 semihereditary ring 为 Prufer ring.</p><p>类似于 <strong>Kaplansky’s Theorem</strong> 我们有 <span class="math inline">\(R\)</span> 为 right semihereditary ring. 任意 <span class="math inline">\(R\)</span>-自由模的有限生成子模 <span class="math inline">\(P\)</span> 都同构与有限个 <span class="math inline">\(R\)</span> 的理想的直和.</p><blockquote><p>right semihereditary 的等价刻画:</p></blockquote><p><span class="math inline">\(R\)</span> 为 right semihereditary ring 当且仅当投射右 <span class="math inline">\(R\)</span> 模的有限生成子模都是投射的.</p><p>例子:</p><ol type="1"><li>Semisimple ring is hereditary.</li><li>PRID is right hereditary, 例如 <span class="math inline">\(D[x]\)</span>, 其中 <span class="math inline">\(D\)</span> 是 division ring.</li><li><span class="math inline">\(M_n(R)\)</span> is semihereditary, 其中 <span class="math inline">\(R\)</span> 为 Dedekind ring.</li><li>von Neumann regular ring is semihereditary.</li><li><span class="math inline">\(\begin{pmatrix} \mathbb{Z} &amp; \mathbb{Q} \\ 0 &amp; \mathbb{Q} \end{pmatrix}\)</span> 是 right hereditary, left semihereditary, but not left hereditary. Note that this example is also left artinain but not right Noetherian.</li></ol><h3 id="hereditary-artinian-ring">Hereditary Artinian Ring</h3><p>Hereditary Artinian ring 十分的重要(因为简单 0.0), 一般一个概念加上 Artinian 条件就会变得特别简单, 例如 Artinian commutative domain is field.</p><p>设 <span class="math inline">\(J = rad R\)</span> 为环 <span class="math inline">\(R\)</span> 的 Jacobison radical. 若 <span class="math inline">\(R\)</span> 是 Artinian ring. 以下结论等价:</p><ol type="1"><li><span class="math inline">\(R\)</span> is right hereditary.</li><li><span class="math inline">\(J\)</span> 作为右 <span class="math inline">\(R\)</span>-模是投射的.</li><li>对任意幂等元 <span class="math inline">\(e\)</span>, <span class="math inline">\(eJ\)</span> 是投射右 <span class="math inline">\(R\)</span>-模.</li><li><span class="math inline">\(R\)</span> 的任意极大右理想都是投射右 <span class="math inline">\(R\)</span>-模.</li></ol><blockquote><p>证明难度还是有的, 要用到任意有限生成 Artinian 模都是有限长的.</p></blockquote><p>例子:</p><p>设 <span class="math inline">\(R\)</span> 是 divison ring <span class="math inline">\(D\)</span> 上的 <span class="math inline">\(n \times n\)</span> 上三角矩阵全体, 则 <span class="math inline">\(R\)</span> 是 hereditary Artinian ring.</p><h3 id="trace-ideal">Trace Ideal</h3><p>Definition: 对任意 <span class="math inline">\(P_R\)</span>, 定义 <span class="math inline">\(tr(P) = \sum im(f)\)</span> 其中, <span class="math inline">\(f\)</span> 跑遍 <span class="math inline">\(P^{\star}\)</span>. 容易看出 <span class="math inline">\(T = tr(P)\)</span> 是 <span class="math inline">\(R\)</span> 的理想, 称为 Trace Ideal. 它满足: 若 <span class="math inline">\(P_R\)</span> 是投射的, 则 <span class="math inline">\(PT = P, T^2 = T, ann(P) = ann_r(T)\)</span> 特别的, 若 <span class="math inline">\(P_R\)</span> 是有限生成投射的, 那么其对偶基 <span class="math inline">\(\lbrace a_i f_i \rbrace_{1\leq i \leq n}\)</span>. 那么 <span class="math inline">\(tr(P)\)</span> 可由有限集 <span class="math inline">\(\lbrace f_j(a_i) \rbrace\)</span> 生成. 另外,若 <span class="math inline">\(tr(P) = R\)</span>, 我们称 <span class="math inline">\(P\)</span> 是生成子.</p><p><strong>引理</strong> 设 <span class="math inline">\(T\)</span> 是交换环 <span class="math inline">\(R\)</span> 的有限生成幂等理想, 则存在幂等元 <span class="math inline">\(e \in R\)</span> 使得 <span class="math inline">\(T=eR\)</span>. Proof: 关键在于把 <span class="math inline">\(T\)</span> 写成 <span class="math inline">\(T = \sum_{i=1} ^n Tx_i\)</span></p><p>由上述引理和 <span class="math inline">\(T = Tr(P)\)</span> 的性质, 不难证明下面定理: <strong>定理</strong> 设 <span class="math inline">\(P_R\)</span> 是交换环 <span class="math inline">\(R\)</span> 有限生成投射模, 那么存在幂等元 <span class="math inline">\(e\)</span> 使得 <span class="math inline">\(T=Tr(P)=eR, N = ann(P) = (1-e)R\)</span>, 特别地, <span class="math inline">\(R = T \otimes N\)</span>, 投射模 <span class="math inline">\(P_R\)</span> 是 faithful(忠实的)当且仅当 <span class="math inline">\(T = R\)</span>. 当 <span class="math inline">\(R\)</span> 无非平凡幂等元时, 则 <span class="math inline">\(P \neq 0\)</span> 是(有限生成投射)生成子.</p><blockquote><p>定理中条件缺一不可, 且幂等元 <span class="math inline">\(e\)</span> 可以根据有限对偶基显式表达出来.</p></blockquote><p>Trace ideal 的应用: <strong>引理</strong> 设 <span class="math inline">\(R \subset S\)</span> 是环(不要求交换), 则 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(S_R\)</span> 的直和因子, 当且仅当, <span class="math inline">\(Tr(S_R) = R\)</span>. Proof: 若 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(S_R\)</span> 的直和因子, 则 <span class="math inline">\(Tr(S_R) \supset Tr(R_R) = R\)</span>, 所以 <span class="math inline">\(Tr(S_R) = R\)</span>. 若 <span class="math inline">\(Tr(S_R) = R\)</span>, 那么存在 <span class="math inline">\(f_i \in S_R^{\star},s_i \in S, (1 \leq i \leq n)\)</span> 使得 <span class="math inline">\(\sum f_i(s_i) = 1\)</span>. 定义映射 <span class="math inline">\(\lambda: S \to R\)</span> 为: <span class="math inline">\(\lambda(s) = f(s_i s)\)</span>. 为环同态, 且在 <span class="math inline">\(R\)</span> 上限制为恒等映射.(因此 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(S_R\)</span> 的直和因子).</p><p><strong>定理</strong> 设 <span class="math inline">\(R \subset S\)</span>, 其中 <span class="math inline">\(R\)</span> 是交换环, <span class="math inline">\(S\)</span> 是 f.g. 右 <span class="math inline">\(R\)</span>-模. 则 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(S_R\)</span> 的直和因子. Proof: 由 <span class="math inline">\(ann(S_R) = 0\)</span>, 在由上面引理即证。</p>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幂零矩阵的一个充要条件</title>
    <link href="/nilpotentMatrix/"/>
    <url>/nilpotentMatrix/</url>
    
    <content type="html"><![CDATA[<p>前几天一个学弟告诉我，关于复数域上幂零矩阵 <span class="math inline">\(A\)</span> 的一个充要条件： <span class="math display">\[A = AB-BA, \quad \exists B \in M_n(\mathbb{C})\]</span> 特此记录。</p><span id="more"></span><p>证明分几个小步骤：</p><ol type="1"><li><p>必要性对若当块成立，若<span class="math inline">\(A\)</span>为（上三角）若当块，那么取 <span class="math inline">\(B=diag \lbrace 0,1,⋯,n−1 \rbrace\)</span> 即可，若 <span class="math inline">\(A\)</span> 为分块若当块（若当标准型），那么取对应的分块 <span class="math inline">\(B\)</span> 即可。又由于 <span class="math display">\[P^{-1}AP = P^{-1}APP^{-1}BP - P^{-1}BP P^{-1}AP\]</span> 因此，由对若当标准型成立,可知道对一般形式成立。</p></li><li><p><span class="math inline">\(tr(A^k) = 0, 1 \leq k \leq n\)</span> ，则<span class="math inline">\(A\)</span> 幂零。</p><p>由若当标准型可知，只需证明： <span class="math display">\[\begin{cases} x_1 + x_2 + \cdots + x_n = 0 \\x_1 ^ 2 + x_2 ^ 2 + \cdots + x_n ^2 = 0 \\\cdots  \\x_1 ^ n + x_2 ^n + \cdots + x_n ^n  = 0\end{cases}\]</span> 推出，<span class="math inline">\(x_1 = x_2 = \cdots x_n = 0\)</span> ，不妨设 <span class="math display">\[\begin{cases} x_1 t_1 + x_2 t_2 + \cdots + x_r t_r = 0 \\x_1 ^ 2 t_1  + x_2 ^ 2 t_2 + \cdots + x_r ^2 t_r= 0 \\\cdots  \\x_1 ^ r t_1 + x_2 ^r t_2 + \cdots + x_r ^r t_r = 0\end{cases}\]</span> 其中 <span class="math inline">\(x_i\)</span> 互不相同，那么，假设 <span class="math inline">\(r&gt;1\)</span> 则由 Vandemode 行列式不为 0 知， <span class="math inline">\(t_i = 0\)</span> 矛盾，因此 <span class="math inline">\(r=1\)</span>， 此时 <span class="math inline">\(x_i=0\)</span>。</p></li><li><p><span class="math inline">\(C=AB-BA\)</span> 且 <span class="math inline">\(AC=CA\)</span> 则，<span class="math inline">\(C\)</span> 幂零。 <span class="math display">\[\forall k,tr (C^k) = tr(C^{k-1}AB - C^{k-1}BA) =tr(C^{k-1}AB) - tr(AC^{k-1}B) = 0\]</span> 因此由上面结论知，<span class="math inline">\(C\)</span> 幂零</p></li><li><p>综合上述结论，充分性显然。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kaplansky 定理</title>
    <link href="/kaplanskyTheorem/"/>
    <url>/kaplanskyTheorem/</url>
    
    <content type="html"><![CDATA[<p>(非交换)环中有一个有趣的（Kaplansky）定理说：</p><blockquote><p>如果环 <span class="math inline">\(R\)</span> 中元素 <span class="math inline">\(a\)</span> 有不止一个右逆，那么 <span class="math inline">\(a\)</span> 有无数多个右逆。</p></blockquote><p><strong>像极了出轨只有零次，或者无数次。</strong></p><span id="more"></span><blockquote><p>(Kaplansky) Suppose an element <span class="math inline">\(a\)</span> in a ring <span class="math inline">\(R\)</span> has more than one right inverse. Show that <span class="math inline">\(a\)</span> has infinitely many right inverses.</p></blockquote><h2 id="kaplansky-若环-r-中元素-a-有不止一个右逆那么它有无数个右逆">(Kaplansky) 若环 <span class="math inline">\(R\)</span> 中元素 <span class="math inline">\(a\)</span> 有不止一个右逆，那么它有无数个右逆</h2><p>证明：（反证法）设 <span class="math inline">\(a\)</span> 的所有右逆构成的集合为 <span class="math inline">\(A = \lbrace x \in R \mid a x = 1 \rbrace\)</span>.</p><p>若 <span class="math inline">\(A\)</span> 有限，不妨设 <span class="math inline">\(A = \lbrace x_1,x_2,\cdots,x_n \rbrace, (n&gt;1)\)</span> , 则 <span class="math display">\[a(1- x_i a + x_1) = a-(a x_i) a + a x_1 = 1\]</span> 并且, 若 <span class="math inline">\(1 - x_i a + x_1 = 1 - x_j a + x_1\)</span>, 即 <span class="math inline">\(x_i a = x_j a,\)</span> 那么 <span class="math inline">\(x_i = x_i(a x_i)=(x_j a) x_j\)</span>, 也就是说 <span class="math display">\[A = \lbrace x_1,x_2,\cdots,x_n \rbrace =  \lbrace 1- x_1 a + x_1,1- x_2 a + x_1,\cdots,1- x_n a + x_1 \rbrace\]</span> 所以存在 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\(1 - x_k a + x_1 = x_1\)</span>，即 <span class="math inline">\(x_k a = 1\)</span> 所以对任意 <span class="math inline">\(1 \leq i \leq n\)</span>, <span class="math display">\[x_i = (x_k a) x_i = x_k (a x_i) = x_k\]</span></p><p>即所有 <span class="math inline">\(x_i\)</span> 都相同，矛盾与 <span class="math inline">\(A\)</span> 中元素个数大于 1，证毕。</p><h2 id="等价叙述-如果环-r-中元素-a-有右逆而没有左逆那么-a-有无穷多个右逆">等价叙述： 如果环 <span class="math inline">\(R\)</span> 中元素 <span class="math inline">\(a\)</span> 有右逆而没有左逆，那么 <span class="math inline">\(a\)</span> 有无穷多个右逆</h2><blockquote><p>通俗的讲就是，如果你喜欢一个不喜欢你的人，那你不仅仅只喜欢这个人。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zariski Topology on $k^n$</title>
    <link href="/zariskiTopologyOnKn/"/>
    <url>/zariskiTopologyOnKn/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(k^n\)</span> 最常见的拓扑自然是欧式拓扑，但是下面介绍的 Zariski 拓扑也是十分重要和“常见”的拓扑，并且它也保持了很多自然的性质，又有其独特的地方，值得了解一番。</p><blockquote><p>详见 Jacobson《Basic Algebra 2》</p></blockquote><span id="more"></span><h2 id="zariski-topology">Zariski Topology</h2><p>给定一个交换环 <span class="math inline">\(A\)</span> ,<span class="math inline">\(Spec(A)\)</span> 表示 <span class="math inline">\(A\)</span> 理想全体构成的集合，带上一个 Zariski topology，拓扑中闭集为所有形式 <span class="math display">\[V(I)=\lbrace P \in Spec(A) | I \subset P \rbrace , I \subset A\]</span> 的集合，那么它必然会满足拓扑关于闭集的公理。</p><h3 id="kn-上的-zariski-拓扑"><span class="math inline">\(k^n\)</span> 上的 Zariski 拓扑</h3><p>由于 <span class="math inline">\(k^n=\lbrace(a_1,a_2,\cdots,a_n)| a_i \in k \rbrace\)</span> 到 <span class="math inline">\(k\)</span> 的多项式函数与 <span class="math inline">\(k[x_1,x_2,\cdots,x_n]\)</span> 同构。所有 <span class="math inline">\(k^n\)</span> 上的拓扑</p><p>本质上是由交换环 <span class="math inline">\(k[x_1,x_2,\cdots,x_n]\)</span> 的 Zariski 拓扑所确定。 <span class="math display">\[V(S)=\lbrace (a_1,a_2,\cdots,a_n) \in k^n | f(a_1,a_2,\cdots,a_n) = 0 , \forall f \in S \rbrace\]</span></p><ol type="1"><li><p><span class="math inline">\(V(k[x_1,x_2,\cdots,x_n]) = \emptyset\)</span></p></li><li><p><span class="math inline">\(V(\emptyset)=k[x_1,x_2,\cdots,x_n]\)</span></p></li><li><p><span class="math inline">\(\cap_{i \in I} V(S_i) = V(\cup_{i \in I} S_i)\)</span></p></li><li><p><span class="math inline">\(V(S) = V(I(S))\)</span></p></li><li><p><span class="math inline">\(V(I_1) \cup V(I_2) = V(I_1 I_2)\)</span></p></li></ol><p>所以，上述 <span class="math inline">\(V(S)\)</span> 全体作为闭集构成了 <span class="math inline">\(k^n\)</span> 的一个拓扑，称为 <span class="math inline">\(k^n\)</span> 上的 Zariski 拓扑。</p><h3 id="性质设-k-是代数闭域">性质（设 <span class="math inline">\(k\)</span> 是代数闭域）</h3><ol type="1"><li><p>拓扑基： <span class="math inline">\(k^n\)</span> 中开集有形式 <span class="math inline">\(k^n \setminus V(S) = \cup_{f \in S} O_f\)</span> 其中 <span class="math inline">\(O_f = k^n \setminus V(f)\)</span> 为开集。 因此 <span class="math inline">\({O_f|f \in k[x_1,x_2,⋯,x_n]}\)</span> 构成了 <span class="math inline">\(k^n\)</span> 上的拓扑集</p></li><li><p><span class="math inline">\(k^a\)</span> 是 <span class="math inline">\(T_1\)</span>空间。</p></li><li><p><span class="math inline">\(k^n\)</span> 是不可约空间，即有限个非空开集交集非空。</p></li><li><p><span class="math inline">\(k^n\)</span> 多项式映射在 Zariski 拓扑下连续。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩具：HC6800-ES 开发版</title>
    <link href="/singleChip/"/>
    <url>/singleChip/</url>
    
    <content type="html"><![CDATA[<p>这里记录一些我的新玩具: <code>51 单片机</code> 的基础常识，作为初学者，下文必然是错误百出。</p><blockquote><p>很久没更新博客了,毕竟很久没写程序了。数学类的嵌套的定义又太多，很不好写。</p></blockquote><span id="more"></span><h2 id="新玩具">新玩具</h2><p>这次淘宝买的新玩具是：HC6800-ES V2.0 开发版，内部单片机是 STC89C52。见下图</p><figure><img src="HC6800.png" alt="HC6800" /><figcaption aria-hidden="true">HC6800</figcaption></figure><p>作为小白看了一下视频，但是呢，感觉视频什么的太慢，还是看书看手册来的爽。安装好单片机版 C 语言的 IDE Keil4 以及烧录软件之后，装一下开发版驱动，就可以在不知道单片机原理的情况下轻松的控制单片机了。例如什么 LED 灯闪烁，跑马灯，等等很基础的程序。</p><p>下面是单片机的管脚图和说明：</p><figure><img src="89C52.png" alt="89C52" /><figcaption aria-hidden="true">89C52</figcaption></figure><figure><img src="STC89C52_1.png" alt="STC89C52_1" /><figcaption aria-hidden="true">STC89C52_1</figcaption></figure><figure><img src="STC89C52_2.png" alt="STC89C52_2" /><figcaption aria-hidden="true">STC89C52_2</figcaption></figure><p>从图上看知道 P0,P1,P2,P3 是重要的 I/O 口，例如我们把 P2 接到 LED 灯，那么给低电平 0，就可以使灯亮。还有 P0，P1 不仅可以作为 I/O 口，还可以作为地址，计时器、计数器来用。还有 P3，等等。由于我用的是开发版，每个口接什么基本上已经固定了，用的时候查相应的官方资料就行了。它也提供了很多程序例子，因此还是很好掌握的，只是要记点东西才能灵活操作它。</p><h2 id="hc6800-es-vs2.0-常见管脚接法">HC6800-ES-VS2.0 常见管脚接法</h2><ol type="1"><li><p>P2 口 8 个位接了 8 个 LED 灯，至 0 灯亮。</p></li><li><p>P1.5 接了蜂鸣器。循环至 0 至 1 发声。</p></li><li><p>P3.0 ~ P3.3 接了独立键盘（不过开发版上竟然接反了 K1 和 K2），使用按键的时候要软件消除抖动，一般延迟 10ms 来完成。</p></li><li><p>通过 P1 的数据，来判断矩阵键盘按的键。（见下图) <img src="keyboard.png" alt="keyboard" /></p></li><li><p>数码管使用 P0, 通过 LSA=P2.2, LSB=P2.3, LSB=P2.4 的 0-1 指来控制显示的地方。</p></li><li><p>常用定时器和中断标程。</p></li></ol><h2 id="液晶显示">1602 液晶显示</h2><p>这个虽然很复杂，但是生产该显示屏的会提供<code>lcd.h</code>和<code>lcd.c</code>然后我们只要先初始化 LCD：<code>LcdInit()</code>再执行字节输出函数：<code>LcdWriteData(char c)</code>即可。</p><h2 id="程序示例">程序示例</h2><p>程序功能: 按下 k1 键 LED 跑马灯，K2 蜂鸣器发生，K3 数码管显示 1-8。由于不会中断，所以跑马灯写的很挫。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;reg52.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;intrins.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> u16;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u8;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> led P2</span><br>sbit k1=P3^<span class="hljs-number">1</span>;<br>sbit k2=P3^<span class="hljs-number">0</span>;<br>sbit k3=P3^<span class="hljs-number">2</span>;<br>sbit LSA=P2^<span class="hljs-number">2</span>;<br>sbit LSB=P2^<span class="hljs-number">3</span>;<br>sbit LSC=P2^<span class="hljs-number">4</span>;<br>sbit beep=P1^<span class="hljs-number">5</span>;<br>u8 beepS,i,ledState = <span class="hljs-number">0</span>, DigState = <span class="hljs-number">0</span>;<br>u8 code smgduan[<span class="hljs-number">17</span>] = &#123;<span class="hljs-number">0x3f</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5b</span>,<span class="hljs-number">0x4f</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6d</span>,<span class="hljs-number">0x7d</span>,<span class="hljs-number">0x07</span>,<br>                       <span class="hljs-number">0x7f</span>,<span class="hljs-number">0x6f</span>,<span class="hljs-number">0x77</span>,<span class="hljs-number">0x7c</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x5e</span>,<span class="hljs-number">0x79</span>,<span class="hljs-number">0x71</span>&#125;; <span class="hljs-comment">//显示0~F的值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delay</span><span class="hljs-params">(u16 t)</span></span>&#123;   <span class="hljs-comment">//  每次约10us</span><br>  <span class="hljs-keyword">while</span>(t--);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ledStart</span><span class="hljs-params">()</span></span>&#123;<br>  ledState = <span class="hljs-number">1</span>;<br>  led=<span class="hljs-number">0xfe</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i!=<span class="hljs-number">7</span>;++i)&#123;<br>    led = _crol_(led,<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">50000</span>);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ledStop</span><span class="hljs-params">()</span></span>&#123;<br>  ledState = <span class="hljs-number">0</span>;<br>  led = <span class="hljs-number">0xff</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DigDisplay</span><span class="hljs-params">()</span></span>&#123;<br>  DigState = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(i)&#123;   <span class="hljs-comment">//位选，选择点亮的数码管</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">case</span></span>(<span class="hljs-number">0</span>):<br>        LSA=<span class="hljs-number">0</span>;LSB=<span class="hljs-number">0</span>;LSC=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//显示第0位</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">case</span></span>(<span class="hljs-number">1</span>):<br>        LSA=<span class="hljs-number">1</span>;LSB=<span class="hljs-number">0</span>;LSC=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//显示第1位</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">case</span></span>(<span class="hljs-number">2</span>):<br>        LSA=<span class="hljs-number">0</span>;LSB=<span class="hljs-number">1</span>;LSC=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//显示第2位</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">case</span></span>(<span class="hljs-number">3</span>):<br>        LSA=<span class="hljs-number">1</span>;LSB=<span class="hljs-number">1</span>;LSC=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//显示第3位</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">case</span></span>(<span class="hljs-number">4</span>):<br>        LSA=<span class="hljs-number">0</span>;LSB=<span class="hljs-number">0</span>;LSC=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//显示第4位</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">case</span></span>(<span class="hljs-number">5</span>):<br>        LSA=<span class="hljs-number">1</span>;LSB=<span class="hljs-number">0</span>;LSC=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//显示第5位</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">case</span></span>(<span class="hljs-number">6</span>):<br>        LSA=<span class="hljs-number">0</span>;LSB=<span class="hljs-number">1</span>;LSC=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//显示第6位</span><br>      <span class="hljs-built_in"><span class="hljs-keyword">case</span></span>(<span class="hljs-number">7</span>):<br>        LSA=<span class="hljs-number">1</span>;LSB=<span class="hljs-number">1</span>;LSC=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;<span class="hljs-comment">//显示第7位</span><br>    &#125;<br>    P0=smgduan[i];  <span class="hljs-comment">//发送段码</span><br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">50000</span>);   <span class="hljs-comment">//间隔一段时间扫描</span><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DigStop</span><span class="hljs-params">()</span></span>&#123;<br>  DigState = <span class="hljs-number">0</span>;<br>  P0 = <span class="hljs-number">0x00</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">keyPress</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(k1==<span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// 检测k1是否按下</span><br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);<span class="hljs-comment">//消除抖动 一般大约10ms</span><br>    <span class="hljs-keyword">if</span>(k1==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//再次判断按键是否按下</span><br>      <span class="hljs-keyword">if</span>(ledState==<span class="hljs-number">0</span>)  <span class="hljs-built_in">ledStart</span>();<br>      <span class="hljs-keyword">else</span>  <span class="hljs-built_in">ledStop</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!k1);   <span class="hljs-comment">//检测按键是否松开</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(k2==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">if</span>(k2==<span class="hljs-number">0</span>)&#123;<br>      beepS=<span class="hljs-number">10</span>;<br>      <span class="hljs-keyword">while</span>(beepS&lt;<span class="hljs-number">200</span>)&#123;<br>        beep=~beep;<br>        <span class="hljs-built_in">delay</span>(beepS);<br>        ++beepS;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!k2);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(k3==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">if</span>(k3==<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">if</span>(DigState == <span class="hljs-number">0</span>)  <span class="hljs-built_in">DigDisplay</span>();<br>      <span class="hljs-keyword">else</span>  <span class="hljs-built_in">DigStop</span>();<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!k3);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)  <span class="hljs-built_in">keyPress</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>note</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五引理</title>
    <link href="/fiveLemma/"/>
    <url>/fiveLemma/</url>
    
    <content type="html"><![CDATA[<p>在同调代数中，Five lemma，Snake lemma，Nine lemma （五引理，蛇形引理，马蹄引理）都是重要的引理。这里介绍一下 五引理。其实它的一般形式是有两个四引理得出的</p><span id="more"></span><p>以下范畴为：Abel 范畴(这里仅在模范畴中考虑，此时 monic 即为单同态，epic 即为满同态)。</p><h2 id="五引理">五引理</h2><p>若下交换图中每一行都正合且 <span class="math inline">\(f\)</span> epic, <span class="math inline">\(q\)</span> monic, <span class="math inline">\(g,p\)</span> isomorphism, then <span class="math inline">\(h\)</span> is isomorphism. <img src="fivelemma.png" alt="五引理" /></p><h2 id="五引理的特殊形式">五引理的特殊形式</h2><p>若下交换图中每一行都正合且 <span class="math inline">\(f, h\)</span> isomorphism,then <span class="math inline">\(g\)</span> is isomorphism. <img src="fivelemmaS.png" alt="五引理特殊形式" /></p><h2 id="两个四引理及其证明">两个四引理及其证明</h2><ol type="1"><li><p>若下交换图中每一行都正合且 <span class="math inline">\(f\)</span> epic，<span class="math inline">\(p\)</span> monic, <span class="math inline">\(g\)</span> monic, then <span class="math inline">\(h\)</span> is monic. <img src="fourlemma1.png" alt="四引理1" /> <span class="math inline">\(\forall c \in C\)</span>, 若 <span class="math inline">\(h(c) = 0\)</span>, 则 <span class="math inline">\(pw(c)＝w&#39;h(c)=0\)</span>, 因为 <span class="math inline">\(p\)</span> monic, 因此 <span class="math inline">\(w(c)=0\)</span>, 又由行正合知，<span class="math inline">\(\exists b \in B\)</span> 使得 <span class="math inline">\(v(b)=c\)</span>，因此 <span class="math inline">\(v&#39;g(b)=hv(b)=h(c)=0\)</span>, 由行正合知, $ a' A' $ 使得 <span class="math inline">\(u&#39;(a&#39;)=g(b)\)</span>，由 <span class="math inline">\(f\)</span> epic 知 <span class="math inline">\(\exists a \in A\)</span> 使得 <span class="math inline">\(f(a) = a&#39;\)</span>. 因此 <span class="math inline">\(gu(a) = u&#39;f(a)=g(b)\)</span>. 又由 <span class="math inline">\(g\)</span> monic 知， <span class="math inline">\(b = u(a)\)</span>. 因此 <span class="math inline">\(c = vu(a) = 0\)</span>. 证毕。</p></li><li><p>若下交换图中每一行都正合且 <span class="math inline">\(g\)</span> epic，<span class="math inline">\(q\)</span> monic, <span class="math inline">\(p\)</span> epic,then <span class="math inline">\(h\)</span> is epic. <img src="fourlemma2.png" alt="四引理2" /> <span class="math inline">\(\forall c&#39; \in C&#39;\)</span>, 因为 <span class="math inline">\(p\)</span> epic, 知 <span class="math inline">\(\exists d \in D\)</span> 使得 <span class="math inline">\(p(d) = w&#39;(c&#39;)\)</span>, 所以 <span class="math inline">\(qs(d) = s&#39;p(d) = s&#39;w&#39;(c&#39;) = 0\)</span>, 又 <span class="math inline">\(q\)</span> monic, 因此 <span class="math inline">\(s(d) = 0\)</span>, 由行正合知, <span class="math inline">\(\exists c \in C\)</span>，使得 <span class="math inline">\(w(c) = d\)</span>.因此 <span class="math inline">\(w&#39;(c&#39;-h(c))=w&#39;(c&#39;)-w&#39;h(c)=p(d)-pw(c)=0\)</span>. 由行正合知，<span class="math inline">\(\exists b&#39; \in B&#39;\)</span> 使得 <span class="math inline">\(v&#39;(b&#39;) = c&#39; - h(c)\)</span>, 又由 <span class="math inline">\(g\)</span> epic 知 <span class="math inline">\(\exists b \in B\)</span> 使得 <span class="math inline">\(g(b) = b&#39;\)</span> 因此 <span class="math inline">\(hv(b)= v&#39;g(b) - v&#39;(b&#39;)=c&#39;-h(c)\)</span>. 即 <span class="math inline">\(c&#39;=h(v(b)+c)\)</span>. 证毕。</p></li></ol><p>四引理记忆方法： 左满右单，两满夹一满，两单夹一单。</p><blockquote><p>显然上述两个四引理显然可推出五引理。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论</title>
    <link href="/gameTheory/"/>
    <url>/gameTheory/</url>
    
    <content type="html"><![CDATA[<p>2002 年张一飞写过一篇论文 <a href="NimGame.pdf">《由感性认识到理性认识－透析一类博弈游戏的解答过程》</a> 把了这类博弈问题带到了大众视野，在此留下学习笔记（参考了很多的内容：原始论文，codeforces，Wiki，各种博客：<a href="https://www.cnblogs.com/cjyyb/p/9495131.html">小蒟蒻yyb</a>, <a href="https://www.cnblogs.com/zwfymqz/tag/%E5%8D%9A%E5%BC%88%E8%AE%BA/">自为风月马前卒</a> 等等，无法一一列举）</p><blockquote><p>其实我一直想把这个做成自动化的，或者说网页类游戏的，但是一直没有这个精力，而且它们有很多共性，但是由于参数不同很统一，但是不同意又有很多重复代码十分不优雅，而且其实很多游戏都可以混合，所以就会很繁琐</p></blockquote><span id="more"></span><h2 id="取石子游戏">取石子游戏</h2><p><span class="math inline">\(A,B\)</span> 两人面对若干堆石子，按照如下规则取石子</p><ol type="1"><li>每步至少取一枚石子</li><li>每步只能在某一堆取走部分或者全部石子</li><li>谁无法按照规则取石子，谁就是输家</li></ol><p>首先抛开问题，我们先从一般的入手。</p><p>我们可以用一个 <span class="math inline">\(n\)</span> 元组 <span class="math inline">\((a_1,a_2,\cdots,a_n)\)</span> 表示一个局面 <span class="math inline">\(S\)</span>。显然 <strong>改变 <span class="math inline">\(n\)</span> 元组的顺序仍然是一个局面。</strong></p><p>一个局面 <span class="math inline">\(n\)</span> 元局面 <span class="math inline">\((a_1,a_2,\cdots,a_n)\)</span> 和一个 <span class="math inline">\(m\)</span> 元局面 <span class="math inline">\((b_1,b_2,\cdots,b_m)\)</span> 之和显然就是一个 <span class="math inline">\(m + n\)</span> 元局面 <span class="math inline">\((a_1,a_2,\cdots,a_n,b_1,b_2,\cdots,b_m)\)</span>。类似的一个局面也可以有多种分解。</p><p>对于局面 <span class="math inline">\(S\)</span>，若先行者有必胜策略，则称 "<span class="math inline">\(S\)</span> 胜"； 对于局面 <span class="math inline">\(S\)</span>，若后行者有必胜策略，则称 "<span class="math inline">\(S\)</span> 负"。</p><p>如果局面 <span class="math inline">\(S\)</span> 胜，则必然存在取子方式 <span class="math inline">\(S \to T\)</span>，且 <span class="math inline">\(T\)</span> 负； 如果局面 <span class="math inline">\(S\)</span> 负，则对任意取子方式 <span class="math inline">\(S \to T\)</span>，有 <span class="math inline">\(T\)</span> 胜。</p><p>局面分解理论，若 <span class="math inline">\(S = A + B\)</span> 则下面结论显然</p><ol type="1"><li>若 <span class="math inline">\(A,B\)</span> 一胜一负，则 <span class="math inline">\(S\)</span> 胜</li><li>若 <span class="math inline">\(A,B\)</span> 全为负，则 <span class="math inline">\(S\)</span> 负</li><li>若 <span class="math inline">\(A,B\)</span> 全为胜，则 <span class="math inline">\(S\)</span> 无法判断（还需要进一步信息才能确定）</li><li>若 <span class="math inline">\(A=B\)</span>，则 <span class="math inline">\(S\)</span> 负</li><li>空局面是负局面</li></ol><p>因此根据上面的分解理论，可以将一个局面进行化简。例如 <span class="math inline">\((2,2,2,7,9,9)\)</span> 可以化简成 <span class="math inline">\((2,7)\)</span></p><p>而局面分解的关系，很容易让人联想到整数的位运算－异或。</p><p>对于上面取石子问题，每一个局面都可以分解成只有一堆石子的局面。 对一个局面，定义一个函数 <span class="math inline">\(f\)</span>，然后把它们异或是不是，然后判断是非为 0，作为是否胜的充要条件.这样做是否可行呢？先对原始例子进行实验。</p><p>函数 <span class="math inline">\(f\)</span>：若局面 <span class="math inline">\(S\)</span> 只有一堆石子，设 <span class="math inline">\(S={a}\)</span>，则定义 <span class="math inline">\(f(a) = a\)</span>。 设局面 <span class="math inline">\(S = (a_1,a_2,\cdots,a_n)=(a_1)+(a_2)+\cdots (a_n)\)</span>，则 <span class="math inline">\(f(S) = f(a_1) \oplus f(a_2) \oplus \cdots \oplus f(a_n)\)</span> <strong>我们断言</strong>：对于一个局面 <span class="math inline">\(S\)</span>，若 <span class="math inline">\(f(S) = 0\)</span>，则 <span class="math inline">\(S\)</span> 负，否则，<span class="math inline">\(S\)</span> 胜。</p><p>下面证明上面的结论。 引理：<span class="math inline">\(a_1 \oplus a_2 \oplus \cdots \oplus a_n = p \neq 0\)</span>，则必存在 <span class="math inline">\(1 \leq k \leq n\)</span>，使得 <span class="math inline">\(a_k \oplus p &lt; a_k\)</span>。这是因为我们看 <span class="math inline">\(p\)</span> 的最高位，有奇数个<span class="math inline">\(a_k\)</span>在此位置非零, 那么与 <span class="math inline">\(p\)</span> 异或后，这一位就从 <span class="math inline">\(1\)</span> 变为 <span class="math inline">\(0\)</span>，证毕。</p><p>若 <span class="math inline">\(f(S) = 0\)</span>，则无论先行者如何取子 <span class="math inline">\(S \to T\)</span>，都有 <span class="math inline">\(f(T) \neq 0\)</span>。 若 <span class="math inline">\(f(S) \neq 0\)</span>，则先行者存在一种取法 <span class="math inline">\(S \to T\)</span>, 使得 <span class="math inline">\(f(T) = 0\)</span>。这是因为由引理 <span class="math inline">\(a_1 \oplus a_2 \oplus a_n = p \neq 0\)</span>，存在 <span class="math inline">\(1 \leq k \leq n\)</span>，使得 <span class="math inline">\(x = a_k \oplus p &lt; a_k\)</span>。那么我们在第 <span class="math inline">\(k\)</span> 堆取走 <span class="math inline">\(a_k - x\)</span> 个石子，那么 <span class="math inline">\(a_1 \oplus \cdots a_{k - 1} \oplus x \oplus a_{k + 1} \cdots \oplus a_n = p \oplus p = 0\)</span>，证毕。</p><h3 id="一般-nim-sg-问题的-on2-暴力做法">一般 Nim SG 问题的 <span class="math inline">\(O(n^2)\)</span> 暴力做法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nim</span> &#123;</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; sg&#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 取决于具体问题</span><br>    <span class="hljs-keyword">return</span> (n &amp; x) == <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sg.<span class="hljs-built_in">size</span>(); i &lt; n; ++i) &#123;<br>      std::stack&lt;<span class="hljs-keyword">int</span>&gt; S;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; ++j) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(i, j)) &#123;<br>        ++cnt[sg[i - j]];<br>        S.<span class="hljs-built_in">push</span>(sg[i - j]);<br>      &#125;<br>      <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (cnt[r]) ++r;<br>      sg.<span class="hljs-built_in">emplace_back</span>(r);<br>      <span class="hljs-keyword">while</span> (!S.<span class="hljs-built_in">empty</span>()) &#123;<br>        --cnt[S.<span class="hljs-built_in">top</span>()];<br>        S.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(*std::<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) r ^= sg[x];<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="必胜策略代码">必胜策略代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;请输入一个正数组，以 0 结尾，输出下一步的必胜策略:&quot;</span> &lt;&lt; std::endl;<br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br>  <span class="hljs-keyword">int</span> n;<br>  <span class="hljs-keyword">while</span> (std::cin &gt;&gt; n &amp;&amp; n) a.<span class="hljs-built_in">emplace_back</span>(n);<br>  <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) s ^= x;<br>  <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) std::cout &lt;&lt; <span class="hljs-string">&quot;必败，随便选择一个合理策略吧，等待对手失误吧&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) <span class="hljs-keyword">if</span> (x ^ s &lt;= x) &#123;<br>      x ^= s;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;以下是下一步的一个必胜策略:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    std::cout &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这说明了上述想法的可行性。下面把这种思想推广成一般的 SG（Sprague-Grundy）函数的情形</p><h2 id="sg-函数">SG 函数</h2><p>当对石子的取法进行限制时，例如每次最多能去 <span class="math inline">\(m\)</span> 个，或每次最少取 <span class="math inline">\(l\)</span> 个等，此时再令 <span class="math inline">\(f(x) = x\)</span> 就不合适了。那么应该选择怎样的 <span class="math inline">\(f\)</span> 呢。显然 <span class="math inline">\(f\)</span> 必须满足：</p><ol type="1"><li>若 <span class="math inline">\(f(S) = 0\)</span>, 则无论先行者如何取子 <span class="math inline">\(S \to T\)</span>，都有 <span class="math inline">\(f(T) \neq 0\)</span></li><li>若 <span class="math inline">\(f(S) \neq 0\)</span>, 则先行者存在一种取子 <span class="math inline">\(S \to T\)</span>，使得 <span class="math inline">\(f(T) = 0\)</span>。</li></ol><p>我们用 <span class="math inline">\((S) = \lbrace S_1, S_2, \cdots S_k \rbrace\)</span> 表示 <span class="math inline">\(S\)</span> 的下一个可能的局面，定义 <span class="math inline">\(g(S) = \lbrace f(S_1),f(S_2), \cdots f(S_k) \rbrace\)</span>，则它必然满足 <span class="math inline">\(f(S) \doteq \text{ MEX } g(S)\)</span></p><blockquote><p>注意上述 <span class="math inline">\(f\)</span> 的值域是整数，<span class="math inline">\(g(S)\)</span> 是整数集的子集。其中 <span class="math inline">\(MEX(A \subseteq \mathbb{N})\)</span> 为不在 <span class="math inline">\(A\)</span> 中最小正整数。</p></blockquote><h3 id="bash-game">Bash game</h3><p>若最多取 <span class="math inline">\(m\)</span> 个没有其它的限制条件，可以取 <span class="math inline">\(f(x) = x \mod m + 1, S = (a_1, \cdots, a_n), f(S) = f(a_1) \oplus \cdots \oplus f(a_n)\)</span></p><blockquote><p>对 SG 感性的理解为，连续最长从赢到输的步数。这样所有的例子都通了！</p><p>可以参考 <a href="https://codeforces.com/gym/102538/problem/E">300iq Contest 3E Easy Win</a> 测试。</p><p>两人轮流取，第 <span class="math inline">\(k\)</span> 次最少取 <span class="math inline">\(1\)</span> 最多取 <span class="math inline">\(k\)</span>，<a href="https://codeforces.com/blog/entry/85311#comment-730625">我在 Codeforces 上写了解答</a>，这个可以变形。</p></blockquote><p>假设有 <span class="math inline">\(n\)</span> 堆，每堆有 <span class="math inline">\(x_i\)</span>, 并且限制，每次至少取 <span class="math inline">\(l_i\)</span>，最多取 <span class="math inline">\(r_i\)</span>. 问先手还是后手有必胜策略</p><blockquote><p>经过一番思考，比较 <span class="math inline">\(l_i = 1\)</span> 的 case 可知，若 <span class="math inline">\(l_i \leq x_i \mod (l_i + r_i)\)</span>，则此回合有必胜策略。否则必败。观察到 <span class="math inline">\(sg_i(x_i) = \lfloor \frac{x_i \mod (l_i + r_i)}{l_i} \rfloor\)</span>（证明是容易的）。然后最后答案就是 <span class="math inline">\(s = sg_1(x_1) \oplus \cdots \oplus sg_n(x_n) \neq 0\)</span>。若 <span class="math inline">\(s \neq 0\)</span>， 先手有必胜策略：先手可以让 s 变成 0，然后后手无论如何操作，先手让它们的和为 <span class="math inline">\(l_i + r_i\)</span>, 然后所有的堆个数都小于超过 <span class="math inline">\(l_i + r_i\)</span> 然后再类似之前的讨论即可。因为如果第 i 堆必败，那么剔除这个堆不会影响最后胜负情况，反之必然满足 <span class="math inline">\(l_i \leq x_i \mod (l_i + r_i) \leq r_i\)</span></p></blockquote><p>因为每次取至少取 <span class="math inline">\(l_i\)</span>，因此本质上第 i 堆现在的个数就是 <span class="math inline">\(sg_i(x_i)\)</span>，根据之前的讨论，得知最后的结论。类似地，我们也可以给出代码（这个问题可以做交互题）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;欢迎来到石子游戏，请输入石子的堆数&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">l</span><span class="hljs-params">(n)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;请输入石子个数，最少取石子个数，最大取石子个数&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">int</span> sg = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    std::cin &gt;&gt; a[i] &gt;&gt; l[i] &gt;&gt; r[i];<br>    sg ^= a[i] % (l[i] + r[i]) / l[i];<br>  &#125;<br>  <span class="hljs-keyword">if</span> (sg != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">int</span> t = a[i] % (l[i] + r[i]) / l[i];<br>      <span class="hljs-keyword">if</span> (sg ^ t &lt;= t) &#123;<br>        a[i] -= t * l[i];<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;第 &quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; 堆中取 &quot;</span> &lt;&lt; l[i] * t &lt;&lt; <span class="hljs-string">&quot; 个&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前石子情况为：&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    std::cout &lt;&lt; std::endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前无必胜策略，随便取一个合理的取法，等待对手失误吧&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当 <code>l[i]</code> 和 <code>r[i]</code> 可变时，也可以考虑，暂时不在此说了。</p></blockquote><h3 id="fibonacci-game">Fibonacci game</h3><p>有一堆石子，先手第一次可以取走任意多个（非零且不能取完），以后每人取的石子不能超过上一个的两倍（非零）</p><p>先手赢当且仅当石子数不是 Fibonacci 数。</p><blockquote><p>利用 Zeckendorf 定理：任何正整数可以表示为若干个<strong>不连续</strong>的Fibonacci数之和（数学归纳法可证）</p></blockquote><p>根据这个定理，策略是显然的，对于非 Fibonacci 数 <span class="math inline">\(n\)</span>，我们找到小于 <span class="math inline">\(n\)</span> 最大的 Fibonacci 数 <span class="math inline">\(F_i\)</span>，然后取走 <span class="math inline">\(n - F_i\)</span> 个数即可。注意到如果石子数一开始就是 Fibonacci 数 <span class="math inline">\(n\)</span>，那么显然无论怎么操作，它最多只能变成另一个 Fibonacci 数，然后后手直接取完</p><blockquote><p>多堆呢？也能做就是复杂度很高：首先注意到如果去了超过 <span class="math inline">\(1 / 3\)</span>，那么后手就没有任何限制了，反正问题变成先手后手互换</p></blockquote><h3 id="multi-nim">Multi-Nim</h3><p><span class="math inline">\(n\)</span> 堆石子，从任意一堆中取出任意个非空石子，或者把一堆分成非空的两堆，无法操作者输</p><p><span class="math display">\[sg(x) = \left\{\begin{array}{c} x - 1 &amp; x \equiv 0 \mod 4 \\ x + 1 &amp; x \equiv 3 \mod 4 \\ x &amp; else  \end {array} \right.\]</span></p><h3 id="有树上删边游戏">有树上删边游戏</h3><p>dfs 考虑每个子树的 sg 值，就可以知道父节点这个子树的值了</p><h2 id="无法取为胜">无法取为胜</h2><p>甲乙两人面对若干堆石子，其中每一堆石子的数目任意给定, 两人轮流取走一些石子, 每次至少取一枚石子, 每次只能从某一堆中取, 可以取完，最终取完石子的为输家</p><h3 id="感性判断">感性判断</h3><ol type="1"><li>去掉任意多的 0 和偶数个 1 并不会影响结果(是对的, 但是要分情况推敲一下)</li><li>无法根据子局面的胜负来判断总局面的胜负.</li><li>负局面的价值远远高于胜局面, <span class="math inline">\((1),(n,n&gt;1),(1,2n,2n+1)\)</span>, 奇数个 1, 偶数个 2 是负局面(用数学归纳法容易证明)</li><li>从小的开始枚举, 为被负局面包含的极小局面是胜局面, 被所有胜局面包围的是负局面, 这样可以一直进行下去直到得到我们的结果.</li><li>前戏终于结束了, 要来真的了 0.0(好害怕)</li></ol><h3 id="理性总结">理性总结</h3><ol type="1"><li>首先我们先剔除所有 0 和偶数个 1 得到新的局面至多有一个 1. 如果为空, 则为胜局面.</li><li>对于堆数 <span class="math inline">\(n=1\)</span> 的情形, <span class="math inline">\(a1=1\)</span> 为负局面, 其它为胜局面. 对于堆数 <span class="math inline">\(n&gt;1\)</span> 是若 <span class="math inline">\(a_1\wedge ⋯\wedge a_n=0\)</span> 为负局面, 其它为胜局面. <strong>证明</strong>: 首先证明结论对 <span class="math inline">\(n=2\)</span> 是成立, 即 <span class="math inline">\(a_1=a_2\)</span>(不可能同时为 1)时是负局面, 因为 <span class="math inline">\(a_1=a_2=2\)</span>是负局面, 若 <span class="math inline">\(a_1=a_2&lt;k\)</span> 是负局面, <span class="math inline">\(a_1=a_2 = k\)</span>, 则下一步必然是 <span class="math inline">\((a1,a2)=(m&lt;k,k)\)</span> 为胜局面(若 <span class="math inline">\(m=0,1\)</span> 时显然, 否则下一步 <span class="math inline">\((a_1=a2)=(m,m)\)</span> 为负局面). 因此结论对 <span class="math inline">\(n=2\)</span> 成立. 现在若结论对于 <span class="math inline">\(n&lt;k\)</span> 成立, 那么由引理若 <span class="math inline">\(a_1\wedge ⋯\wedge a_n=0\)</span> 则下一步必然导致 <span class="math inline">\(a′_1 \wedge ⋯ \wedge a′_n \neq 0\)</span>. 若其中某个 <span class="math inline">\(a′_i=0\)</span>, 那么由归纳法必然导致结论成立. 那么后手就可以取走一些石子导致 <span class="math inline">\(a′′_1 \wedge ⋯\wedge a′′_n=0\)</span>. 另外一出现多于 2 个 1 直接剔除(不会改变异或和的值). 这样下去堆数必然减少, 由归纳法可知结论成立.</li></ol><h2 id="有向无环图-dag-上-sg-问题">有向无环图 DAG 上 SG 问题</h2><p>在一个有向无环图中，只有一个起点，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，不能走的玩家判负。</p><blockquote><p>来自 <a href="https://oi-wiki.org/math/game-theory/">OI-wiki</a></p></blockquote><p>对于状态 <span class="math inline">\(x\)</span> 和 它的 <span class="math inline">\(k\)</span> 个后继状态 <span class="math inline">\(y_1, y_2, \cdots, y_k\)</span>, 定义 SG 函数: <span class="math inline">\(SG(x) = mex \{ SG(y_1), SG(y_2), \cdots, SG(y_k) \}\)</span></p><p>而对于由 <span class="math inline">\(n\)</span> 个有向图游戏组成的组合游戏，设它们的起点分别为 <span class="math inline">\(s_1, \cdots, s_n\)</span>，先手必胜当且仅当 <span class="math inline">\(SG(s_1) \oplus \cdots \oplus SG(s_n) \neq 0\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SG</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// n 个节点，0 为起点，m 条有向边，确保无环。</span><br>  <span class="hljs-keyword">int</span> n, m;<br>  std::cin &gt;&gt; n &gt;&gt; m;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">int</span> x, y;<br>    std::cin &gt;&gt; x &gt;&gt; y;<br>    e[x].<span class="hljs-built_in">emplace_back</span>(y);<br>  &#125;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sg</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u) -&gt; <span class="hljs-keyword">int</span> &#123;<br>    <span class="hljs-keyword">if</span> (sg[u] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> sg[u];<br>    std::set&lt;<span class="hljs-keyword">int</span>&gt; S;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) S.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">dfs</span>(v));<br>    sg[u] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">find</span>(sg[u]) != S.<span class="hljs-built_in">end</span>()) ++sg[u];<br>    <span class="hljs-keyword">return</span> sg[u];<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> nroot;<br>  std::cin &gt;&gt; nroot;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (nroot--) &#123;<br>    ans ^= <span class="hljs-built_in">SG</span>();<br>  &#125;<br>  std::cout &lt;&lt; (ans ? <span class="hljs-string">&quot;先手赢&quot;</span> : <span class="hljs-string">&quot;后手赢&quot;</span>) &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以做到二维平面上有障碍点集，又可以做一个题目了。</p><p>注意到上述问题，堆与堆之间是相互独立的，如果不独立，那就很难考虑了。</p></blockquote><h2 id="树上-sg">树上 sg</h2><p>对了树上问题是这样的，先手确定树上一个点为起点，每次只能到相邻点，到达过的点不能再到达，无法走的输。如果一棵树的树，随便确定一个点为起点，然后就变成有根树的 sg 问题，比 DAG 上还要简单。然后换根 DP，O(n) 能处理，再处理多棵无根树的情况</p><ul><li>对于有根树，我们 dfs 搞就好了，也可以参考 DAG 来搞，但是没必要。</li><li>对于无根树，我们可以以某一点给根，给树定向，顺便预处理出每个子树的 sg 值，然后下一次 dfs 更新父节点作为子节点的贡献（注意不是父节点的 sg 值），最后再跑一次就可以得到每个点为根的答案了</li><li>如果是多棵有根树，十分简单，直接异或和</li><li>如果是多棵无根树，那么就每颗树 mex 后（相当于还有一个超级节点），异或和（如下）</li></ul><p>之前考虑一个的树上 SG 的问题，如果多颗树不知道怎么解决，转化之后就是下面形式</p><p>现在有 m 堆，第 i 堆有 m_i 小堆（每个小堆有非零个石子），每次第一次进入第 i 堆，必须从要在这 m_i 小堆中选择唯一的小堆保留（不取石子），其它小堆（如果有）直接丢掉，然后其它规则与无限制取石子一致</p><p>问先手是否有必赢策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> cerr(x) std::cerr &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; <span class="hljs-meta-string">&#x27;\n&#x27;</span></span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-comment">// index start from 0</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sgOnRootedTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; e, <span class="hljs-keyword">int</span> root)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = (<span class="hljs-keyword">int</span>)e.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sg</span><span class="hljs-params">(n)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) <span class="hljs-built_in">dfs</span>(v, u);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) ++cnt[sg[v]];<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cnt[ans]) ++ans;<br>    sg[u] = ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) --cnt[sg[v]];<br>  &#125;;<br>  <span class="hljs-built_in">dfs</span>(root, root);<br>  <span class="hljs-keyword">return</span> sg;<br>&#125;<br><span class="hljs-comment">// index start from 0, we should give a dirction for simplify</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sgOnTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = (<span class="hljs-keyword">int</span>)g.<span class="hljs-built_in">size</span>();<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n);<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span>, <span class="hljs-title">sg</span><span class="hljs-params">(n)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span>, <span class="hljs-title">sgFa</span><span class="hljs-params">(n, n + <span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-comment">// O(n) since there are exact n - 1 sides</span><br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; pdfs = [&amp;](<span class="hljs-keyword">int</span> u) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[u]) <span class="hljs-keyword">if</span> (v != p[u]) &#123;<br>      p[v] = u;<br>      e[u].<span class="hljs-built_in">emplace_back</span>(v);<br>      <span class="hljs-built_in">pdfs</span>(v);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) ++cnt[sg[v]];<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cnt[ans]) ++ans;<br>    sg[u] = ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) --cnt[sg[v]];<br>  &#125;;<br>  <span class="hljs-built_in">pdfs</span>(<span class="hljs-number">0</span>);<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; qdfs = [&amp;](<span class="hljs-keyword">int</span> u) &#123;<br>    ++cnt[sgFa[u]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) ++cnt[sg[v]];<br>    <span class="hljs-keyword">int</span> now = sg[u];<br>    <span class="hljs-keyword">while</span> (cnt[now]) ++now;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v) &#123;<br>      <span class="hljs-keyword">if</span> (--cnt[sg[v]] == <span class="hljs-number">0</span>) sgFa[v] = std::<span class="hljs-built_in">min</span>(now, sg[v]);<br>      ++cnt[sg[v]];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) --cnt[sg[v]];<br>    --cnt[sgFa[u]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-built_in">qdfs</span>(v);<br>  &#125;;<br>  <span class="hljs-built_in">qdfs</span>(<span class="hljs-number">0</span>);<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u) &#123;<br>    ++cnt[sgFa[u]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) ++cnt[sg[v]];<br>    <span class="hljs-keyword">int</span> now = sg[u];<br>    <span class="hljs-keyword">while</span> (cnt[now]) ++now;<br>    sg[u] = now;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) --cnt[sg[v]];<br>    --cnt[sgFa[u]];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-built_in">dfs</span>(v);<br>  &#125;;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> sg;<br>&#125;<br><span class="hljs-comment">// 多颗树怎么做（每一个堆可以取多种值）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">sgOnMulTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt;&amp; g)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> mex = [](std::vector&lt;<span class="hljs-keyword">int</span>&gt; sg) &#123;<br>    <span class="hljs-keyword">int</span> n = sg.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : sg) <span class="hljs-keyword">if</span> (x &lt; n) ++cnt[x];<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cnt[ans]) ++ans;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;;<br>  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp;x : g) ans ^= <span class="hljs-built_in">mex</span>(<span class="hljs-built_in">sgOnTree</span>(x));<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>)-&gt;<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">int</span> k;<br>  std::cin &gt;&gt; k;<br>  <span class="hljs-keyword">using</span> Node = std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;;<br>  <span class="hljs-function">std::vector&lt;Node&gt; <span class="hljs-title">e</span><span class="hljs-params">(k)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : e) &#123;<br>    <span class="hljs-keyword">int</span> n;<br>    std::cin &gt;&gt; n;<br>    x.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">int</span> u, v;<br>      std::cin &gt;&gt; u &gt;&gt; v;<br>      x[u].<span class="hljs-built_in">emplace_back</span>(v);<br>      x[v].<span class="hljs-built_in">emplace_back</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : <span class="hljs-built_in">sgOnTree</span>(x)) std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      std::cout &lt;&lt; <span class="hljs-built_in">sgOnRootedTree</span>(x, i)[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-built_in">sgOnMulTree</span>(e) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="阶梯-nim">阶梯 Nim</h2><p>有 m 堆石子 <span class="math inline">\((a_1, \cdots, a_m)\)</span> 每次可以从 i 位置移动 <span class="math inline">\(1 \leq c_i \leq a_i\)</span> 个石子到 i - 1 的位置。两人轮流进行，无法移动者输。</p><p>观察到偶数位置的石子不会影响结果（因为某人移动偶数位置石子，另一个人总能把移动的石子再次移动到偶数位置。因此最终结果其实就是 <span class="math inline">\(a_1 \oplus a_3 \cdots\)</span> 非零则先手赢，否则后手赢。</p><p>这个问题可以到树上做！也是类似的，每个点只能移动到它的父节点。还能拓展到每次移动到 k-祖先。还能拓展到换根的情形。例题：<a href="https://codeforces.com/contest/1498/problem/F">1498F</a>，那么我们每 2k 步异或一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n, k;<br>  std::cin &gt;&gt; n &gt;&gt; k;<br>  <span class="hljs-keyword">int</span> k2 = k * <span class="hljs-number">2</span>;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">e</span>(n);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x, y; i &lt; n; ++i) &#123;<br>    std::cin &gt;&gt; x &gt;&gt; y;<br>    --x; --y;<br>    e[x].<span class="hljs-built_in">emplace_back</span>(y);<br>    e[y].<span class="hljs-built_in">emplace_back</span>(x);<br>  &#125;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  std::vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">b</span>(n, std::vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span> * k)); <span class="hljs-comment">// 以 u 为节点的子树的答案</span><br>  <span class="hljs-keyword">auto</span> c = b; <span class="hljs-comment">// c 表示父节点当作儿子节点时，这个分支上的答案</span><br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; preDfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) &#123;<br>    b[u][<span class="hljs-number">0</span>] = a[u];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) &#123;<br>      <span class="hljs-built_in">preDfs</span>(v, u);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k2; ++i) &#123;<br>        b[u][(i + <span class="hljs-number">1</span>) % k2] ^= b[v][i];<br>      &#125;<br>    &#125;<br>  &#125;;<br>  <span class="hljs-built_in">preDfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>  std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; k2; ++i) &#123;<br>      ans[u] ^= b[u][i] ^ c[u][i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) <span class="hljs-keyword">if</span> (v != fa) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k2; ++i) &#123;<br>        c[v][(i + <span class="hljs-number">1</span>) % k2] = c[u][i] ^ b[u][i] ^ b[v][(i + k2 - <span class="hljs-number">1</span>) % k2];<br>      &#125;<br>      <span class="hljs-built_in">dfs</span>(v, u);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : ans) std::cout &lt;&lt; std::<span class="hljs-built_in">min</span>(<span class="hljs-number">1</span>, x) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个问题：有 <span class="math inline">\(n\)</span> 个位置 <span class="math inline">\(1,\cdots,n\)</span>，每个位置上有 <span class="math inline">\(a_i\)</span> 个石子。有两个人轮流操作。操作步骤是：挑选 <span class="math inline">\(1, \cdots, n\)</span> 中任一位置 <span class="math inline">\(i\)</span>，将至少 1 个石子全部移动至 <span class="math inline">\(j\)</span> 位置（<span class="math inline">\(0 \leq j &lt; i\)</span>，且 <span class="math inline">\(a_{j + 1} = \cdots = a_{i - 1} = 0\)</span>）。谁不能操作谁输。求先手必胜还是必败。（这个问题有点难，主要是能将奇数位置移动到奇数位置）</p><h2 id="不公平取石子的游戏">不公平取石子的游戏</h2><p>在 <a href="https://ac.nowcoder.com/acm/contest/9753/B">NewCoder</a> 上有个不公平的游戏：A 每次能取 <code>[1, p]</code> 个石子，B 能取 <code>[1, q]</code> 个石子，A 先。</p><p>显然 <span class="math inline">\(p = q\)</span> 时，就是之前的经典问题。只需考虑 <code>n % (p + 1)</code> 即可。若 <span class="math inline">\(p &gt; q\)</span>，那么 A 必胜，因为此时 <span class="math inline">\(p \geq q + 1\)</span>，所以有必胜策略（策略一：总能让剩余的为 0 或者 大于 p；策略二：若 <code>n % (p + 1)</code> 不为 0 就按照 q = p 处理，否则 A 第一次取 <code>p + 1</code>），若 <span class="math inline">\(p &lt; q\)</span>，只有 A 取完则赢，否则必输。</p><p>有 <code>m</code> 堆，</p><ul><li><span class="math inline">\(p = q\)</span>，经典问题，前面有结论。</li><li><span class="math inline">\(p &gt; q\)</span>，若存在 <span class="math inline">\(a_i\)</span> 使得 <span class="math inline">\(a_i &gt; q\)</span> 或 <span class="math inline">\(a_1 \oplus \cdots \oplus a_m \neq 0\)</span>，则 A 必赢。</li><li><span class="math inline">\(p &lt; q\)</span>，若存在大于一个 <span class="math inline">\(a_i\)</span> 使得 <span class="math inline">\(a_i &gt; p\)</span>，<span class="math inline">\(A\)</span> 必输。若所有 <span class="math inline">\(a_i \leq p\)</span> 那么就等于无限制。所以我们只需考虑，有唯一的一个 <span class="math inline">\(a_i &gt; p\)</span> 的情形，<span class="math inline">\(x = \oplus \cdots a_{i-1} \oplus a_{i + 1} \cdots \oplus a_m\)</span>，若 <span class="math inline">\(x = 0\)</span> 或者 <span class="math inline">\(x \oplus a_i &gt; p\)</span> 或者 <span class="math inline">\(x - x \oplus a_i &gt; p\)</span> 则 <span class="math inline">\(A\)</span> 必输。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">win</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> sg = <span class="hljs-number">0</span>, n = a.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">if</span> (p &gt; q) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (a[i] &gt; q) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sg ^= x;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) sg ^= x % (<span class="hljs-number">1</span> + p);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">int</span> ai = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) &#123;<br>      sg ^= x;<br>      <span class="hljs-keyword">if</span> (x &gt; p) &#123;<br>        <span class="hljs-keyword">if</span> (ai != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        ai = x;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ai != <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">int</span> aii = sg ^ ai;<br>      <span class="hljs-keyword">return</span> aii &lt;= p &amp;&amp; aii &lt;= ai &amp;&amp; ai - aii &lt;= p;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sg;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//freopen(&quot;in&quot;,&quot;r&quot;,stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">int</span> n, p, q;<br>  std::cin &gt;&gt; n &gt;&gt; p &gt;&gt; q;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  std::cout &lt;&lt; (<span class="hljs-built_in">win</span>(a, p, q) ? <span class="hljs-string">&quot;first player win&quot;</span> : <span class="hljs-string">&quot;second player win&quot;</span>) &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多人博弈合作收买间谍">多人博弈：合作，收买，间谍</h2><ul><li>如果不考虑合作策略，那么就会变成不公平的二人博弈游戏，可能出现没人有必胜策略。</li><li>如果考虑合作，那就有意思了，也复杂多了，这时候还有明面合作和暗面合作，还有就是间谍。</li></ul><p><a href="https://www.zhihu.com/question/449457734/answer/1805504444">知乎</a>。</p><p>m 个人 <span class="math inline">\(m &gt; 2\)</span>（<span class="math inline">\(m = 2\)</span> 就回到了普通的二人博弈情况），每个人可取 <span class="math inline">\([a, b](a &lt; b)\)</span>（<span class="math inline">\(a = b\)</span> 是平凡的，没有考虑的意义）。先取到 n 者赢。</p><p>当 n 充分大时，超过 <span class="math inline">\(\lfloor \frac{m}{2} \rfloor\)</span> 合作，则此群体必胜，即单个人没有必赢策略。<a href="https://www.zhihu.com/people/rt237">rt237</a> 给的证明十分漂亮。还可以考虑反问题：即先取到 n 者输。</p><h2 id="无限制取石子问题的反问题">无限制取石子问题的反问题</h2><p>一堆石子谁先取到最后一个谁输，做法：</p><p>首先剔除所有的 0，以及偶数个 1，并不会影响局面的胜负。空局面认为是胜。若此时堆的个数为 1，那么 <span class="math inline">\(a_1 = 1\)</span> 为输局面，其它为赢局面。如果堆数 <span class="math inline">\(n &gt; 1\)</span>。那么 <span class="math inline">\(a_1 \oplus \cdots \oplus a_n = 0\)</span> 为输局面，否则为赢局面。（首先对 <span class="math inline">\(n = 2\)</span> 数学归纳证明，然后对一般的 n 数学归纳证明。</p><h2 id="有顺序堆的取石子问题">有顺序堆的取石子问题</h2><p>例题：<a href="https://codeforces.com/problemset/problem/1382/B">1382B</a>。即看那一步有必赢且必输的策略。</p><p>如果此题加限制条件，每次最多取 <span class="math inline">\(m\)</span> 个，那么答案就是第一个 <span class="math inline">\(\mod (m + 1)\)</span> 大于 1 的数。但是要注意 取模后为 0 的情形。</p><h2 id="每次可取多堆">每次可取多堆</h2><p>例题：<a href="https://codeforces.com/contest/1451/problem/F">1451F</a></p><p>更多博弈问题可见：<a href="https://codeforces.com/problemset?tags=games">Codeforces-game</a></p><h2 id="sg-函数是因子个数-1">sg 函数是因子个数 + 1</h2><p>例题：<a href="https://codeforces.com/gym/102911/problem/C">codeforce gym 102911C</a>，从 <span class="math inline">\(n\)</span> 中取 <span class="math inline">\(k\)</span> 个满足 <span class="math inline">\(k &gt; 0\)</span> 且 <span class="math inline">\(n - k\)</span> 是 <span class="math inline">\(n\)</span> 的因子。设 <span class="math inline">\(n = p_1 ^{s_1} \cdots p_r^{s_r}\)</span>， 则 <span class="math inline">\(sg(n) = s_1 + \cdots s_r + 1\)</span>。</p><h2 id="一堆相邻之间有限制">一堆，相邻之间有限制</h2><p><span class="math inline">\(n\)</span> 个元素，每次最少取 <span class="math inline">\(1\)</span>，最多取 <span class="math inline">\(m\)</span> (<span class="math inline">\(m \geq 2\)</span>)，且相邻两个的和不能为 <span class="math inline">\(m + 1\)</span>。谁无法取谁输。</p><p>结论 <code>n % (m + 2) == 0</code> 则先手必输，反之先手必赢。</p><p>证明： 首先不难看出若 <span class="math inline">\(n \leq m + 1\)</span> 时，先手必赢，<span class="math inline">\(n = m + 2\)</span> 时，先手必输。</p><ul><li>若第一步先手取 <code>1</code>，那么后手取 <code>m - 1</code>，此时先手不能取 <code>2</code>（所以先手无法取完），若第二步先手取 <code>1</code>，那么后手取 <code>1</code>回到最初的情况（那么剩下的数为 <span class="math inline">\(n - m - 2\)</span> 又满足 <code>n % (m + 2) == 0</code>)。若第二步先手取 <code>3</code>，那么后手取 <span class="math inline">\(m - 1\)</span> （此时又回到了第一步的情况，再继续考虑第二步即可）。若 第二步先手取 <span class="math inline">\(x\)</span>(<span class="math inline">\(x \geq 4\)</span>), 后手取 <span class="math inline">\(m + 4 - x\)</span> 就回到了最初的情况。</li><li>若第一步先手取了 <code>x</code> (<span class="math inline">\(x \geq 2\)</span>) 那么后手取 <span class="math inline">\(m + 2 - x\)</span> 即可。</li></ul><p>反之 <code>k = n % (m + 2)</code>, <span class="math inline">\(k \neq 0\)</span>，若 <span class="math inline">\(k \leq m\)</span>，那么先手取 <span class="math inline">\(k\)</span> 即可。否则 <span class="math inline">\(k = m + 1\)</span>, 那先手取 <span class="math inline">\(m\)</span>，此时后手不能取 <span class="math inline">\(1\)</span>，因此后手取完之后，剩下的数依然满足 <span class="math inline">\(n \mod (m + 2) \neq 0\)</span>。</p><h2 id="一堆取的取走的需要和原来是数字与运算为-0">一堆，取的取走的需要和原来是数字与运算为 0</h2><p>当前 <span class="math inline">\(n\)</span>，每次取 <span class="math inline">\(1 \leq x \leq n, x \And n = 0\)</span>。无法取的输。</p><p>首次在 Codeforces 上看到，我<a href="https://codeforces.com/blog/entry/88374#comment-767851">评论</a> 种给出了答案。首先观察到后置 1 并不影响答案，打表观察发现到，<strong>F：若所有的 11 成对挨着出现（否则记作状态 T），那么先手输，否则先手赢</strong>。先删去后置的 1，不妨假设 <span class="math inline">\(n\)</span> 为偶数，如果我们在状态 F，那么我们看第一次成对 11 出现变化的位置，此时第一个 1 肯定不会变动，也就导致了 11 不成对出现；如果我们在状态 T，如果 1 的个数为奇数，那么我们就把最后一个 1 移动到最后（相当于删除了），然后让奇数个 1 向它右边的 1 靠拢（从左到右数）。至此说明 F 的下一步状态必为 T，T 存在一个到 F 的状态。且初始态 <span class="math inline">\(n = 0\)</span> 为 F 态。所以证毕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">solve</span><span class="hljs-params">(LL n)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (n &amp; <span class="hljs-number">1</span>) n &gt;&gt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (n) &#123;<br>    n &gt;&gt;= __builtin_ctzll(n);<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>      n &gt;&gt;= <span class="hljs-number">1</span>;<br>      flag = !flag;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多堆取走的需要和原来是数字与运算为-0">多堆，取走的需要和原来是数字与运算为 0</h2><blockquote><p>为了给群友解释，重新写一次。</p></blockquote><p>有 <span class="math inline">\(m\)</span> 堆石子 <span class="math inline">\(n_1, \cdots, n_m\)</span>，每次可以在其中一堆（比如第 <span class="math inline">\(i\)</span> 堆）中取 <span class="math inline">\(x_i\)</span> 个石子，且满足 <span class="math inline">\(1 \leq x_i \leq n_i, x_i \And n_i = 0\)</span>，无法取的人输，两人轮流游戏，且都以最优策略进行。问先手赢还是后手赢。</p><p>首先如果没有 <span class="math inline">\(x_i \And n_i = 0\)</span> 这个限制。那么这就是最经典的 nim 取石子游戏。先手赢当且仅当 <span class="math inline">\(n_1 \wedge \cdots \wedge n_m \neq 0\)</span>（这个可以从张一飞的集训队论文中找到解释）。上述问题也是经典的 SG nim 游戏的一种特殊情况有一般性的做法：</p><p>（仅需考虑一堆的情况）设 <span class="math inline">\(k_1, k_2, \cdots k_r\)</span> 为所有 <span class="math inline">\(n\)</span> 的合理的下一步可能那么 <span class="math inline">\(sg(n)\)</span> 就定义成 <span class="math inline">\(MEX(sg(k_1), \cdots, sg(k_r))\)</span>（即未出现的最小的非负整数），其中 <span class="math inline">\(sg(n) = 0\)</span>，表示 <span class="math inline">\(n\)</span> 个石子时，先手输。若 <span class="math inline">\(sg(n) \neq 0\)</span> 那么先手必然存在一个策略 <span class="math inline">\(k_i\)</span> 使得 <span class="math inline">\(sg(k_i) = 0\)</span>（这是 MEX 的定义可推出）。这就给出了 sg 函数。先手赢当且仅当 <span class="math inline">\(sg(n_1) \wedge \cdots \wedge sg(n_m) \neq 0\)</span>。</p><p>可以用上述方法证明如果没有 <span class="math inline">\(x_i \And n_i = 0\)</span> 这个限制，<span class="math inline">\(sg(n) = n\)</span>。如果把限制改成 <span class="math inline">\(1 \leq x_i \leq \min(M, n_i)\)</span> 那么 <span class="math inline">\(sg(n) = n \mod (M + 1)\)</span>。这些都是经典结果。</p><p>我们回到原来的问题：仅需考虑一堆的情况，即 <span class="math inline">\(n\)</span> 个石子，每次取 <span class="math inline">\(x\)</span> 个满足 <span class="math inline">\(1 \leq x \leq n, x \And n = 0\)</span>。首先观察到输赢仅与 <span class="math inline">\(n\)</span> 的二进制表示有关，且我们删除后置的 1 不会影响结果。对于上述问题，我无法给它的 sg 一个简单的表达式，我打表观察（用 bitset）规律也没有观察出个啥。只知道 <span class="math inline">\(sg(n) \neq 0\)</span> 当且仅当 <span class="math inline">\(n\)</span> 的二进制中存在 <code>0(奇数个连续的 1)0</code> 这种形式的子串。即我仅仅知道一堆的情况下，谁会赢。我打完表就不期待这个问题 sg 有简单的表达式了，能有一个 <span class="math inline">\(O(\log n)\)</span> 或者 <span class="math inline">\(O(\log^2 n)\)</span> 的做法就万幸了，所以需要各位群友大大的帮助！</p><blockquote><p>我在 <a href="https://codeforces.com/blog/izlyforever">codeforces</a> 上也提了这个问题，希望群友大大们能抬一手不要让它淹没于大海。</p></blockquote><p><a href="https://codeforces.com/blog/entry/88386?#comment-768681">wery0</a> 给了一个 <span class="math inline">\(O(n^{\log_2 3})\)</span> 的做法（一开始不理解，后来根据他的 Talk 懂了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nim</span> &#123;</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; sg&#123;<span class="hljs-number">0</span>&#125;, cnt;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverseBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n ^ ((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">32</span> - __builtin_clz(n)) - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sg.<span class="hljs-built_in">size</span>() &gt;= n) <span class="hljs-keyword">return</span>;<br>    cnt.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sg.<span class="hljs-built_in">size</span>(); i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) &#123;<br>        sg.<span class="hljs-built_in">emplace_back</span>(sg[i &gt;&gt; <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">int</span> m = <span class="hljs-built_in">reverseBit</span>(i);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j; j = (j - <span class="hljs-number">1</span>) &amp; m) &#123;<br>        ++cnt[sg[i - j]];<br>      &#125;<br>      <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (cnt[r]) ++r;<br>      sg.<span class="hljs-built_in">emplace_back</span>(r);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j; j = (j - <span class="hljs-number">1</span>) &amp; m) &#123;<br>        --cnt[sg[i - j]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(*std::<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) r ^= sg[x];<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://codeforces.com/blog/entry/88386?#comment-768681">wery0</a> 给了一个 <span class="math inline">\(O(n^{\log_2 3} \log n)\)</span> 的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nim</span> &#123;</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; sg&#123;<span class="hljs-number">0</span>&#125;;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> r = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i *= <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> ((n &amp; i) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (x &amp; <span class="hljs-number">1</span>) r -= i;<br>      x /= <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sg.<span class="hljs-built_in">size</span>(); i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) &#123;<br>        sg.<span class="hljs-built_in">emplace_back</span>(sg[i &gt;&gt; <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      std::set&lt;<span class="hljs-keyword">int</span>&gt; S;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>        <span class="hljs-keyword">int</span> now = <span class="hljs-built_in">f</span>(i, j);<br>        <span class="hljs-keyword">if</span> (now &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        S.<span class="hljs-built_in">insert</span>(sg[now]);<br>      &#125;<br>      <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (S.<span class="hljs-built_in">count</span>(r)) ++r;<br>      sg.<span class="hljs-built_in">emplace_back</span>(r);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(*std::<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) r ^= sg[x];<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一种更快的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nim</span> &#123;</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; sg&#123;<span class="hljs-number">0</span>&#125;;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> r = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i *= <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> ((n &amp; i) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (x &amp; <span class="hljs-number">1</span>) r -= i;<br>      x /= <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sg.<span class="hljs-built_in">size</span>() &gt;= n) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sg.<span class="hljs-built_in">size</span>(); i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) &#123;<br>        sg.<span class="hljs-built_in">emplace_back</span>(sg[i &gt;&gt; <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      std::stack&lt;<span class="hljs-keyword">int</span>&gt; S;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>        <span class="hljs-keyword">int</span> now = <span class="hljs-built_in">f</span>(i, j);<br>        <span class="hljs-keyword">if</span> (now &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        ++cnt[sg[now]];<br>        S.<span class="hljs-built_in">push</span>(sg[now]);<br>      &#125;<br>      <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (cnt[r]) ++r;<br>      sg.<span class="hljs-built_in">emplace_back</span>(r);<br>      <span class="hljs-keyword">while</span> (!S.<span class="hljs-built_in">empty</span>()) &#123;<br>        --cnt[S.<span class="hljs-built_in">top</span>()];<br>        S.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(*std::<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>()) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) r ^= sg[x];<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="另一种姿势的实现">另一种姿势的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> watch(x) std::cout &lt;&lt; (#x) &lt;&lt; <span class="hljs-meta-string">&quot; is &quot;</span> &lt;&lt; (x) &lt;&lt; std::endl</span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> N&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nim</span> &#123;</span><br>  std::vector&lt;<span class="hljs-keyword">int</span>&gt; sg, cnt;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Nim</span>() : <span class="hljs-built_in">sg</span>(N), <span class="hljs-built_in">cnt</span>(N + <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, msk = <span class="hljs-number">0</span>, m; i &lt; N; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) &#123;<br>        sg[i] = sg[i &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> ((i &amp; -i) == i) msk = i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>      m = msk ^ i;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j; j = (j - <span class="hljs-number">1</span>) &amp; m) &#123;<br>        ++cnt[sg[i - j]];<br>      &#125;<br>      <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span> (cnt[r]) ++r;<br>      sg[i] = r;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = m; j; j = (j - <span class="hljs-number">1</span>) &amp; m) &#123;<br>        --cnt[sg[i - j]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) r ^= sg[x];<br>    <span class="hljs-keyword">return</span> r;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// freopen(&quot;in&quot;, &quot;r&quot;, stdin);</span><br>  std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>  std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">auto</span> start = std::<span class="hljs-built_in">clock</span>();<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">2</span>;<br>  Nim&lt;N&gt; A;<br>  <span class="hljs-keyword">int</span> n;<br>  std::cin &gt;&gt; n;<br>  <span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : a) std::cin &gt;&gt; x;<br>  std::cout &lt;&lt; A.<span class="hljs-built_in">solve</span>(a) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Time used: &quot;</span> &lt;&lt; (std::<span class="hljs-built_in">clock</span>() - start) &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多堆取的取走的需要和原来是数字或运算为自己">多堆，取的取走的需要和原来是数字或运算为自己</h2><p>显然 <code>sg(n) = __built_in_popcount(n)</code></p><h2 id="每次可以取小于-m-堆中的任意多个元素不能一个不取">每次可以取小于 m 堆中的任意多个元素（不能一个不取）</h2><p>做法：考虑二进制，对于任意给定位，这一位的 1 的个数和都是 m 的倍数，那么就后手赢，否则先手赢。</p><p>对于否则的情况，我们总可以找到考虑最高位不是 m 的倍数，然后随便选择余数个（当前位为 1 的）进行改变。并且这些数后面的位是可以任意改变的。然后再继续往低位跑，显然，最终选取的个数总和小于 m。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 每次选择在 x 堆(0 &lt; x &lt; m) 取石子，不能取的输</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">multNim</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;LL&gt; &amp;a, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  LL mx = *std::<span class="hljs-built_in">max_element</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">int</span> ln = std::__lg(mx + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ln; ++i) &#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : a) <span class="hljs-keyword">if</span> ((x &gt;&gt; i) &amp; <span class="hljs-number">1</span>) ++cnt;<br>    <span class="hljs-keyword">if</span> (cnt % m) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多堆codeforce-103274g-的变种">多堆，<a href="https://codeforces.com/gym/103274/problem/G">codeforce 103274G</a> 的变种</h2><p>有 <span class="math inline">\(k\)</span> 堆石子 <span class="math inline">\(n_1, n_2, \cdots, n_k\)</span>(<span class="math inline">\(\sum n_i \leq N\)</span>)，每一个 <span class="math inline">\(n_i\)</span> 的二进制中 1 的个数都是偶数。每次可以从某一堆 i 中取 <span class="math inline">\(x_i\)</span> 个，<span class="math inline">\(1 \leq x_i \leq m_i\)</span>，<span class="math inline">\(1 \leq m_i \leq M\)</span>，取完之后需要保证剩下的石子的二进制中 1 的个数为偶数，无法取的人输。</p><p>使用一个 RingBuffer 和一个 cnt 和一个 mask。需要计算的是 mex（注意到值不会超过 m）</p><p>如果 <span class="math inline">\(m \leq 64\)</span>（注意到二进制中 1 的奇偶性的均匀型，所以 <span class="math inline">\(m &lt; 128\)</span> 就可以做）, 利用二进制和 <code>__builtin_ctzll</code> 更新 mex，那么 1.5s 内可以做到 <span class="math inline">\(n &lt; 5 \cdots 10^8\)</span>，<a href="https://codeforces.com/gym/103274/submission/133211770">提交记录</a></p><p>如果 <span class="math inline">\(m \leq 1000\)</span>, 暂存当前 mex，根据 cnt 更新 mex，那么 1s 可以做到 <span class="math inline">\(n &lt; 10^7\)</span>，<a href="https://codeforces.com/gym/103274/submission/133210540">提交记录</a>，注意这里的复杂度为 <span class="math inline">\(O(n m)\)</span> 很差，但是统计效果很好。</p><p>如果 <span class="math inline">\(m\)</span> 不加限制，其实我们也可以利用 <code>vector&lt;LL&gt;</code> 自己封装的 bitset，用二进制和 <code>__builtin_ctzll</code> 更新 mex，10s 做到 <span class="math inline">\(n &lt; 10^9, m &lt; 10^8\)</span>, <a href="https://codeforces.com/gym/103274/submission/133246717">提交记录</a></p><p>所以如果使用上面策略，那么我们可以用 mask 上 mask 就可以常数次搞定答案了～，即 <span class="math inline">\(m &lt; 64^2\)</span>，我可以搞了。然后再往前嵌套？继续套娃吗？确实可以！</p><h2 id="二分图博弈">二分图博弈</h2><p><a href="https://www.cnblogs.com/LLCSBlog/p/13882635.html">别人写的挺好</a></p><p>例题：<a href="https://codeforces.com/gym/102832/problem/H">102832H</a></p><p>先手必胜当且仅当任何一个最大匹配方案都包含初始状态。</p><p>判定: 不加入初始节点，跑一遍最大流，加入初始节点，再跑一次最大流，有变化所以先手必赢。</p><p>另外如果先手可选择初始状态（进入算一次），那么先手输当且仅当图是完全匹配。</p><h2 id="位置博弈">位置博弈</h2><p>只能朝着几个方向走，走出区域者输</p><p>例题：<a href="https://codeforces.com/contest/1451/problem/D">1451D</a></p><h2 id="不公平博弈">不公平博弈</h2><h3 id="surreal-number">surreal Number</h3><p>直接按顺序看</p><ul><li><a href="http://www.matrix67.com/blog/archives/6333">Matrix67</a></li><li>2009 年集训队论文 方展鹏《浅谈如何解决不平等博弈问题》</li><li>唐纳德所著的《Surreal Numbers》106 页不推荐</li></ul><p>即可，还是很优美的，没啥例题，就 POJ 2931</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不公平博弈，a[i] 值域为 &#123;1, -1&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">surrealNumber</span><span class="hljs-params">(std::vector&lt;<span class="hljs-keyword">int</span>&gt; a)</span> </span>&#123;<br>  <span class="hljs-keyword">double</span> r = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, n = a.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; a[i] == a[<span class="hljs-number">0</span>]) r += a[i], ++i;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> k = <span class="hljs-number">2</span>; i &lt; n; ++i, k *= <span class="hljs-number">2</span>) r += a[i] / k;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-comment">// 模板例题：https://vjudge.net/problem/POJ-2931</span><br></code></pre></td></tr></table></figure><h3 id="横切竖切游戏">横切竖切游戏</h3><p>先看例题：<a href="https://vjudge.net/problem/HDU-3544" class="uri">https://vjudge.net/problem/HDU-3544</a></p><p>切割游戏，这里是题解：<a href="https://www.cnblogs.com/AOQNRMGYXLMV/p/4462791.html" class="uri">https://www.cnblogs.com/AOQNRMGYXLMV/p/4462791.html</a></p><p>从特殊的，小的开始分析，然后，大表找规律，并且不妨假设 <span class="math inline">\(n \times m, n \geq m\)</span>，<span class="math inline">\(m = 1\)</span>时，可以切 <span class="math inline">\(n - 1\)</span> 刀。<span class="math inline">\(m = 2\)</span> 时，我们发现 <span class="math inline">\(2 \times 2\)</span> 先切的人吃亏，即局面为 0，切出 <span class="math inline">\(1 \times 2\)</span> 更吃亏，所以不难看出可以且 <span class="math inline">\(\frac{n}{2} - 1\)</span> 刀。<span class="math inline">\(m = 3\)</span> 时，你会发现也是按照 <span class="math inline">\(m = 2\)</span> 的情况来切，<span class="math inline">\(m = 4\)</span> 就不一样了。因此不难发现 <span class="math inline">\(m\)</span> 为 2 的幂次的时候有本质区别。也就是下面的核心代码，证明下次一定把。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (n &lt; m) &#123;<br>    flag = <span class="hljs-literal">false</span>;<br>    std::<span class="hljs-built_in">swap</span>(n, m);<br>  &#125;<br>  <span class="hljs-keyword">int</span> ans = (n &gt;&gt; std::__lg(m)) - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> flag ? ans : -ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自然数方幂和公式及其快速算法</title>
    <link href="/powSum/"/>
    <url>/powSum/</url>
    
    <content type="html"><![CDATA[<h2 id="自然数方幂和公式">自然数方幂和公式</h2><p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了...)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。</p><span id="more"></span><h2 id="若-a_n-nn-1-求其前-n-项和-s_n">若 <span class="math inline">\(a_n = n(n-1)\)</span> 求其前 <span class="math inline">\(n\)</span> 项和 <span class="math inline">\(S_n\)</span></h2><p><span class="math display">\[a_n = n(n-1) ＝ \frac{(n+1)n(n-1) -n(n-1)(n-2)}{3}\]</span></p><p>所以</p><p><span class="math display">\[S_n =\frac{(n+1)n(n-1)}{3}\]</span></p><blockquote><p>受到上面做法的启发，我们推广到一般形式：</p></blockquote><h2 id="若-a_n-a_n-p则其前-n-项和-s_n-frac-a_n1-p1p1">若 <span class="math inline">\(a_n = A_n ^p\)</span>，则其前 <span class="math inline">\(n\)</span> 项和 <span class="math inline">\(S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}\)</span></h2><p><span class="math display">\[a_n = A_n ^p ＝ \frac{A_{n+1} ^{p+1} -A_n ^{p+1}}{p+1}\]</span></p><p>所以</p><p><span class="math display">\[S_n = \frac{A_{n+1} ^{p+1}}{p+1}\]</span></p><p>由上面的结论，我们可以直奔主题了</p><h2 id="求-1222-dots-n2">求 <span class="math inline">\(1^2+2^2+ \dots + n^2\)</span></h2><p>由 <span class="math display">\[n^2 = n(n-1) + n\]</span> 知 <span class="math display">\[1^2+2^2+ \dots + n^2 = \frac{(n+1)n(n-1)}{3} + \frac{(n+1)n}{2} = \frac{n(n+1)(2n+1)}{6}\]</span></p><blockquote><p>同理我们可以推广上面做法</p></blockquote><h2 id="求1p2p-dots-np">求<span class="math inline">\(1^p+2^p+ \dots + n^p\)</span></h2><p>设</p><p><span class="math display">\[n^p = a_p A_n ^p + a_{p-1} A_n ^{p-1} + a_{p-2} A_n ^{p-2} + \cdots + a_1 A_n ^1\]</span> 则</p><p><span class="math display">\[1^p+2^p+ \dots + n^p = \frac{a_p A_{n+1} ^{p+1}}{p+1} + \frac{a_{p-1} A_{n+1} ^{p}}{p} + \cdots + \frac{a_1 A_{n+1} ^2}{2}\]</span> 因此问题的关键就转化成如何求解数组 <span class="math inline">\(a_k ,k=1,2,\cdots,p\)</span> 我们发现当 <span class="math inline">\(n＝k\)</span> 时成立 <span class="math display">\[k^p = a_k A_k ^k + a_{k-1} A_k ^{k-1} + \cdots a_1 A_{k} ^1\]</span> 令 <span class="math inline">\(b_k = k! \cdot a_k\)</span> 则</p><p><span class="math display">\[k^p = b_k + b_{k-1} C_k ^{k-1} + \cdots b_1 C_{k} ^1\]</span> 即</p><p><span class="math display">\[k^p = \sum _{j=1} ^k b_j C _{k} ^j\]</span> 应用二项式反演 [我的博文](../inverseFormulaAndItsMatrixForm）</p><p><span class="math display">\[b_k = \sum _{j=1} ^k (-1)^{k-j} C _{k} ^j j^p\]</span> 因此最终，我们有公式</p><p><span class="math display">\[1^p+2^p+ \dots + n^p = \sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}\]</span></p><blockquote><p>妙呀，帅的呀，猛的呀，不谈了呀，哈哈哈</p><p>这个东西本质叫 离散微积分，也叫下降幂。</p></blockquote><p>生成函数，离散微积分，上升幂下降幂，Stirling 数，牛顿多项式，特别的有用</p><h2 id="自然数方幂和快速算法">自然数方幂和快速算法</h2><p>这次写的目的是因为上次是从数学上完美的解决了这个问题，这次我们要从计算上完美的解决这个问题，当然这归功于我看到的一份 <a href="http://codeforces.com/profile/sgtlaugh">sgtlaugh</a> 的代码。经过解读体会到其中的奥秘，特此记录。一句话，简直不敢相信。 &gt; 如果有人说他能在 <span class="math inline">\(O(k)\)</span> 时空复杂度求解 <span class="math inline">\(\sum_{i=1}^n i^k\)</span>，你肯定会说这怎么可能别忽悠我了，那我只能说，因为你没看过这篇博文。</p><h2 id="首先预处理ok-复杂度-求-sum_i1n-ik-其中-n-leq-k">首先预处理，<span class="math inline">\(O(k)\)</span> 复杂度 求 <span class="math inline">\(\sum_{i=1}^n i^k\)</span> 其中 <span class="math inline">\(n \leq k\)</span></h2><p>我之前一直以为要用 <span class="math inline">\(k \log k\)</span> 的复杂度才能解决这个问题，其实我们只需对所有素数 <span class="math inline">\(p\)</span> 计算 <span class="math inline">\(p^k\)</span> 即可。对于一般的 <span class="math inline">\(i\)</span> 我们先预处理 其最小素因子 <span class="math inline">\(sp[i]\)</span>。计算 <span class="math inline">\(sp[i]^k \cdot (i/sp[i])^k\)</span> 即可（具体可见最后代码）。由于素数的阶为 <span class="math inline">\(O(\frac{k}{\log k})\)</span> 因此整个复杂度即为 <span class="math inline">\(O(k)\)</span>。</p><h2 id="再由-lagrange-插值多项式得出最终答案">再由 Lagrange 插值多项式得出最终答案</h2><p>因为我们知道 <span class="math inline">\(\sum_{i=1} ^n i^k\)</span> 一定是一个关于 <span class="math inline">\(n\)</span> 的次数为 <span class="math inline">\(k+1\)</span> 的多项式。因此，我们只需计算其在 <span class="math inline">\(0,\cdots,k+1\)</span> 上的取值，用 Lagrange 插值多项式即可知道答案。</p><blockquote><p>对于一个次数不超过 <span class="math inline">\(n\)</span> 的多项式 <span class="math inline">\(f(x)\)</span>，其在不同位置 <span class="math inline">\(x_0,\cdots,x_n\)</span> 的取值唯一决定了这个多项式:</p></blockquote><p><span class="math display">\[f(x) = \sum_{i=0} ^n f(x_i) \prod_{j=0,j \neq i} ^n \frac{x-x_j}{x_i - x_j}\]</span></p><h3 id="具体到本问题我们取-xn-mk1-x_ii-那么">具体到本问题，我们取 <span class="math inline">\(x=n, m=k+1, x_i=i\)</span> 那么</h3><p><span class="math display">\[f(n) = \sum_{i=0} ^m (-1)^{m-i} f(x_i) {n \choose i}  {n-i-1 \choose m-i }\]</span></p><h2 id="例题codeforces-622f">例题：Codeforces 622F</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">6</span>;<br><span class="hljs-keyword">const</span> LL mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> sp[N],p[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spf</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// samllest prime factor</span><br>  <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;p[cnt++]=<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;N;i+=<span class="hljs-number">2</span>) sp[i]=<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i+=<span class="hljs-number">2</span>) sp[i]=i;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;i&lt;N;i+=<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">if</span>(sp[i]==i)    p[cnt++] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; cnt &amp;&amp; p[j]&lt;=sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123;<br>      sp[i * p[j]] = p[j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">pow_mod</span><span class="hljs-params">(LL x,LL n,LL p)</span></span>&#123;<br>  LL r=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(n)&#123;<br>    <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) r=r*x%p;<br>    n&gt;&gt;=<span class="hljs-number">1</span>;  x=x*x%p;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br>LL inv[N],AP[N],AS[N],f[N];<br><span class="hljs-function">LL <span class="hljs-title">getpowsum</span><span class="hljs-params">(LL n,<span class="hljs-keyword">int</span> k)</span></span>&#123; <span class="hljs-comment">// mod &gt; k</span><br>  <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> n%mod;<br>  <span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>]!=<span class="hljs-number">2</span>) <span class="hljs-built_in">spf</span>();<br>  <span class="hljs-keyword">int</span> nk=k+<span class="hljs-number">1</span>;<br>  f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=nk;++i)&#123;<br>    <span class="hljs-keyword">if</span>(sp[i]==i) f[i]=<span class="hljs-built_in">pow_mod</span>(i,k,mod);<br>    <span class="hljs-keyword">else</span>         f[i]=f[sp[i]]*f[i/sp[i]]%mod;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=nk;++i)&#123;<br>    f[i]+=f[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">if</span>(f[i]&gt;=mod) f[i]-=mod;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(n&lt;=nk) <span class="hljs-keyword">return</span> f[n];<br>  LL tmp = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=nk;++i)    tmp=tmp*i%mod;<br>  inv[nk] = <span class="hljs-built_in">pow_mod</span>(tmp,mod<span class="hljs-number">-2</span>,mod);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=nk<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) inv[i]=inv[i+<span class="hljs-number">1</span>]*(i+<span class="hljs-number">1</span>)%mod;<br>  AP[<span class="hljs-number">0</span>]=AS[nk]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=nk;++i)   AP[i]=AP[i<span class="hljs-number">-1</span>]*(n+<span class="hljs-number">1</span>-i)%mod;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=nk<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) AS[i]=AS[i+<span class="hljs-number">1</span>]*(n-i<span class="hljs-number">-1</span>)%mod;<br>  LL res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=nk;++i)&#123; <span class="hljs-comment">// because f(i)=0</span><br>    LL x = f[i]*AP[i]%mod*AS[i]%mod*inv[i]%mod*inv[nk-i]%mod;<br>    <span class="hljs-keyword">if</span>((nk-i)&amp;<span class="hljs-number">1</span>) res-=x; <span class="hljs-comment">// be careful</span><br>    <span class="hljs-keyword">else</span>        res+=x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (res%mod+mod)%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  LL n;<br>  <span class="hljs-keyword">int</span> k;<br>  <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;k)&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">getpowsum</span>(n,k)&lt;&lt;endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实际上我们可以不求 <span class="math inline">\(\mod p\)</span> 后的答案，利用大数类得到标准答案，但是这时因为数字实在太大，每次乘法的用时过大，因此仅适合 <span class="math inline">\(k&lt;n\)</span> 的情况</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cpp_int f[N];<br><span class="hljs-function">cpp_int <span class="hljs-title">getpowsum</span><span class="hljs-params">(LL n,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-built_in">cpp_int</span>(n);<br>  <span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>]!=<span class="hljs-number">2</span>) <span class="hljs-built_in">spf</span>();<br>  <span class="hljs-keyword">int</span> nk=<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>;<br>  f[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;f[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=nk+<span class="hljs-number">1</span>;++i)&#123;<br>    <span class="hljs-keyword">if</span>(sp[i]==i) f[i]=<span class="hljs-built_in">pow</span>(<span class="hljs-built_in">cpp_int</span>(i),k);<br>    <span class="hljs-keyword">else</span>         f[i]=f[sp[i]]*f[i/sp[i]];<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=nk;++i) f[i]+=f[i<span class="hljs-number">-1</span>];<br>  <span class="hljs-keyword">if</span>(n&lt;=nk)   <span class="hljs-keyword">return</span> f[n];<br>  cpp_int res = <span class="hljs-number">0</span>,tl=<span class="hljs-number">1</span>,tr=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=nk<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i) tr=tr*(n-i<span class="hljs-number">-1</span>)/(nk-i);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=nk;++i)&#123;<br>    <span class="hljs-keyword">if</span>((nk-i)&amp;<span class="hljs-number">1</span>) res -= f[i]*tl*tr;<br>    <span class="hljs-keyword">else</span>         res += f[i]*tl*tr;<br>    tl = tl*(n-i)/(i+<span class="hljs-number">1</span>);<br>    tr = tr*(nk-i)/(n-i<span class="hljs-number">-1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其实如果我们知道最终的上界，求出多个 <span class="math inline">\(\mod p\)</span> 后的答案，再用中国剩余定理貌似很不错。</p></blockquote><h3 id="该方法可以推广成求-sum_i1n-fik其中-fx-是多项式具体分析即可">该方法可以推广成求 <span class="math inline">\(\sum_{i=1}^n f(i)^k\)</span>，其中 <span class="math inline">\(f(x)\)</span> 是多项式。具体分析即可</h3><p>这种情况一般很难再做到 <span class="math inline">\(O(k)\)</span> 时间复杂度，而变成了 <span class="math inline">\(O(k \log k) \deg f\)</span> 复杂度。</p><h3 id="如果求所有-fk-sum_i-1n-ik-k-0-cdots-m可以在-om-log-m-复杂度求出">如果求所有 <span class="math inline">\(f(k) = \sum_{i = 1}^n i^k, k = 0, \cdots, m\)</span>，可以在 <span class="math inline">\(O(m \log m)\)</span> 复杂度求出</h3><p><span class="math inline">\(\frac{f(k)}{k!}\)</span> 是 <span class="math inline">\(\sum_{i = 1}^n e^{ix} = e^x \frac{e^{nx} - 1}{e^x - 1}\)</span> 的 <span class="math inline">\(x^k\)</span> 的系数。注意到 <span class="math inline">\(e^x - 1\)</span> 的常数项系数为 0，所以不可逆，要分子分母同时除以 <span class="math inline">\(x\)</span>，所以求它们的时候要多预算一位。</p><p>这里用幂生成函数而非常规生成函数是因为 <span class="math inline">\(\sum_{i = 1}^n \frac{1}{1 - i x}\)</span> 不好计算，维护分子分母分治可以在 <span class="math inline">\(O(n \log^2 n)\)</span> 计算出结果。</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输出源代码本身的源代码</title>
    <link href="/printSelf/"/>
    <url>/printSelf/</url>
    
    <content type="html"><![CDATA[<p>我们可以把计算机看成一个函数，将一份代码映成一段输出，那么输出为代码本事就是数学中不动点。</p><p>任意语言都有很多相应版本的这种程序，原理都是类似的，目前有 cpp 和 python 的版本</p><span id="more"></span><p>代码原理和步骤</p><ol type="1"><li>先把头写好，定义好数组，记作头部</li><li>开始对数组赋值一直赋值到头部，然后空几行</li><li>把头用数组打印出来，再讲数组全部打印出来，再将后面的部分打印出来</li><li>再去空的几行，做数组赋值，赋值的时候后面的每一行</li></ol><blockquote><p>注意代码中特殊字符需要转义，不然就很尬了，而且代码不能用 tab 缩进</p><p>文件打印就太没水平了，这里就不给出了</p></blockquote><h2 id="cpp-版本">cpp 版本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string a[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>a[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;#include&lt;iostream&gt;&quot;</span>;<br>a[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;#include&lt;string&gt;&quot;</span>;<br>a[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;using namespace std;&quot;</span>;<br>a[<span class="hljs-number">3</span>]=<span class="hljs-string">&quot;string a[10];&quot;</span>;<br>a[<span class="hljs-number">4</span>]=<span class="hljs-string">&quot;int main()&#123;&quot;</span>;<br>a[<span class="hljs-number">5</span>]=<span class="hljs-string">&quot;for(int i=0;i&lt;5;++i) cout&lt;&lt;a[i]&lt;&lt;endl;&quot;</span>;<br>a[<span class="hljs-number">6</span>]=<span class="hljs-string">&quot;for(int i=0;i&lt;10;++i) cout&lt;&lt;char(97)&lt;&lt;char(91)&lt;&lt;i&lt;&lt;char(93)&lt;&lt;char(61)&lt;&lt;char(34)&lt;&lt;a[i]&lt;&lt;char(34)&lt;&lt;char(59)&lt;&lt;endl;&quot;</span>;<br>a[<span class="hljs-number">7</span>]=<span class="hljs-string">&quot;for(int i=5;i&lt;10;++i) cout&lt;&lt;a[i]&lt;&lt;endl;&quot;</span>;<br>a[<span class="hljs-number">8</span>]=<span class="hljs-string">&quot;return 0;&quot;</span>;<br>a[<span class="hljs-number">9</span>]=<span class="hljs-string">&quot;&#125;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i) cout&lt;&lt;a[i]&lt;&lt;endl;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i) cout&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(<span class="hljs-number">97</span>)&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(<span class="hljs-number">91</span>)&lt;&lt;i&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(<span class="hljs-number">93</span>)&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(<span class="hljs-number">61</span>)&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(<span class="hljs-number">34</span>)&lt;&lt;a[i]&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(<span class="hljs-number">34</span>)&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(<span class="hljs-number">59</span>)&lt;&lt;endl;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">5</span>;i&lt;<span class="hljs-number">10</span>;++i) cout&lt;&lt;a[i]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="python-版本">python 版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(sys.argv[<span class="hljs-number">0</span>]) <span class="hljs-keyword">as</span> f:<br>  <span class="hljs-built_in">print</span>(f.read(), end =<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>但是利用传入参数读文件属实耍赖，所以在写一个不用读文件的版本：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>))<br>a[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a = list(range(6))&#x27;</span><br>a[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;print(a[0])&#x27;</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;for i in range(6):&#x27;</span><br>a[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;    print(&quot;a[&quot;+str(i)+&quot;] = &quot;+chr(39)+a[i]+chr(39))&#x27;</span><br>a[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;for i in range(1,5): print(a[i])&#x27;</span><br>a[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;print(a[5], end = &quot;&quot;)&#x27;</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a[&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;] = &quot;</span>+<span class="hljs-built_in">chr</span>(<span class="hljs-number">39</span>)+a[i]+<span class="hljs-built_in">chr</span>(<span class="hljs-number">39</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>): <span class="hljs-built_in">print</span>(a[i])<br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">5</span>], end = <span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>最后一行是因为 Python 默认以 print 回车结尾 我无法用 tab 缩进，只能用空格缩进，这是唯一不完美的地方</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>cpp</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>$\pi(x)$ 的计算</title>
    <link href="/computationOfPiX/"/>
    <url>/computationOfPiX/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(\pi(x)\)</span> 表示不超过 <span class="math inline">\(x\)</span> 的素数个数。容易看出可以在 <span class="math inline">\(O(N)\)</span> 时间复杂度，<span class="math inline">\(O(N)\)</span> 空间复杂度离线预处理求出小于 <span class="math inline">\(N\)</span> 的素数全体。但是如果 <span class="math inline">\(N=10^{14}\)</span> 或者更大，这种做法必然是不现实的。因此下面给出高效的求解方法...</p><p>理论基础: 参考潘承洞《数论基础》以及<a href="countPrime.zip">论文包.zip</a></p><span id="more"></span><h2 id="psixs"><span class="math inline">\(\psi(x,s)\)</span></h2><p><span class="math inline">\(\psi(x,s)\)</span> 表示不超过 <span class="math inline">\(x\)</span> 且能不能被前 <span class="math inline">\(s\)</span> 个素数整除的正整数个数。即 <span class="math display">\[\psi(x,s) = \sum_{n \leq x} \sum_{d|(n,m_s)} \mu(d) = \sum_{d|m_s} u(d)\lfloor \frac{x}{d} \rfloor\]</span> 其中 <span class="math inline">\(m_s = p_1 \cdots p_s\)</span> 为前 <span class="math inline">\(s\)</span> 个素数的积。</p><p>另一方面，显然我们有 <span class="math display">\[\psi(x,s) = \psi(x,s-1) - \psi(\frac{x}{p_s},s-1)\]</span></p><h2 id="pix"><span class="math inline">\(\pi(x)\)</span></h2><p>我们知道一个数 <span class="math inline">\(n&gt;1\)</span> 是素数当且仅当不存在素数 <span class="math inline">\(p \leq \sqrt{n}\)</span> 使得 <span class="math inline">\(p \mid n\)</span>。因此当 <span class="math inline">\(s \geq \pi(\sqrt{x})\)</span> 时， <span class="math display">\[\psi(x,s) = \pi(x) - s + 1\]</span></p><h2 id="p_kxs"><span class="math inline">\(P_k(x,s)\)</span></h2><p>设 <span class="math inline">\(P_k(x,s)\)</span> 为 <strong>不超过 <span class="math inline">\(x\)</span> 且每个素因子都大于 <span class="math inline">\(p_s\)</span> 且素因子(按重根计)个数为 <span class="math inline">\(k\)</span></strong> 的整数个数（方法属于 Lehmer）。 进一步设 <span class="math inline">\(P_0(x,s)=1\)</span>。则 <span class="math display">\[\psi(x,s) = \sum_{k=0} ^{\infty} P_k(x,s)\]</span> 显然 <span class="math inline">\(P_1(x,s) = \pi(x)-s\)</span>。</p><p>若 <span class="math inline">\(\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})\)</span> 则 <span class="math inline">\(P_k(x,s)=0,k \geq 3\)</span> 此时 <span class="math display">\[\psi(x,s) = 1 + \pi(x)-s + P_2(x,s)\]</span> 其中 <span class="math display">\[P_2(x,s) = \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \pi(\frac{x}{p_k}) - k + 1 \right)\]</span></p><blockquote><p>注意到上式中 <span class="math inline">\(\frac{x}{p_k} &lt; x^{\frac{2}{3}}\)</span></p></blockquote><h2 id="pix-的计算公式"><span class="math inline">\(\pi(x)\)</span> 的计算公式</h2><p><span class="math display">\[\pi(x) = \psi(x,s) + \frac{(\pi(\sqrt{x})+s-2)(\pi(\sqrt{x})- s+1)}{2} - \sum_{k=s+1}^{\pi(\sqrt{x})} \pi(\frac{x}{p_k})\]</span></p><blockquote><p>取上面 $s = () $ 因此问题最终转化成求 <span class="math inline">\(\psi(x,\pi(\sqrt[3]{x}))\)</span>。它可以利用</p></blockquote><ol type="1"><li><span class="math inline">\(\psi(x,0) = \lfloor x \rfloor\)</span></li><li><span class="math inline">\(\psi(x,s) = \psi(x,s-1) - \psi(\frac{x}{p_s},s-1)\)</span></li></ol><p>至此问题貌似就这么解决了。但是由于这个递归会使得程序效率大大降低，因此需要一些预处理操作。</p><ol type="1"><li>若 <span class="math inline">\(x&lt;p_s\)</span> 则 <span class="math inline">\(\psi(x,s) ＝ 1\)</span></li><li>给定一个小整数 M，预处理出 <span class="math inline">\(\psi(x,s)\)</span>,其中 <span class="math inline">\(x &lt; q=p_1 \cdots p_s,\quad s&lt;=M\)</span> 则 <span class="math inline">\(\psi(x,s) = \psi(x \mod q,s) + \lfloor \frac{x}{q} \rfloor \psi(q,s)\)</span></li></ol><h2 id="lehmer-计算公式">lehmer 计算公式</h2><blockquote><p>我自己写的代码没有上面的快，两种计算各有优势</p></blockquote><p>令 <span class="math inline">\(s = \pi(\sqrt[4]{x}), t= \pi(\sqrt[3]{x})\)</span>。则，对任意 <span class="math inline">\(i&gt;3, P_i(x,s) = 0\)</span>, <span class="math display">\[\begin{array}{rl}\psi(x,s) &amp;= 1 + \pi(x) - s + P_2(x,s) + P_3(x,s) \\&amp;= 1+ \pi(x) - s  + P_2(x,s) + \sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1) \\\end{array}\]</span></p><p>即： <span class="math display">\[\pi(x) = \psi(x,s)-1+s-P_2(x,s) - \sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1)\]</span></p><blockquote><p>注意到 <span class="math inline">\(\frac{x}{p_k} &lt; \sqrt{x}\)</span> ，所以最后一个式子可以用下式求，最后计算复杂度在于 <span class="math inline">\(P_2(x,s)\)</span></p></blockquote><p><span class="math display">\[\sum_{k=s+1}^{t} P_2(\frac{x}{p_k},k-1) = \sum_{k=s+1}^{t}  \sum_{j=k}^{\pi(\sqrt{\frac{x}{p_k}})} \pi(\frac{x}{p_k p_j}) - j+1\]</span></p><h2 id="稳定简洁的-dp-做法">稳定简洁的 DP 做法</h2><p>我们令 <span class="math inline">\(dp(x,s) = \psi(x,s)+s-1\)</span> 它的意义是，<span class="math inline">\(2～x\)</span> 中被前 <span class="math inline">\(s\)</span> 个素数筛完后的伪素数个数。因此我们有 <span class="math inline">\(dp(0,0)=0,dp(x,0)=x-1,x&gt;1,dp(x,\pi(\sqrt{x})) = \pi(x)\)</span> 且有状态转移 <span class="math display">\[dp(x,s) = dp(x,s-1)-dp(\frac{x}{p_s},s-1)+s-1\]</span> 因为 <span class="math inline">\(dp(p_{s-1},s-1) = s-1\)</span>，最后一项可以写成 <span class="math inline">\(dp(p_{s-1},s-1)\)</span>。虽然上面需要二维数组，但是实际上我们可以优化成一维数组的情况。因为 <span class="math display">\[dp(x,s) = dp(x,s-1)-dp(\frac{x}{p_s},s-1)+ dp(p_{s-1},s-1)\]</span> 另外我们也不可能开 <span class="math inline">\(O(n)\)</span> 的数组，但是可以利用一种黑科技开 <span class="math inline">\(O(\sqrt{n})\)</span> 的数组即可达到我们的目的。 即我们用 <span class="math inline">\(L[x]\)</span> 表示 <span class="math inline">\(dp(x,s)\)</span> 用 <span class="math inline">\(R[x]\)</span> 表示 <span class="math inline">\(dp(\frac{n}{x},s)\)</span>。</p><blockquote><p>若<span class="math inline">\(L[m]!=L[m-1]\)</span> ，则说明 <span class="math inline">\(m\)</span> 不能被前 <span class="math inline">\(s\)</span> 个素数整除是第 <span class="math inline">\(s+1\)</span> 个素数。</p><p>我们需要的是 <span class="math inline">\(R[1]\)</span></p></blockquote><p>上述做法的时间复杂度为 <span class="math inline">\(O(\frac{n}{\log n})\)</span> 且常数特别小，代码十分简洁。</p><blockquote><p>这个骚方法还目前还没有找到其它的应用 0.0</p><p>主要还没法对它用树状数组</p></blockquote><h2 id="求第-n-个素数的方法">求第 n 个素数的方法</h2><ul><li>根据概率分布找到大致界限</li><li>再牛顿梯度法（或者二分查找）使得 <span class="math inline">\(\pi(m)= n\)</span></li><li>素数判断递减 <span class="math inline">\(m\)</span> 直到 <span class="math inline">\(m\)</span> 为素数</li><li><a href="p/nthPrimeNumber.html">参考这里</a></li></ul><h2 id="psixs-计算太慢了需要优化"><span class="math inline">\(\psi(x,s)\)</span> 计算太慢了，需要优化</h2><p>我们知道，若 <span class="math inline">\(\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})\)</span> 则 <span class="math display">\[\psi(x,s) = 1 + \pi(x)-s + P_2(x,s)\]</span> 其中 <span class="math display">\[P_2(x,s) = \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \pi(\frac{x}{p_k}) - k + 1 \right) =  \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \psi(\frac{x}{p_k},s)+ s - k \right)\]</span></p><blockquote><p>注意到上式中 $ &lt; x^{} $</p></blockquote><p>我们之前的操作本质是递归让 <span class="math inline">\(x,s\)</span> 变小，通过打表预处理来加速递归使得满足一定的效率需要。</p><p>现在我们来直接计算得到我们的答案。</p><h3 id="符号约定">符号约定</h3><p>取定整数 <span class="math inline">\(\sqrt[3]{x} \leq y = x^{\frac{1}{3}+\epsilon }&lt; \sqrt{x}, z = \frac{x}{y}, s = \pi(y)\)</span> ，约定 <span class="math inline">\(p, q\)</span> 是素数。 预处理 <span class="math inline">\(y\)</span> 以内的数组：<code>isp[], p[], mu[], pi[]</code> ，对 <span class="math inline">\([1,z]\)</span> 内的 <span class="math inline">\(\psi(x,s)\)</span> 用树状数组（可以在我的博客网站搜索：<code>树状数组</code>）维护（注意到这需要 <span class="math inline">\(O(z)\)</span> 的内存，单次维护不现实，所以我们可以一段段的维护，保证每一段的长度为 <span class="math inline">\(2^{\lfloor \log_2(y) \rfloor +1}\)</span> 来提高效率）</p><blockquote><p>做完上面的预处理后，我们发现 <span class="math inline">\(P_2(x,s)\)</span> 可以直接计算了。</p></blockquote><h3 id="psixs-直接计算"><span class="math inline">\(\psi(x,s)\)</span> 直接计算</h3><p>在本博文的最开始有： <span class="math display">\[\psi(x,s) = \sum_{n \leq x} \sum_{d|(n,p)} \mu(d) = \sum_{d|p} u(d)\lfloor \frac{x}{d} \rfloor\]</span> 其中 <span class="math inline">\(p\)</span> 为前 <span class="math inline">\(s\)</span> 个素数的积。</p><blockquote><p>但是最右边本质上有很多项，所以直接算，其实复杂度特别高。</p></blockquote><p>我们还有递归公式： <span class="math display">\[\begin{array}{cl}\psi(x,s) &amp;= \psi(x,s-1) - \psi(\frac{x}{p_s},s-1) \\&amp;= \psi(x,s-2) - \psi(\frac{x}{p_{s-1}},s-2) - \psi(\frac{x}{p_s},s-2)  + \psi(\frac{x}{p_sp_{s-1}},s-2)\end{array}\]</span> 可以一直分解下去，如果一直分解下去就可以得到最上面的公式了。</p><p>所以我们约定：对于节点 <span class="math inline">\(\mu(n) \psi(\frac{x}{n},b)\)</span> ，如果满足</p><ul><li>原始节点： <span class="math inline">\(b = c, n \leq y\)</span></li><li>特殊节点：<span class="math inline">\(n &gt; y\)</span></li></ul><p>就不再分解。这也等价于说 如果 <span class="math inline">\(n &lt; y\)</span> 且 <span class="math inline">\(b&gt;c\)</span> 就分解。因为一开始 <span class="math inline">\(n=1,b=a&gt;c\)</span>。而且 <span class="math inline">\(n\)</span> 会增大，<span class="math inline">\(b\)</span> 会减小，所以节点一定会有限步内，落入上述两种框架中的一种。并且 <strong>特殊节点的父节点 <span class="math inline">\(-\mu(n) \psi(\frac{x}{\frac{n}{p_{d+1}}},b+1)\)</span></strong> 必然满足 <span class="math inline">\(\frac{n}{ p_{d+1} } \leq y &lt;n\)</span> 且 <span class="math inline">\(b+1&gt;c\)</span>。综上：</p><blockquote><p>以前设置 <span class="math inline">\(c = 7\)</span>，但是后来发现没必要，<span class="math inline">\(c=0\)</span> 就挺好。</p></blockquote><p><span class="math display">\[\psi(x,s) = \sum_{n=1} ^y \mu(n) \lfloor \frac{x}{n} \rfloor +  \sum_{\frac{n}{\delta(n)} \leq y &lt; n} \mu(n) \psi(\frac{x}{n}, \pi(\delta(n))-1) = S_0 + S\]</span></p><p><span class="math inline">\(S_0\)</span> 很好处理，计算 <span class="math inline">\(S\)</span>： 对 <span class="math inline">\(p = \delta(n)\)</span> 一起求： <span class="math display">\[S = - \sum_{p \leq y} \sum_{\begin{array}{c} \delta(m) &gt;p \\ m \leq y &lt; mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)\]</span> 注意到：<span class="math inline">\(\frac{x}{mp} &lt; z\)</span> ，所以我们已经可以把 <span class="math inline">\(\psi(x,s)\)</span> 直接计算出来了。</p><blockquote><p>但是我们可以避免很多计算来提高效率。于是我们有下列一系列的操作</p></blockquote><ul><li><span class="math inline">\(p \geq \sqrt{y}\)</span>，则 <span class="math inline">\(m\)</span> 为素数 ，且此时 <span class="math inline">\(mp &gt; p^2 \geq y\)</span> (若 <span class="math inline">\(m\)</span> 为合数，则 <span class="math inline">\(m \geq \delta(m) ^2 &gt;p^2 \geq y\)</span> 矛盾)</li><li><span class="math inline">\(\frac{x}{mp} &lt; p\)</span> 时，<span class="math inline">\(\psi(\frac{x}{mp},\pi(p)-1) = 1\)</span></li><li><span class="math inline">\(\sqrt{\frac{x}{mp}} &lt; p\)</span> 时，<span class="math inline">\(\psi(\frac{x}{mp},\pi(p)-1) = \pi(\frac{x}{mp}) - \pi(p) +2\)</span></li><li><span class="math inline">\(\sqrt{y} &lt; \sqrt{z} &lt; x^{\frac{1}{4}} &lt; x^{\frac{1}{3}} &lt; y\)</span></li></ul><h4 id="由此对s分段计算">由此对<span class="math inline">\(S\)</span>分段计算</h4><p><span class="math display">\[S_1 = - \sum_{\sqrt[3]{x} &lt; p \leq y} \sum_{\begin{array}{c} \delta(m) &gt;p \\ m \leq y &lt; mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)\]</span></p><p><span class="math display">\[S_2 = - \sum_{\sqrt{z} &lt; p \leq \sqrt[3]{x}} \sum_{\begin{array}{c} \delta(m) &gt;p \\ m \leq y &lt; mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)\]</span></p><p><span class="math display">\[S_3 = - \sum_{\sqrt{y} &lt; p \leq \sqrt{z}} \sum_{\begin{array}{c} \delta(m) &gt;p \\ m \leq y &lt; mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)\]</span></p><p><span class="math display">\[S_4 = - \sum_{p \leq \sqrt{y}} \sum_{\begin{array}{c} \delta(m) &gt;p \\ m \leq y &lt; mp \end{array}} \mu(m) \psi(\frac{x}{mp},\pi(p)-1)\]</span></p><p>由限制关系式，我们化简 <span class="math inline">\(S_1, S_2, S_3\)</span> <span class="math display">\[\begin{array}{cl}S_1 &amp;= - \sum_{\sqrt[3]{x} &lt; p \leq y} \sum_{p&lt;q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\&amp;=  \sum_{\sqrt[3]{x} &lt; p &lt; q \leq y} 1 \\&amp;= {\pi(y)-\pi(\sqrt[3]{x}) \choose 2}\end{array}\]</span></p><p><span class="math display">\[\begin{array}{cl}S_2 &amp;= - \sum_{\sqrt{z} &lt; p \leq \sqrt[3]{x}} \sum_{p&lt;q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\&amp;=  \sum_{\sqrt{z} &lt; p \leq \sqrt[3]{x}} \sum_{p&lt;q \leq y} \pi(\frac{x}{pq}) - \pi(p) +2 \\&amp;= \sum_{\sqrt{z} &lt; p \leq \sqrt[3]{x}} \sum_{p&lt;q \leq y} \pi(\frac{x}{pq}) + \sum_{\sqrt{z} &lt; p \leq \sqrt[3]{x}} (\pi(p)-\pi(y))(\pi(p)-2)\end{array}\]</span></p><p><span class="math display">\[\begin{array}{cl}S_3 &amp;= - \sum_{\sqrt{y} &lt; p \leq \sqrt{z}} \sum_{p &lt; q \leq y} \mu(q) \psi(\frac{x}{pq},\pi(p)-1) \\&amp;=  \sum_{\sqrt{y} &lt; p \leq \sqrt{z}}  \sum_{p &lt; q \leq y} \psi(\frac{x}{pq},\pi(p)-1)\end{array}\]</span></p><blockquote><p><span class="math inline">\(S_2\)</span> 也可以用 <span class="math inline">\(S_3\)</span> 的式子求，只是效率不高。</p><p><span class="math inline">\(S_2\)</span> 中 <span class="math inline">\(\frac{x}{pq}, p&lt;y\)</span>，即可以直接求。</p></blockquote><p><strong>当然了还可以继续细化，但是我嫌麻烦就不想再细化了！</strong></p><blockquote><p>也就是现在的核心就是树状数组分段维护数据，然后每一段的总值要用数组存起来就好了。然后用这个数据结果计算 <span class="math inline">\(S_2,S_3,S_4,P_2(x,s)\)</span>，然后就大功告成了 0.0</p><p>用 <span class="math inline">\(\psi(x,s)\)</span> 计算 <span class="math inline">\(\pi(x)\)</span>，还是用 <span class="math inline">\(\pi(x)\)</span> 计算 <span class="math inline">\(\psi(x,s)\)</span> ，这是一个问题。</p><p>用树状数组维护的时候会有一个很大的问题就是：求和式中 每此动 <span class="math inline">\(p\)</span> 整个维护就要从 <span class="math inline">\(1 \to p\)</span> 重新维护一次很麻烦。这个问题没解决所以我不想写代码。</p><p>想把 <span class="math inline">\(\frac{x}{pq}\)</span> 的所有可能的值单调递增排列但是又不现实。</p></blockquote><h2 id="第-n-个素数">第 n 个素数</h2><blockquote><p>做法依赖于 <span class="math inline">\(\pi(x)\)</span> 的计算</p></blockquote><h3 id="素数定理-这里就不证了">素数定理( 这里就不证了)</h3><p><span class="math display">\[\lim _{x \to \infty} \frac{\pi(x)}{x/\ln x} = 1\]</span></p><p>从而我们知道： <span class="math display">\[\lim _{x \to \infty} \frac{p_n}{n \ln n} = 1\]</span> 其中，<span class="math inline">\(p_n\)</span> 为第 <span class="math inline">\(n\)</span> 个素数，显然 <span class="math inline">\(p_n\)</span> 是 <span class="math inline">\(\pi(x) = n\)</span> 最小的解。</p><h3 id="p_n-求解"><span class="math inline">\(p_n\)</span> 求解</h3><ul><li>预处理小于 <span class="math inline">\(N\)</span> 的素数</li><li>初始值 <span class="math inline">\(n\ln n\)</span></li><li>牛顿梯度法</li></ul><p><a href="https://primes.utm.edu/nthprime/index.php#nth">第 <span class="math inline">\(n\)</span> 个素数和 <span class="math inline">\(\pi(x)\)</span> 的网站</a></p><p><a href="https://github.com/kimwalisch/primecount">世界纪录保持者的求法</a></p><h2 id="sum_p-leq-n-p-text-is-prime-p"><span class="math inline">\(\sum_{p \leq n, p \text{ is prime}} p\)</span></h2><p>我们可以在不求出 <strong>不超过 <span class="math inline">\(x\)</span> 的所有素数</strong> 的情况下，求出最终结果。</p><p><span class="math display">\[f_k(x) \doteq \sum_{p \leq x} p^k\]</span></p><ul><li><span class="math inline">\(f_0(x) = \pi(x)\)</span></li><li><span class="math inline">\(f_1(x) = \sum_{p \leq x} p\)</span> 这是我们关心的结果</li><li>对于一般的 <span class="math inline">\(k\)</span> 借助自然数方幂和快速算法也可以求</li></ul><h3 id="f_kxs最小素因子大于-p_s-且不超过-x-的数的-k-次方和"><span class="math inline">\(f_k(x,s)\)</span>：最小素因子大于 <span class="math inline">\(p_s\)</span> 且不超过 <span class="math inline">\(x\)</span> 的数的 <span class="math inline">\(k\)</span> 次方和</h3><p><span class="math display">\[f_k(x,s) = \sum_{m \leq x, \delta(m)&gt;p_s} m^k\]</span> 其中，<span class="math inline">\(\delta(m)\)</span> 表示 <span class="math inline">\(m\)</span> 的最小素因子（约定 <span class="math inline">\(\delta(1) = + \infty\)</span>）。</p><h3 id="f_kxs-的递推公式"><span class="math inline">\(f_k(x,s)\)</span> 的递推公式</h3><p><span class="math display">\[\begin{aligned}f_k(x,s) &amp;= \sum_{m \leq x, \delta(m)&gt;p_s} m^k \\&amp;= f(x,s-1) - \sum_{m \leq x, \delta(m) = p_s} m^k \\&amp;= f(x,s-1) - p_s ^k f(\frac{x}{p_s},s-1)\end{aligned}\]</span></p><blockquote><p><span class="math inline">\(\displaystyle f_k(x,0) = \sum_{i=1} ^ {\lfloor x \rfloor} i^k\)</span></p></blockquote><h3 id="f_kxs-和-f_kx-的关系"><span class="math inline">\(f_k(x,s)\)</span> 和 <span class="math inline">\(f_k(x)\)</span> 的关系</h3><p>若 <span class="math inline">\(s &gt;= \pi(\sqrt{x})\)</span>，则 <span class="math display">\[f_k(x) = f_k(x,s) - 1  + f_k(p_s)\]</span></p><p>其实我们还可以，类似于 <span class="math inline">\(\pi(x)\)</span> 的计算一样, 取 <span class="math inline">\(\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})\)</span> <span class="math display">\[f_k(x) = f_k(x,s) - 1  + f_k(p_s) - \sum_{i=s+1} ^ {\pi(\sqrt{x})} (f(\frac{x}{p_i})-f(p_{i-1})) p_i ^k\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>math</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环的 Zariski 拓扑(素谱)</title>
    <link href="/zariskiTopologyOfRing/"/>
    <url>/zariskiTopologyOfRing/</url>
    
    <content type="html"><![CDATA[<p>设 <span class="math inline">\(A\)</span> 是(交换)环。令 <span class="math inline">\(X\)</span> 为 <span class="math inline">\(A\)</span> 的素理想全体，定义 <span class="math inline">\(V(E)\)</span> 为 <span class="math inline">\(A\)</span> 中包含 <span class="math inline">\(E\)</span> 的素理想全体，则将所有 <span class="math inline">\(V(E)\)</span> 看做闭集，它满足拓扑空间三条公理，即构成了拓扑，该拓扑称作 Zariski 拓扑，这个拓扑空间叫做环 <span class="math inline">\(A\)</span> 的素谱，记作 <span class="math inline">\(Spec(A)\)</span>。</p><p>有了拓扑，我们自然要考虑：</p><ol type="1"><li>集合的内部、闭包</li><li>拓扑的基，拓扑的分离性，紧性</li><li>空间的连通性，不可约性</li><li>拓扑空间的连续函数等等概念</li></ol><p>在这个具体拓扑下的样子。</p><span id="more"></span><h2 id="zariski-拓扑">Zariski 拓扑</h2><p>要证明 <span class="math inline">\(T = \lbrace V(E),E \subset A \rbrace\)</span> 作为闭集确实构成了一个拓扑，即证明 <span class="math inline">\(\emptyset \in T,X \in T\)</span>，且 <span class="math inline">\(T\)</span> 中任意并，有限交运算是封闭的。而显然我们有</p><ol type="1"><li><span class="math inline">\(V(0)=X,V(A)=\emptyset\)</span></li><li><span class="math inline">\(\cap_{i \in I} V(E_i) = V(\cup_{i \in I}E_i)\)</span></li><li>为说明 <span class="math inline">\(V(E_1) \cap V(E_2) \in T\)</span> 我们需要一些准备工作。</li></ol><p>设 <span class="math inline">\(I(E)\)</span> 为由 <span class="math inline">\(E\)</span> 生成的理想，定义 <span class="math display">\[\sqrt{\alpha} = \lbrace x\in A : x^n \in \alpha \rbrace\]</span> 则显然我们有</p><ol type="1"><li><span class="math inline">\(\alpha \subset \sqrt{\alpha} = \sqrt{\sqrt{\alpha}}\)</span></li><li><span class="math inline">\(\sqrt{\alpha \beta} = \sqrt{\alpha \cap \beta} = \sqrt{\alpha} \cap \sqrt{\beta}\)</span></li><li><span class="math inline">\(\sqrt{\alpha}=(1) \Leftrightarrow \sqrt{\alpha}\)</span></li><li><span class="math inline">\(\sqrt{\alpha+\beta} = \sqrt{ \sqrt{\alpha}+\sqrt{\beta} }\)</span></li><li>若 <span class="math inline">\(p\)</span> 是素理想，<span class="math inline">\(\sqrt{p} = p\)</span>。</li><li><span class="math inline">\(V(E)=V(I(E))=V(\sqrt{I(E)})\)</span></li><li><span class="math inline">\(V(\alpha \cap \beta)=V(\alpha \beta)=V(\alpha) \cup V(\beta)\)</span></li><li><span class="math inline">\(\cap_{p \in V(\alpha)} p = \sqrt{\alpha}\)</span></li><li><span class="math inline">\(V(E_1) = V(E_2) \Leftrightarrow \sqrt{I(E_1)} = \sqrt{I(E_2)}\)</span></li></ol><p>因此，<span class="math inline">\(V(E_1) \cap V(E_2) = V(I(E_1)) \cap V(I(E_2)) = V(I(E_1) \cap I(E_2)) \in T\)</span>。这说明它确实满足拓扑空间的三条公理。</p><h2 id="例子">例子</h2><p>有了拓扑之后，我们自然用具体的例子来看一下，这个拓扑大致长什么样子。 考虑 <span class="math inline">\(Spec(\mathbb{Z})\)</span> ，此时 <span class="math inline">\(X = \lbrace (p) : p\text{ is prime } \rbrace \cup (0)\)</span>。可以看出，包含 <span class="math inline">\((0)\)</span> 闭集仅有 <span class="math inline">\(X\)</span>，除 <span class="math inline">\((0)\)</span> 外，<span class="math inline">\(X\)</span> 中的单点集全是闭集。因此 <span class="math inline">\(Spec(\mathbb{Z})\)</span> 不是 <span class="math inline">\(T_1\)</span> 空间，由此可见，一般地，<span class="math inline">\(Spec(A)\)</span> 不是 <span class="math inline">\(T_1\)</span> 空间，即此拓扑的分离性很差。</p><h2 id="内部和闭包">内部和闭包</h2><p>因为在一般的拓扑理论中我们有 <span class="math inline">\(A^{o} = \overline{A^c} ^c\)</span>，因此，我们只需搞清楚 <span class="math inline">\(A^{o}\)</span> 和 <span class="math inline">\(\overline{A}\)</span>中任意一个即可，我们考虑闭包(<span class="math inline">\(\overline{A}\)</span>)。对于 <span class="math inline">\(Y \subset X\)</span>。若 <span class="math inline">\(Y \subset V(E)\)</span> 则 <span class="math inline">\(\forall \; p \in Y, E \in p\)</span>,即 $ E _{p Y} p$。因此 <span class="math inline">\(Y \subset V(\cap_{p \in Y}) \subset V(E)\)</span>。因此 <span class="math inline">\(\overline{Y} = V(\cap_{p \in Y})\)</span>。 特别地，</p><ol type="1"><li><span class="math inline">\(\overline{\lbrace p_x \rbrace} = V(p_x)\)</span></li><li><span class="math inline">\(\overline{\lbrace p_x \rbrace} = \lbrace p_x \rbrace \Leftrightarrow p_x\)</span> 是极大理想。</li><li><span class="math inline">\(p_y \in \overline{\lbrace p_x \rbrace} \Leftrightarrow p_x \subset p_y\)</span></li><li><span class="math inline">\(X\)</span> 是 <span class="math inline">\(T_0\)</span> 空间（<span class="math inline">\(p_y \notin \overline{\lbrace p_x \rbrace}\)</span> 或者 <span class="math inline">\(p_x \notin \overline{\lbrace p_y \rbrace}\)</span>）。</li></ol><p>因此，这样就很清楚为何在之前的例子<span class="math inline">\(Spec(\mathbb{Z})\)</span>中除<span class="math inline">\((0)\)</span>外单点集都是闭集了。有了之前的结论我们再看一下其他的例子。 <span class="math inline">\(Spec(\mathbb{R})\)</span>：此时 <span class="math inline">\(X = \lbrace 0 \rbrace\)</span> 只有一个元素拓扑是平凡的。 因为 若 <span class="math inline">\(A\)</span> 为域,则 <span class="math inline">\(A[x]\)</span> 为 ED 为 PID，其素理想为 <span class="math inline">\((f)\)</span> 不可约多项式。且 PID 中非零素理想就是极大理想。 <span class="math inline">\(Spec(\mathbb{C}[x])\)</span>: 此时 <span class="math inline">\(X = \lbrace (x+t): t \in \mathbb{C} \rbrace \cup \lbrace (0) \rbrace\)</span> <span class="math inline">\(Spec(\mathbb{R}[x])\)</span>: 此时 <span class="math inline">\(X = \lbrace (x+t): t \in \mathbb{R} \rbrace \cup \lbrace (x^2+ax+b): a,b \in \mathbb{R},a^2 &lt; 4b \rbrace \cup \lbrace (0) \rbrace\)</span></p><h2 id="基紧性">基，紧性</h2><p>由于 <span class="math inline">\(V(\cup_{i \in I}E_i) = \cap_{i \in I} V(E_i)\)</span> 我们定义 <span class="math inline">\(X_E = X \setminus V(E)\)</span>。则 <span class="math inline">\(X_E = \cup_{f \in E} X_f\)</span> 这说明 <span class="math inline">\(X_f,f \in A\)</span> 确实构成了 <span class="math inline">\(X\)</span> 的一组基。<span class="math inline">\(X_f\)</span> 表示不包含 <span class="math inline">\(f\)</span> 的素理想全体。</p><ol type="1"><li><span class="math inline">\(X_f \cap X_g = X_{fg}\)</span></li><li><span class="math inline">\(X_f = \emptyset \Leftrightarrow f\)</span> 是幂零的。</li><li><span class="math inline">\(X_f = X \Leftrightarrow f\)</span> 是单位。</li><li><span class="math inline">\(X_f = X_g \Leftrightarrow \sqrt{(f)} = \sqrt{(g)}\)</span></li></ol><h3 id="x-是拟紧的"><span class="math inline">\(X\)</span> 是拟紧的</h3><blockquote><p>这里的拟紧,实际上就是一般点集拓扑学中的紧，在代数中紧这个概念是拟紧＋Hausdorff。</p></blockquote><p>我们只需证明：若 <span class="math inline">\(\cup_{f \in S} X_f = X\)</span> 则存在有限并使上式成立。实际上，</p><p><span class="math display">\[\cup_{f \in S} X_f = X \Leftrightarrow V(I(S))=V(S) = \emptyset\]</span> 因此 <span class="math inline">\(I(S)=A\)</span>，即 <span class="math inline">\(1 = \sum_{i=1}^n a_i s_i\)</span>。所以<span class="math inline">\(I(s_1,\cdots,s_n) = A\)</span>，即 <span class="math inline">\(\cup_{i=1}^n X_{s_i} = X\)</span>。证毕。</p><h3 id="x_f-是拟紧的"><span class="math inline">\(X_f\)</span> 是拟紧的</h3><p>我们只需证明：若 <span class="math inline">\(X_f \subset \cup_{g \in S} X_g\)</span>，则存在有限并使上式成立。实际上，</p><p><span class="math display">\[X_f \subset \cup_{g \in S} X_g  \Leftrightarrow V(\sqrt{I(S)}) = V(S) \subset V(f)\]</span> 因此 <span class="math inline">\(f \in \sqrt{I(S)}\)</span>，即 <span class="math inline">\(f^m = \sum_{i=1}^n a_i s_i\)</span>。所以 <span class="math inline">\(f^m \in I(s_1,\cdots,s_n)\)</span>即。<span class="math inline">\(X_f \subset \cup_{i=1}^n X_{s_i}\)</span>。证毕。</p><h3 id="任意开集-y-subset-x-是拟紧的当且仅当-y-可以写成有限多个-x_f-的并">任意开集 <span class="math inline">\(Y \subset X\)</span> 是拟紧的当且仅当 <span class="math inline">\(Y\)</span> 可以写成有限多个 <span class="math inline">\(X_f\)</span> 的并</h3><p>Proof: 由 <span class="math inline">\(X_f\)</span> 是拟紧的知道，“<span class="math inline">\(\Leftarrow\)</span>” 是显然的。 “<span class="math inline">\(\Rightarrow\)</span>” 是因为存在<span class="math inline">\(E \subset A\)</span> 使得 <span class="math display">\[Y = X_E = \cup_{f \in E} X_f\]</span> 是 <span class="math inline">\(Y\)</span> 的一个开覆盖，由于是拟紧的，因此可以写成有限个 <span class="math inline">\(X_f\)</span> 的并，证毕。</p><blockquote><p>以上结论来自 Atiyah《An Introduction to Coummutative Algebra》习题。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>李代数</title>
    <link href="/lieAlgebra/"/>
    <url>/lieAlgebra/</url>
    
    <content type="html"><![CDATA[<p>近期在整理 Lie Algebra 课的笔记，还是很喜欢这门课的，主要是本科时候矩阵玩的特别 6，然后 Lie Algebra 可以认为是矩阵的推广版本。里面的证明技巧性相当强。我之所以喜欢数学很大程度与数学技巧有关。但是我的导师说，这些虽然很有技巧，但是你花时间都是可以处理的，会技巧没什么了不起，脑袋稍微好一点就能做这种事，长期技巧的训练其实意义并不大，应该更关注数学内部的东西，具体说就是一个代数对象的结构，分类，不变量，对象之间的同构。一个概念有哪些等价形式，与其它概念之间的关系，搞清楚这些更为重要，它们的证明只要大致知道怎么过来的就行。我们并不要把证明的细节放在心中，因为我们已经经过了多年的训练，相信我们通过大致步骤就能给出详细的证明，只是花的时间多少罢了。当然初学一个东西，去抠它的细节是无可厚非的。</p><blockquote><p>以上纯属废话 0.0</p></blockquote><span id="more"></span><h2 id="定义">定义</h2><p>交换环 <span class="math inline">\(K\)</span> 上的模 <span class="math inline">\(L\)</span>，以及一个运算 <span class="math inline">\(L \times L \to L,(x,y) \mapsto [x,y]\)</span> 称为 <span class="math inline">\(x,y\)</span> 的 Lie 括号，或交换子，并称 <span class="math inline">\(L\)</span> 是 <span class="math inline">\(K\)</span> 上的 Lie Algebra，如果满足如下公理。 L1. <span class="math inline">\([\cdot,\cdot]\)</span> 是双线性的； L2. <span class="math inline">\([x,x]=0\)</span> 对任意 <span class="math inline">\(x \in L\)</span> 成立； L3. <span class="math inline">\([x,[y,z]]+[y,[z,x]]+[z,[x,y]]=0\)</span> (Jacobi 恒等式)</p><p>若 <span class="math inline">\([L,L]=0\)</span> 则上面结论显然成立，此时称为 Abelian Lie Algebra。</p><blockquote><p>我们通常并不考虑 Abelian Lie Algebra。并且要求交换环 <span class="math inline">\(K\)</span> 是域 <span class="math inline">\(F\)</span>，很多时候还要求 <span class="math inline">\(F\)</span> 是特征为 0 的代数闭域，另外我们大多考虑 <span class="math inline">\(L\)</span> 是 <span class="math inline">\(F\)</span> 上的有限维线性空间。</p></blockquote><p>子，理想，商，同态，表示等一系列的概念和其它代数结构几乎一致。可以划入范畴中。另外单，半单，Radical 等这些概念也于环里面的类似，就不赘述了。</p><h2 id="样板-lie-algebra">样板 Lie Algebra</h2><p>若 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(F\)</span> 上有限维线性空间，<span class="math inline">\(End V\)</span> 表示 <span class="math inline">\(V\)</span> 到 <span class="math inline">\(V\)</span> 的线性变换全体按照元素的复合构成了 <span class="math inline">\(F\)</span> 上的线性空间且 <span class="math inline">\(\dim End V = (\dim V)^2\)</span>。也构成了 <span class="math inline">\(End V\)</span> 是一个结合 <span class="math inline">\(F\)</span>-代数。而任何结合代数都可以诱导一个 Lie 代数： <span class="math inline">\([x,y]=xy - yx\)</span> 。为了强调 Lie 结构，我们用 <span class="math inline">\(\mathbb{gl}(V)\)</span> 代替 <span class="math inline">\(End V\)</span>，称为 general linear algebra。它在 Lie 代数中充当的角色很类似于置换群在群中的角色。我们知道半单 Lie 代数同构于 <span class="math inline">\(\mathbb{gl}(V)\)</span> 的一个子 Lie 代数。</p><h2 id="导子和伴随表示">导子和伴随表示</h2><p>我们称一个 <span class="math inline">\(F-\)</span>代数 <span class="math inline">\(A\)</span>（可以非结合）也可以借助导子(derivation)诱导一个 Lie 代数，称一个导子是指一个线性映射 <span class="math inline">\(\delta: A \to A\)</span> 满足 <span class="math inline">\(\delta(ab)=\delta(a)b+a\delta(b)\)</span>。易知导子 <span class="math inline">\(Der A\)</span> 全体构成了 <span class="math inline">\(End A\)</span> 的一个子空间，由于 <span class="math inline">\([\delta,\delta’] \in Der A\)</span>，因此 <span class="math inline">\(Der A\)</span> 构成了 <span class="math inline">\(\mathbb{gl}(V)\)</span>的一个子 Lie 代数。 由于 Lie 代数 <span class="math inline">\(L\)</span> 也是 <span class="math inline">\(F\)</span>-代数,因此我们也可以定义 <span class="math inline">\(Der L\)</span>。这里的导子本质上就是 Jacobi 恒等式的变形。 定义 <span class="math inline">\(ad_x: L \to L,y \mapsto [x,y]\)</span>，实际上 <span class="math inline">\(ad_x \in Der L\)</span>。<span class="math inline">\(L \to Der L,x \mapsto ad_x\)</span> 称为 <span class="math inline">\(L\)</span> 的伴随表示(adiont representation)。</p><h2 id="可解和幂零">可解和幂零</h2><p>对于给定 Lie 代数 <span class="math inline">\(L\)</span>，我们有理想降链 <span class="math inline">\(L^{(0)} = L,L^{(1)}=[L^{(0)},L^{(0)}],\cdots,L^{(i)}=[L^{(i-1)},L^{(i-1)}],\cdots\)</span>。若存在 <span class="math inline">\(n\)</span> 使得 <span class="math inline">\(L^{(n)} = 0\)</span> 则称 <span class="math inline">\(L\)</span> 可解(slovable)。</p><ol type="1"><li>若<span class="math inline">\(L\)</span> 可解，<span class="math inline">\(L\)</span> 的子代数和同态像可解</li><li><span class="math inline">\(I\)</span> 是 <span class="math inline">\(L\)</span> 的可解理想，若 <span class="math inline">\(L/I\)</span> 可解，则 <span class="math inline">\(L\)</span> 可解。</li><li><span class="math inline">\(I,J\)</span> 是 <span class="math inline">\(J\)</span> 的可解理想，则 <span class="math inline">\(I+J\)</span> 也是。</li></ol><p>由上述性质可知，<span class="math inline">\(L\)</span> 有唯一的极大可解理想。即为 <span class="math inline">\(Rad L\)</span>,若 <span class="math inline">\(Rad L =0\)</span> 则称之为<strong>半单</strong>的，等价于 <span class="math inline">\(L\)</span> 无非零 Abelian 理想(充分性显然，必要性是因为 <span class="math inline">\(Rad L\)</span> 可解，考虑最后一个非 0 项必然是 Abelian 理想矛盾)。另外 我们称 <span class="math inline">\(x \in End V\)</span> 半单，若 <span class="math inline">\(x\)</span> 的极小多项式无重根。</p><p>对于给定 Lie 代数 <span class="math inline">\(L\)</span>，我们有理想降链 <span class="math inline">\(L^0 = L,L^1=[L, L^0],\cdots,L^i=[L, L^{i-1}],\cdots\)</span>。若存在 <span class="math inline">\(n\)</span> 使得 <span class="math inline">\(L^{n} = 0\)</span> 则称 <span class="math inline">\(L\)</span> 幂零(nilpotent)。</p><ol type="1"><li>若<span class="math inline">\(L\)</span> 幂零，<span class="math inline">\(L\)</span> 的子代数和同态像幂零。</li><li>若 <span class="math inline">\(L/Z(L)\)</span> 幂零。则 <span class="math inline">\(L\)</span> 幂零。</li><li>若 <span class="math inline">\(L\)</span> 幂零且非 0，则 <span class="math inline">\(Z(L) \neq 0\)</span>。</li></ol><p>显然由于 <span class="math inline">\(L^{(i)} \subset L^i\)</span> 因此幂零一定可解，但是反之则不尽然，例如 <span class="math inline">\(\mathbb{gl}(V)\)</span> 中对应的上三角矩阵全体构成的 Lie 代数。由 Lie 定理的推论知：</p><blockquote><p><span class="math inline">\(L\)</span> 可解的充要条件是 <span class="math inline">\([L,L]\)</span> 幂零。</p></blockquote><h3 id="ad-nilpotent">ad-nilpotent</h3><p><span class="math inline">\(L\)</span> 是一个 Lie 代数，<span class="math inline">\(x \in L\)</span>, 称 <span class="math inline">\(x\)</span> ad-nilpotent 是指 <span class="math inline">\(ad_x\)</span> 幂零。 易知若 <span class="math inline">\(x\)</span> 幂零，则 <span class="math inline">\(ad_x\)</span> 幂零，但是反之不尽然。然而我们有 <strong>Engel 定理</strong>：</p><h3 id="l-幂零当且仅当-ad-l-幂零"><span class="math inline">\(L\)</span> 幂零当且仅当 <span class="math inline">\(ad L\)</span> 幂零</h3><h2 id="一些重要结果">一些重要结果</h2><p>这里罗列一些定理实际上就是搞清楚 Lie 代数中的一些问题和一些好的性质。</p><p><strong>THM1</strong>. 设 <span class="math inline">\(L\)</span> 是 <span class="math inline">\(\mathbb{gl}(V)\)</span> 的子代数(<span class="math inline">\(L\)</span> 中的元素可理解为矩阵)，<span class="math inline">\(V\)</span> 是有限维的，若 <span class="math inline">\(L\)</span> 中元素都幂零，则存在 <span class="math inline">\(v \in V\)</span> 使得 <span class="math inline">\(L(v) = 0\)</span>. 上面结果是讲，<span class="math inline">\(L\)</span> 中元素都幂零，则 <span class="math inline">\(L\)</span> 有公共的 <span class="math inline">\(0\)</span> 特征向量。证明是很有技巧性的。构造一个 codemension 为 1 的子代数，并证明它是 <span class="math inline">\(L\)</span> 不变子空间。然后数学归纳法完成证明。上面定理还说明我们可以取定一组基使 <span class="math inline">\(L\)</span> 同时严格上三角。</p><p><strong>THM2</strong>. 若 <span class="math inline">\(L\)</span> 幂零，<span class="math inline">\(K\)</span> 是 <span class="math inline">\(L\)</span> 的非零理想,则 <span class="math inline">\(K \cap Z(L) \neq 0\)</span></p><p><strong>THM3</strong>. 设 <span class="math inline">\(L\)</span> 是 <span class="math inline">\(\mathbb{gl}(V)\)</span> 可解子代数，<span class="math inline">\(V\)</span> 是有限维的，则存在 <span class="math inline">\(L\)</span> 存在公共特征向量。</p><p>上面定理还说明我们可以取定一组基使得 <span class="math inline">\(L\)</span> 同时上三角。</p><p><strong>THM4</strong>. 若 <span class="math inline">\(x \in EndV\)</span>，则存在唯一的分解 <span class="math inline">\(x = x_s+x_n\)</span>，其中 <span class="math inline">\(x_s\)</span> 是半单的， <span class="math inline">\(x_n\)</span> 是幂零的，且 <span class="math inline">\(x_s,x_n\)</span> 都能表示成 <span class="math inline">\(x\)</span> 的无常数项的多项式。将其称之为 Jordan-Chevally 分解。</p><p><strong>THM5</strong>. 若 <span class="math inline">\(x\)</span> 半单，则 <span class="math inline">\(ad_x\)</span> 半单。若 <span class="math inline">\(x=x_s+x_n\)</span> 是 Jordan-Chevally 分解，则 <span class="math inline">\(ad_x = ad_{x_s} + ad_{x_n}\)</span> 也是。<span class="math inline">\(Der A\)</span> 包含其元素的 半单部分和幂零部分。</p><p><strong>THM6</strong>. $A B End V $，令 <span class="math inline">\(M = \lbrace x \in \mathbb{gl}(V) \mid [x,B] \subset A\rbrace\)</span>。若 <span class="math inline">\(x \in M\)</span> 满足，<span class="math inline">\(Tr(xy)=0\)</span> 对任意 <span class="math inline">\(y\in M\)</span> 成立，则 <span class="math inline">\(x\)</span> 幂零。</p><p><strong>THM7</strong> <span class="math inline">\(L \subset \mathbb{gl}(V)\)</span>，<span class="math inline">\(V\)</span> 是有限维的, 则 对任意 <span class="math inline">\(x \in [L,L],\;y \in L\)</span> 有 <span class="math inline">\(Tr(xy)=0\)</span> 当且仅当 <span class="math inline">\(L\)</span> 可解。</p><p><strong>THM8</strong> 设 <span class="math inline">\(L\)</span> 是 Lie 代数，对任意 <span class="math inline">\(x \in [L,L],\;y \in L\)</span> 有 <span class="math inline">\(Tr(ad_x ad_y)=0\)</span> 则 <span class="math inline">\(L\)</span> 可解。</p><p><strong>THM9</strong> 若 <span class="math inline">\(L\)</span> 是半单的，则 <span class="math inline">\(L\)</span> 可唯一写成单子理想的直和且 <span class="math inline">\(L=[L,L],Z(L)=0\)</span> 且 <span class="math inline">\(L\)</span> 的理想和同态像都是半单的。</p><p><strong>THM10</strong> <span class="math inline">\(ad L\)</span> 是 <span class="math inline">\(Der L\)</span> 的理想，且若 <span class="math inline">\(L\)</span> 是半单的，则 <span class="math inline">\(ad L = Der L\)</span>。</p><h2 id="to-be-continue">To be continue</h2>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵的 Jordan 分解</title>
    <link href="/jordanDecompositionOfMatrix/"/>
    <url>/jordanDecompositionOfMatrix/</url>
    
    <content type="html"><![CDATA[<p>最近在整理李代数（Lie Algebra） 内容时，里面提到了 Jordan 分解，这里就详细介绍并证明几个相关结果。</p><ol type="1"><li>若矩阵 <span class="math inline">\(A,B\)</span> 可交换，则它们有公共特征向量。</li><li>若矩阵 <span class="math inline">\(A,B\)</span> 可以对角化，则它们可以同时对角化，当且仅当 <span class="math inline">\(A,B\)</span> 交换</li><li>每一个矩阵 <span class="math inline">\(A\)</span> 都可以唯一分解成 <span class="math inline">\(A=B+C\)</span>, 其中 <span class="math inline">\(B\)</span> 可对角化（半单部分），<span class="math inline">\(C\)</span> 幂零。且 <span class="math inline">\(B,C\)</span> 都可以写成 <span class="math inline">\(A\)</span> 的无常数项的多项式。</li></ol><span id="more"></span><p>下面证明这三个结果并给出说明其意义。</p><h2 id="若矩阵-ab-可交换则它们有公共特征向量">若矩阵 <span class="math inline">\(A,B\)</span> 可交换，则它们有公共特征向量</h2><p><strong>证明</strong>：我们设 <span class="math inline">\(V\)</span> 为 <span class="math inline">\(n\)</span> 阶列向量全体。设 <span class="math inline">\(\lambda\)</span> 为 <span class="math inline">\(B\)</span> 的一个特征值。设 <span class="math display">\[W = \lbrace x \in V \mid Bx = \lambda x \rbrace\]</span> 则对任意 <span class="math inline">\(x \in W\)</span>, <span class="math display">\[B(Ax) = A(Bx)=A(\lambda x)=\lambda(Ax)\]</span> 即 <span class="math inline">\(Ax \in W\)</span>。即 <span class="math inline">\(W\)</span> 是 <span class="math inline">\(A\)</span> 的不变子空间，因此，<span class="math inline">\(A\)</span> 在 <span class="math inline">\(W\)</span> 中有特征值 <span class="math inline">\(\mu\)</span> 对应的特征向量 <span class="math inline">\(v\)</span> 即为所求。</p><h2 id="若矩阵-ab-可以对角化则它们可以同时对角化当且仅当-ab-交换">若矩阵 <span class="math inline">\(A,B\)</span> 可以对角化，则它们可以同时对角化，当且仅当 <span class="math inline">\(A,B\)</span> 交换</h2><p><strong>证明</strong>：<span class="math inline">\(\rightarrow\)</span> 是显然的。现证 <span class="math inline">\(\leftarrow\)</span> 若 <span class="math inline">\(A,B\)</span> 交换。 由条件知，存在可逆矩阵 <span class="math inline">\(P\)</span> 使得 <span class="math inline">\(P^{-1}AP = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})\)</span>。由 <span class="math inline">\(A,B\)</span> 交换知，<span class="math inline">\(P^{-1}AP P^{-1}BP = P^{-1}BP P^{-1}AP\)</span>。因此 <span class="math display">\[P^{-1}BP = \left(\begin{matrix}B_1 \\  &amp; B_2 \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; B_s\end{matrix}\right)\]</span> 因为 <span class="math inline">\(B\)</span> 可对角化，因此 <span class="math inline">\(B\)</span> 的最小多项式无重根。所以 <span class="math inline">\(B_i\)</span> 的最小多项式也无重根。因此 <span class="math inline">\(B_i\)</span> 可对角化，存在可逆矩阵 <span class="math inline">\(Q_i\)</span> 使得 <span class="math inline">\(Q_i^{-1}B_iQ_i\)</span> 为对角阵。令 <span class="math inline">\(Q = diag(Q_1,\cdots,Q_s)\)</span>，<span class="math inline">\(T=PQ\)</span>，则 <span class="math inline">\(T^{-1}BT\)</span> 为对角阵。 <span class="math display">\[T^{-1}AT = diag(Q_1^{-1},\cdots,Q_s^{-1})diag(a_1 E_{n_1},\cdots,a_s E_{n_s}) diag(Q_1,\cdots,Q_s) = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})\]</span></p><h2 id="jodan-分解">Jodan 分解</h2><p>每一个矩阵 <span class="math inline">\(A\)</span> 都可以唯一分解成 <span class="math inline">\(A=B+C\)</span>, 其中 <span class="math inline">\(B\)</span> 可对角化，<span class="math inline">\(C\)</span> 幂零。且 <span class="math inline">\(B,C\)</span> 都可以写成 <span class="math inline">\(A\)</span> 的无常数项的多项式。</p><p>证明：首先对任意矩阵，我们有 Jordan 标准型：对任意矩阵 <span class="math inline">\(A\)</span>，存在可逆矩阵 <span class="math inline">\(P\)</span> 使得 <span class="math display">\[P^{-1} A P = \left(\begin{matrix} J_1(\lambda_1) \\  &amp; J_2(\lambda_2) \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; J_s(\lambda_s) \end{matrix}\right) = \left(\begin{matrix} \lambda_1 E_{n_1} \\  &amp; \lambda_2 E_{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right) + \left(\begin{matrix} J_1(0) \\  &amp; J_2(0) \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; J_s(0) \end{matrix} \right)\]</span></p><p>由于 <span class="math inline">\(J_i(\lambda_i)\)</span> 的化零多项式为 <span class="math inline">\(f_i(\lambda) = |\lambda I_i - J_i(\lambda_i)|\)</span>。由中国剩余定理知。存在多项式 <span class="math inline">\(f(\lambda)\)</span> 满足 <span class="math inline">\(f(\lambda) = \lambda_i (mod \; f_i),i=1,\cdots,s\)</span> 且 <span class="math inline">\(f(\lambda)= 0 (mod \lambda)\)</span>。此时</p><p><span class="math display">\[P^{-1} f(A) P = \left(\begin{matrix} \lambda_1 E_{n_1} \\  &amp; \lambda_2 E_{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right)\]</span> 令 <span class="math inline">\(B=f(A)，C=A-B\)</span> 即为所求。上面的 <span class="math inline">\(B,C\)</span> 是唯一的，因为，若存在 <span class="math inline">\(B_1,C_1\)</span> 也满足上述条件，则 <span class="math inline">\(A,B,C,B_1,C_1\)</span>彼此交换，<span class="math inline">\(B-B_1 = C_1 - C\)</span> 是幂零的，因此 <span class="math inline">\(B=B_1,C=C_1\)</span>。</p><p>对于 Jordan 分解，我们可以将一个矩阵分为所谓的半单部分和幂零部分，而由第二条结论知道，如果 <span class="math inline">\(A_1,A_2\)</span> 可交换，那么 <span class="math inline">\(A_1+A_2\)</span> 的半单部分即为 <span class="math inline">\(B_1+B_2\)</span>。或者说的更明了一点就是，如果 <span class="math inline">\(A,B\)</span> 可交换，且可以对角化，则 <span class="math inline">\(A+B\)</span> 也可以对角化。</p><blockquote><p>想到写这些完全是因为李代数忘掉 Lie 括号本身就是一个线性空间。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有限整环是域</title>
    <link href="/finiteDomainIsField/"/>
    <url>/finiteDomainIsField/</url>
    
    <content type="html"><![CDATA[<p>有限整环是域，这是一个相当深刻的定理，被称为 Wedderburn's little theorem，介绍如下</p><span id="more"></span><h2 id="有限整环是体">有限整环是体</h2><p>设 <span class="math inline">\(D\)</span> 是有限整环（不要求交换），下证 <span class="math inline">\(D\)</span> 是体。 证明：对任意 <span class="math inline">\(0 \neq a \in D\)</span>，考虑 <span class="math inline">\(a,a^2,a^3,..,a^n,...\)</span> 由于 <span class="math inline">\(D\)</span> 是有限环，因此存在 <span class="math inline">\(n,r &gt; 0\)</span> 使得 <span class="math inline">\(a^{n+r} = a^n\)</span> 即 <span class="math inline">\(a^n(a^r-1)=0\)</span> 由于 <span class="math inline">\(D\)</span> 是整环，<span class="math inline">\(a \neq 0\)</span>，因此 <span class="math inline">\(a^r =1\)</span> ，所以 <span class="math inline">\(a\)</span> 可逆，证毕。</p><h2 id="有限体是域">有限体是域</h2><p>设 <span class="math inline">\(K\)</span> 是有限体。<span class="math inline">\(Z\)</span> 是它的中心，即 <span class="math display">\[Z = \lbrace z \in K \mid \forall x \in K, xz = zx \rbrace\]</span> 则，<span class="math inline">\(Z\)</span> 是域。令 <span class="math inline">\(|Z|=q\)</span>，则 <span class="math inline">\(K\)</span> 是 <span class="math inline">\(q\)</span> 元域上的有限维向量空间，设维数为 <span class="math inline">\(n\)</span>，则 <span class="math inline">\(|K|=q^n\)</span>。我们需要证明 <span class="math inline">\(K=Z\)</span>, 即证明 <span class="math inline">\(n=1\)</span>。 对任意 <span class="math inline">\(a \in K\)</span>，令 <span class="math inline">\(N(a) = \lbrace x \in K \mid ax = xa \rbrace\)</span> ，这显然是 <span class="math inline">\(K\)</span> 的一个子体。并且包含 <span class="math inline">\(Z\)</span>。因此 <span class="math inline">\(N(a)\)</span> 也是 <span class="math inline">\(Z\)</span> 上的有限维向量空间。从而 <span class="math inline">\(N(a)=q^{n(a)},n(a) \geq 1\)</span>。由于 <span class="math inline">\(K^{\star}\)</span> 为 <span class="math inline">\(q^n-1\)</span> 阶乘法群，<span class="math inline">\(N(a)^{\star}\)</span> 为 <span class="math inline">\(K^{\star}\)</span> 的 <span class="math inline">\(q^{n(a)}-1\)</span> 阶子群，因此 <span class="math inline">\(q^{n(a)}-1 \mid q^n-1\)</span>，因此 <span class="math inline">\(n(a) \mid n\)</span>。 将乘法群 <span class="math inline">\(K^{\star}\)</span> 中的元素分成共轭类，从群论的角度，与 <span class="math inline">\(a \in K^{\star}\)</span> 共轭的元素有 <span class="math inline">\([K^{\star} :N(a)^{\star}] = \frac{q^n-1}{q^{n(a)}-1}\)</span>，从而每个共轭类取一次，共轭类集合记作<span class="math inline">\(X\)</span>，我们有 <span class="math display">\[q^n - 1 = q-1 + \sum_{\overline{a} \in X} \frac{q^n-1}{q^{n(a)}-1}\]</span> 我们需要证明的是当 <span class="math inline">\(n&gt;1\)</span> 时上式不成立。为此我们先介绍<strong>分圆多项式</strong>的知识。 <span class="math display">\[P_n(x) = \prod_{1 \leq r \leq n,(r,n)=1} (x-e^{\frac{2 \pi i r}{n}})\]</span></p><p>即 <span class="math inline">\(P_n(x)\)</span> 是以全部 <span class="math inline">\(n\)</span> 次本原单位复根（共 <span class="math inline">\(\phi(n)\)</span> 个）为根的首一多项式。易知 <span class="math display">\[x^n -1 = \prod_{d \mid n} P_d(n)\]</span> 由数论函数的 <a href="../DirichletProduct">Möbius 变换</a>，(取对数或指数来切换乘积和相加)可知 <span class="math display">\[P_n(x) = \prod_{d \mid n} (x^d-1)^{\mu(n/d)}\]</span> 于是 <span class="math inline">\(P_n(x)=f(x)/g(x)\)</span> 其中 <span class="math inline">\(f(x),g(x)\)</span> 都为 <span class="math inline">\(\mathbb{Z}[x]\)</span> 中的首一多项式。另一方面，按照定义，<span class="math inline">\(P_n(x) \in \mathbb{C}[x]\)</span> ，从而在 <span class="math inline">\(\mathbb{C}[x]\)</span> 中 <span class="math inline">\(g(x) \mid f(x)\)</span>。比较系数易知，<span class="math inline">\(P_n(x)\)</span> 为 <span class="math inline">\(\mathbb{Z}[x]\)</span> 中首一多项式。</p><p>因为对任意 <span class="math inline">\(d \mid n,0&lt;d&lt;n,P_n(x)\)</span> 的每个根都是 <span class="math inline">\(x^n-1\)</span> 的根，但不是 <span class="math inline">\(x^d-1\)</span> 的根，从而</p><p><span class="math display">\[P_n(x) \mid \frac{x^n-1}{x^d-1}\]</span> 因此 <span class="math inline">\(P_n(q) \mid q-1\)</span>, 但当 <span class="math inline">\(n&gt;1\)</span> 时， <span class="math display">\[|P_n(q))| &gt; (q-1)^{\phi(n)} \geq q-1\]</span> 矛盾，证毕。</p><blockquote><p>这个定理也可以表述为：一个有限环，如果它不是域，那么它必然存在零因子。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华罗庚恒等式</title>
    <link href="/huaIndentity/"/>
    <url>/huaIndentity/</url>
    
    <content type="html"><![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p><ol type="1"><li><p>若在一个环中 <span class="math inline">\(a,b,1-ab\)</span> 都可逆，则 <span class="math display">\[\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a\]</span></p></li><li><p>若在一个环中 <span class="math display">\[a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}\]</span></p></li></ol><span id="more"></span><p>上面两个恒等式直接验算即知，可是华老当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？</p><p>当然以下也只是我的个人猜测加上 Wikipedia 的一些参考。</p><h2 id="在环中-1-ba-可逆当且仅当-1-ab-可逆">在环中, 1-ba 可逆当且仅当 1-ab 可逆</h2><p><span class="math display">\[(1-ba)^{-1} = 1+ b(1-ab)^{-1}a\]</span></p><p>上面恒等式直接证明是显然的，应用却 666，6 到要吐。 问题在于为什么想到这样奇怪的式子呢？思路怎么来的呢？ 我们知道，当 <span class="math inline">\(0&lt;x&lt;1\)</span> 时， <span class="math display">\[\frac{1}{1-x} = \sum_{n=0}^{\infty} {x^n}\]</span> 因此，形式上我们有</p><p>讲上述不等式应用到矩阵形式即可得到 Sherman–Morrison 恒等式</p><h2 id="在环中若-abab-1-可逆则">在环中，若 <span class="math inline">\(a,b,ab-1\)</span> 可逆，则</h2><p>由上面恒等式我们知道 <span class="math display">\[(ab-1)^{-1} = a(ba-1)^{-1}b - 1\]</span> 因此 <span class="math display">\[\begin{aligned} (a-b^{-1})^{-1} &amp;= \left((ab-1)b^{-1} \right)^{-1} \\&amp;= b\left( a(ba-1)^{-1}b - 1 \right) \\&amp;= ba(ba-1)^{-1}b - b  \\&amp;= (ba-1)^{-1}b\end{aligned}\]</span></p><p>注意到</p><p><span class="math display">\[\begin{aligned}  (ba-1)^{-1}b - a^{-1} &amp;= (ba-1)^{-1}baa^{-1} - a^{-1} \\&amp;= (ba-1)^{-1}a^{-1} \\&amp;= (aba-a)^{-1}\end{aligned}\]</span> 因此，华罗庚等式 1： $ ( (a-b<sup>{-1})</sup>{-1} - a^{-1} )^{-1} = aba - a$ 得证。</p><h2 id="一个重要恒等式">一个重要恒等式</h2><p><span class="math display">\[b^{-1} - a^{-1} = ( b+b(a-b)^{-1}b )^{-1}\]</span></p><p>上面恒等式与逆算子连续性有关系。 证明： <span class="math display">\[\begin{aligned}  (b^{-1} - a^{-1})^{-1} &amp;= (1-ba^{-1})^{-1}b \\&amp;=(1+b(1-a^{-1}b)^{-1}a^{-1})b \\&amp;= b+b(a-b)^{-1}b\end{aligned}\]</span></p><h2 id="华罗庚恒等式-2-证明">华罗庚恒等式 2 证明</h2><p><span class="math display">\[\begin{aligned}a \left( a^{-1}b^{-1}a - (a-1)^{-1} b^{-1}(a-1) \right) &amp;=(b^{-1}a- a(a-1)^{-1} b^{-1} (a-1) \\&amp;= ( 1-a(a-1)^{-1} )b^{-1}a + (a-1+1) (a-1)b^{-1} )^{-1} \\&amp;= -(a-1)^{-1}b^{-1}a + b^{-1} + (a-1)b^{-1} \\&amp;= b^{-1} - (a-1)^{-1} b^{-1}(a-1)\end{aligned}\]</span></p><h2 id="华罗庚恒等式的意义">华罗庚恒等式的意义</h2><ol type="1"><li>华罗庚第一个恒等式可以用来证明一个 Hua's Theorem：除环间中保持加法和幺元以及逆元的映射必然是除环间的同态或者反同态。</li><li>华罗庚第二个恒等式可以证明 Cartan-Brauer-Hua Theorem 即一个除环的真子除环的单位群如果是原除环的单位群的正规子群，则该子除环一定包含于除环的中心。</li></ol><h2 id="最后用一句广为流传的话结尾">最后用一句广为流传的话结尾</h2><blockquote><p>龙生龙，凤生凤，华罗庚的学生会打洞（矩阵打洞）</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fermat 平方和定理</title>
    <link href="/fermatSqureSumTheorem/"/>
    <url>/fermatSqureSumTheorem/</url>
    
    <content type="html"><![CDATA[<p>Fermat 平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被 4 除余 1（必要性显然）。这个结论首次由 Euler 在 1747 年给出证明。详细叙述如下：</p><span id="more"></span><p>为方便起见,记 <span class="math display">\[A = \lbrace a^2 + b^2 \mid a,b \in \mathbb{Z} \rbrace\]</span> 证明分五步完成</p><ol type="1"><li><p>$(a<sup>2+b</sup>2)(c<sup>2+d</sup>2)=(ac bd)^2 +(ad bc)^2 $ proof: 计算即知。</p></li><li><p>若 <span class="math inline">\(a^2+b^2 \mid c^2+d^2\)</span>, <span class="math inline">\(a^2+b^2\)</span> 为素数，则 <span class="math display">\[\frac{c^2+d^2}{a^2+b^2} \in A\]</span> <strong>proof</strong>: 由于 <span class="math inline">\((ac-bd)(ac+bd) = (a^2+b^2)c^2-(c^2+d^2)b^2\)</span> 因此 <span class="math inline">\((a^2+b^2) \mid (ac-bd)(ac+bd)\)</span> 而 <span class="math inline">\((a^2+b^2)\)</span> 是素数，因此必然整除其中一个。假设 <span class="math inline">\((a^2+b^2)|(ac-bd)\)</span>，则由 1 知 <span class="math inline">\((a^2+b^2)｜(ad+bc)\)</span> 因此 <span class="math display">\[\frac{c^2+d^2}{a^2+b^2}=(\frac{ac - bd}{a^2+b^2})^2 +(\frac{ad + bc}{a^2+b^2})^2\]</span> ​类似的，假设 <span class="math inline">\((a^2+b^2) \mid (ac＋bd)\)</span> 则有 <span class="math display">\[\frac{c^2+d^2}{a^2+b^2}=(\frac{ac + bd}{a^2+b^2})^2 +(\frac{ad - bc}{a^2+b^2})^2\]</span></p></li><li><p><span class="math inline">\(x \mid a^2+b^2,x \notin A\)</span>，则 <span class="math inline">\(\exists y| \frac{a^2+b^2}{x}\)</span> 使得 <span class="math inline">\(y \notin A\)</span></p><p>反证：设 <span class="math inline">\(a^2+b^2 = x p_1 p_2 \cdots p_n\)</span> 则 <span class="math inline">\(\forall y| \frac{a^2+b^2}{x},y \in A\)</span> 则由 2，经过 <span class="math inline">\(n\)</span> 次除法，最终 <span class="math inline">\(x \in A\)</span> 矛盾。</p></li><li><p>若 <span class="math inline">\((a,b)=1\)</span> 则 <span class="math inline">\(\forall x | a^2+b^2 \Rightarrow x \in A\)</span></p><p>假设 <span class="math inline">\(\exists x| a^2+b^2,x \notin A\)</span> 则，我们设 <span class="math inline">\(a = mx + c,b = mx + d\)</span>,其中 <span class="math inline">\(|c|,|d| \leq \frac{x}{2}\)</span>。则 <span class="math inline">\(a^2+b^2=(mx+c)^2+(mx+d)^2=tx+(c^2+d^2)\)</span>，因此 <span class="math inline">\(x \mid c^2+d^2\)</span>。又 <span class="math inline">\((a,b)=1\)</span> ，因此 <span class="math inline">\(((c,d),x)=1\)</span>。因此不妨设 <span class="math inline">\((c,d)=1\)</span>（否则，两边同除它的平方）则 <span class="math inline">\(\exists z, zx = c^2+d^2 \leq \frac{x^2}{2}\)</span>。即 <span class="math inline">\(z\leq \frac{x}{2}\)</span>。由引理 3 知道 <span class="math inline">\(z\)</span> 有一个因子 <span class="math inline">\(w \notin A\)</span>。即我们由 <span class="math inline">\(x \mid a^2+b^2,x \notin A\)</span> 得到了 <span class="math inline">\(w \mid c^2+d^2, w \notin A ,w \leq \frac{x}{2}\)</span> 这样一直下去必然会在有限步结束，矛盾，即必然有 <span class="math inline">\(x \in A\)</span> 。</p></li><li><p>若素数 <span class="math inline">\(p=4n+1\)</span>，则 <span class="math inline">\(p\in A\)</span>。</p><p>由 Fermat 小定理知 <span class="math inline">\(1,2^{4n},\cdots,(4n)^{4n}\)</span> 除以 <span class="math inline">\(p\)</span> 模 1.因此 <span class="math inline">\(2^{4n}－1,3^{4n}－2^{4n},\cdots,(4n)^{4n}-(4n-1)^{4n}\)</span> 都是 <span class="math inline">\(p\)</span> 的倍数。这些差都有分解 <span class="math display">\[a^{4n} - b^{4n} = (a^{2n}+b^{2n})(a^{2n}-b^{2n})\]</span> 由于上述 <span class="math inline">\(a,b\)</span> 相差为 1，必然互素，因此若 <span class="math inline">\(p|a^{2n}+b^{2n}\)</span> 则由 4 命题得证。否则 <span class="math inline">\(2^{2n}-1,3^{2n}-2^{2n},\cdots,(2n)^{2n}-(2n-1)^{2n}\)</span> 都是 <span class="math inline">\(p\)</span> 的倍数。 因此 1.对上面式子做 <span class="math inline">\(2n\)</span> 阶差得到 <span class="math inline">\((2n)!\)</span> 是 <span class="math inline">\(p\)</span> 的倍数，显然是不可能的。 或者 2.由于上面序列的前 <span class="math inline">\(d\)</span> 项和 <span class="math inline">\(d^{2n}-1\)</span> 是 <span class="math inline">\(p\)</span> 的倍数，因此素数 <span class="math inline">\(p\)</span> 无原根，矛盾与原根存在定理。 &gt; <span class="math inline">\(1^k,2^k, \cdots, k^k, (k+1)^k\)</span> 的 <span class="math inline">\(k\)</span> 阶差为 <span class="math inline">\(k!\)</span></p></li></ol><h2 id="用现代语言fermat-平方和定理也可以表达为">用现代语言，Fermat 平方和定理也可以表达为</h2><blockquote><p>奇素数 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(\mathbb{Z}[i]\)</span> 中不可约元当且仅当 <span class="math inline">\(p \equiv 3 \mod 4\)</span></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自然底数 e 的由来</title>
    <link href="/naturalBase/"/>
    <url>/naturalBase/</url>
    
    <content type="html"><![CDATA[<p>自然底数 <span class="math inline">\(e\)</span> 之所以重要，我想很大程度上是因为，指数函数 <span class="math inline">\(f(x)=e^x\)</span> 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 <span class="math inline">\(e\)</span> 被叫做自然底数。</p><span id="more"></span><p>然而，<span class="math inline">\(e\)</span> 的定义可以由一个常见的重要数列极限来定义。即 <span class="math display">\[e \doteq \lim _{n \to \infty}(1+\frac{1}{n})^n\]</span> 那么为什么右边极限存在呢，我们来仔细分析。 令 <span class="math display">\[a_n = (1+\frac{1}{n})^n ,\; b_n =(1+\frac{1}{n})^{n+1}\]</span> 则，由 <a href="../meanInequation">均值不等式</a> 易知： <span class="math display">\[a_n = (1+\frac{1}{n})^n \cdot 1 \leq [\frac{n(1+\frac{1}{n})+1}{n+1}]^{n+1} =a_{n+1}\]</span> 且 <span class="math display">\[\frac{1}{b_n} = (\frac{n}{n+1})^n \cdot 1 \leq [\frac{(n+1)\frac{n}{n+1}+1}{n+2}]^{n+2} = \frac{1}{b_{n+1}}\]</span> 因此 <span class="math inline">\(2 = a_1 \leq a_n \leq b_n \leq b_1 = 4\)</span>。由于单调有界序列必有极限，不妨把这个极限记作 <span class="math inline">\(e\)</span> 且由上面推理知 <span class="math inline">\(2 &lt; e &lt; 4\)</span>。</p><h2 id="补充说明">补充说明</h2><p><span class="math display">\[f_n = (1+\frac{1}{n})^{n+c},\quad g_n = (1+\frac{1}{n})^{n+d}\]</span></p><p>那么满足<span class="math inline">\(f_n \leq e &lt; g_n\)</span> 的最大的<span class="math inline">\(c=\frac{1}{ln⁡2}−1\)</span>，最小的<span class="math inline">\(d = \frac{1}{2}\)</span>，详细证明</p><figure><img src="0.png" alt="0" /><figcaption aria-hidden="true">0</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>均值不等式的证明</title>
    <link href="/meanInequation/"/>
    <url>/meanInequation/</url>
    
    <content type="html"><![CDATA[<p>初中就学过最简单的均值不等式 <span class="math inline">\(\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0\)</span>。它的证明只需配方就知道了，这里介绍一下一般的均值不等式: <span class="math display">\[\frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }\]</span></p><span id="more"></span><p><strong>Proof</strong>：当 <span class="math inline">\(n=1\)</span> 时结论是平凡的，<span class="math inline">\(n=2\)</span> 时配方即知。<span class="math inline">\(n=2^k\)</span>时不难用数学归纳法知，结论成立，下面主要看 <span class="math inline">\(2^{k-1} &lt;n&lt; 2^k\)</span>的情况： 令 $A =  $ 则，应用 <span class="math inline">\(2^k\)</span> 时的结论 <span class="math display">\[\frac{ \sum_{i=1} ^n a_i + (2^k-n)A }{2^k} \geq\sqrt[2^k]{\Pi_{i=1}^n a_i A^{2^k -n}}\]</span> 化简可得到结论。</p><blockquote><p>上述证明简单优美，第一次在陈纪修《数学分析》上册看到这个优美的方法。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装逼题目</title>
    <link href="/zhuangbility/"/>
    <url>/zhuangbility/</url>
    
    <content type="html"><![CDATA[<p>数学老师想好了两个自然数 <span class="math inline">\(m,n\)</span> 满足 <span class="math inline">\(2 \leq m \leq n \leq 100\)</span> ,他把 <span class="math inline">\(m,n\)</span> 的和 <span class="math inline">\(s\)</span> 告诉了 <span class="math inline">\(S\)</span> 同学，把 <span class="math inline">\(m,n\)</span> 的积 <span class="math inline">\(p\)</span> 告诉了 <span class="math inline">\(P\)</span> 同学，他们都是聪明诚实的学生。进行了下面对话</p><ul><li><span class="math inline">\(S\)</span>: 我不知道 <span class="math inline">\(m,n\)</span> 的值，但我知道你也不知道。</li><li><span class="math inline">\(P\)</span>: 现在我知道了。</li><li><span class="math inline">\(S\)</span>: 现在我也知道了。</li></ul><p>请问 <span class="math inline">\(m,n\)</span> 的值。</p><span id="more"></span><ol type="1"><li><p>由第一句话，我们知道 <span class="math inline">\(s \geq 6\)</span>,且 <span class="math inline">\(p\)</span> 中无大于或者等于 53 的质因数。但是 <span class="math inline">\(S\)</span> 是如何知道的呢，可见 <span class="math inline">\(s \leq 54\)</span>。对 数 <span class="math inline">\(6 \to 54\)</span> 逐一检查发现，除了<span class="math inline">\(A = \lbrace 11,17,23,27,29,35,37,41,47,51,53 \rbrace\)</span>的其他元素外，其余每个数都可以表示成两个素数的和，因此从第一句话知道，$ s A$。</p></li><li><p>刚刚推理 <span class="math inline">\(P\)</span> 同学当然也能完成。由于 <span class="math inline">\(A\)</span> 中的元素全是奇数，因此，若 <span class="math inline">\(p = 2^k \cdot (2v+1), k \geq 0, v \geq 0\)</span> 或者 <span class="math inline">\(p = 2^k \cdot (2v+1)(2j+1), k \geq 0, v \geq 0, j \geq 0\)</span> 则 <span class="math inline">\(P\)</span> 同学就能确定的知道答案。</p></li><li><p><span class="math inline">\(S\)</span> 同学最后也知道了 <span class="math inline">\(m,n\)</span> 的值，说明在 <span class="math inline">\(s\)</span> 所有分解 <span class="math inline">\(s = m+ n, 2 \leq m \leq n \leq 100\)</span> 中，且有一种满足 <span class="math inline">\(xy = 2^k v\)</span>。 检查 <span class="math inline">\(11 = 4+7 = 3+8\)</span>, <span class="math inline">\(23 = 4 + 19 = 7+16\)</span>, <span class="math inline">\(27 = 4+23 = 8+19\)</span>, <span class="math inline">\(35=4+31=16+19\)</span>, <span class="math inline">\(37 = 8+29 = 5+32\)</span>, <span class="math inline">\(47= 4 + 43 = 16+31\)</span>, <span class="math inline">\(51 = 4+47 = 8+43\)</span>。 又因为 <span class="math display">\[  29 = 4 + 25 = 13 +16,\; 41 = 4+37 = 16 + 25,\; 53 = 16 +37 = 21 + 32\]</span> 其中 <span class="math inline">\(4 \times 25 = 100 = 20 \times 5\)</span>, <span class="math inline">\(20+5 =25 \notin A\)</span>, <span class="math inline">\(16 \times 25 = 400 = 80 \times 5\)</span>, <span class="math inline">\(80+5 =85 \notin A\)</span>, <span class="math inline">\(21 \times 32 = 672 = 7 \times 96\)</span> ,$ 7+96 =103 A$。 因此，只可能 <span class="math inline">\(s=17\)</span> <span class="math display">\[17 = 2+15 = 3+14 = 4+13 = 5+12 = 6+11 = 7 +10 = 8+9\]</span> 其中只有 <span class="math inline">\(17 =4 + 13\)</span> 满足 <span class="math inline">\(P\)</span> 的断言，因此 <span class="math inline">\(m = 4,n=13\)</span>。</p></li></ol><blockquote><p>此题是我高三（2011 年）在《奥赛金牌之路》中所见，实在很吊，一直铭记于心,特此记录。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数集上的一种特殊拓扑</title>
    <link href="/specialTopologyOnNaturalNumber/"/>
    <url>/specialTopologyOnNaturalNumber/</url>
    
    <content type="html"><![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。</p><span id="more"></span><h2 id="特殊拓扑的定义">特殊拓扑的定义</h2><p>对 <span class="math inline">\(a,b \in \mathbb{Z},b&gt;0\)</span>，令 <span class="math display">\[N_{a,b} = \lbrace a + nb \colon n \in \mathbb{Z} \rbrace\]</span> 我们称集合 <span class="math inline">\(O \subset \mathbb{Z}\)</span> 是开集，若 <span class="math inline">\(O = \emptyset\)</span>，或者 <span class="math inline">\(\forall a \in O,\exists b&gt;0,st. N_{a,b} \subset O\)</span>,容易验证这样定义的开集族全体构成了 <span class="math inline">\(\mathbb{Z}\)</span> 上的拓扑。</p><h3 id="上述拓扑的性质">上述拓扑的性质</h3><p>每个 <span class="math inline">\(N_{a,b}\)</span> 都是既开又闭的。这是由于 <span class="math display">\[N_{a,b} = \mathbb{Z} \setminus \cup_{i=1}^{b-1} N_{a+i,b}\]</span> 又由</p><p><span class="math display">\[\mathbb{Z} \setminus \lbrace -1,1 \rbrace = \cup_{p \in P} N_{0,p}\]</span></p><p>其中 <span class="math inline">\(P\)</span> 是素数集。</p><h3 id="上述拓扑的应用">上述拓扑的应用</h3><p>若素数只有有限个，即 <span class="math inline">\(P\)</span> 是有限集，则 <span class="math inline">\(\lbrace -1,1 \rbrace\)</span> 是开集，矛盾。</p><p>上述方法脑洞大，形式简洁，不愧是 <a href="0.pdf">《Proofs from THE BOOK》</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相对公平的席位分配</title>
    <link href="/fairAssignment/"/>
    <url>/fairAssignment/</url>
    
    <content type="html"><![CDATA[<p>“公平”的席位分配首先本来就是不可能的，公平一般是无法达到的，我们只是尽量降低不公平度，那么我们怎么衡量不公平度呢。就像评价一个人，有不同的指标，不公平度也是一样，这里介绍一种相对合理易于接受，且好判断的方法。</p><span id="more"></span><h2 id="问题表述">问题表述</h2><p>某学校三个系部学生共 200 名,(甲系 100,乙系 60,丙系 40)代表会议共 20 席,按比例分配三个系分别为 10、6、4 席。但是情况变为下列情况怎样分配才是最公平的,现因学生转系三系人数为 103、63、34 。</p><ol type="1"><li>问 20 席该如何分配 ?</li><li>若增加 21 席又如何分配 ?</li></ol><p>显然，因为无法整除无论如何分配都不公平。下面说一下几种策略。</p><p><strong>策略一</strong>： 按班级人数比例乘以总人数，小数点大的分得多余的一个位子。</p><table><thead><tr class="header"><th style="text-align: center;">某校</th><th style="text-align: right;">甲系</th><th style="text-align: right;">乙系</th><th style="text-align: right;">丙系</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">共 200 人</td><td style="text-align: right;">103</td><td style="text-align: right;">63</td><td style="text-align: right;">34</td></tr><tr class="even"><td style="text-align: center;">人数比例</td><td style="text-align: right;">51.3</td><td style="text-align: right;">31.5</td><td style="text-align: right;">17</td></tr><tr class="odd"><td style="text-align: center;">20 席位</td><td style="text-align: right;">10.3</td><td style="text-align: right;">6.3</td><td style="text-align: right;">3.4</td></tr><tr class="even"><td style="text-align: center;">实际分配</td><td style="text-align: right;">10</td><td style="text-align: right;">6</td><td style="text-align: right;">4</td></tr><tr class="odd"><td style="text-align: center;">21 席位</td><td style="text-align: right;">10.82</td><td style="text-align: right;">6.62</td><td style="text-align: right;">3.57</td></tr><tr class="even"><td style="text-align: center;">实际分配</td><td style="text-align: right;">11</td><td style="text-align: right;">7</td><td style="text-align: right;">3</td></tr></tbody></table><p>按照上述策略，会出现席位增多而 <strong>丙系的席位却减少了一个的不合理现象</strong>，说明此方法并不合理。</p><h2 id="模型建立">模型建立</h2><p>假设只有 A、B 两个单位分配席位的情况，设两方人数 <span class="math inline">\(m_1,m_2\)</span> ,分配到的席位为 <span class="math inline">\(n_1,n_2\)</span>。</p><ol type="1"><li><p><span class="math inline">\(\frac{n_1}{m_1} = \frac{n_2}{m_2}\)</span> 公平，但是一般是不满足的。</p></li><li><p><span class="math inline">\(\frac{n_1}{m_1} &gt; \frac{n_2}{m_2}\)</span> 对 A 不公平。</p></li><li><p><span class="math inline">\(\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}\)</span> 对 B 不公平。</p></li></ol><p>绝对不公平度 <span class="math display">\[d = \left| \frac{n_1}{m_1} - \frac{n_2}{m_2} \right|\]</span> 但这样做还是有不足，例如 某两个单位的人数和席位为 <span class="math inline">\(n_1=n_2=10,m_1=120,m_2=100\)</span> 算得 <span class="math inline">\(d=2\)</span>. 另两个单位的人数和席位为 <span class="math inline">\(n_1=n_2=10,m_1=1020,m_2=1000\)</span> 算得 <span class="math inline">\(d=2\)</span>。 但是显然，第二种情况更公平，但是（绝对）不公平度却是一样的不合理</p><p>相对不公平度</p><ol type="1"><li><p>若 <span class="math inline">\(\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}\)</span> 则 <span class="math display">\[r_A(n_1,n_2) = \frac{ \frac{n_2}{m_2} - \frac{n_1}{m_1} }{ \frac{n_2}{m_2} } = 1 - \frac{n_1 m_2}{m_1 n_2}\]</span></p></li><li><p>若 <span class="math inline">\(\frac{n_1}{m_1} &gt; \frac{n_2}{m_2}\)</span> 则 <span class="math display">\[r_B(n_1,n_2)  = \frac{ \frac{n_1}{m_1} - \frac{n_2}{m_2} }{ \frac{n_1}{m_1} } = 1 - \frac{n_2 m_1}{m_2n_1}\]</span> 我们的目标是让<span class="math inline">\(r_A,r_B\)</span>(每种分配只会有一个)最小。</p></li></ol><h3 id="策略二"><strong>策略二</strong></h3><p>假设当前 <span class="math inline">\(\frac{n_1}{m_1} &lt; \frac{n_2}{m_2}\)</span> 对 A 不公平。新增了一个席位。</p><ol type="1"><li>若 <span class="math inline">\(\frac{n_1 + 1}{m_1} \leq \frac{n_2}{m_2}\)</span> 则 A 加 1 席</li><li>否则此时<ul><li>若分配给 A，则对 B 的不公平值(相对): <span class="math display">\[r_B(n_1+1,n_2) = 1 - \frac{n_2 m_1}{m_2 (n_1 + 1)}\]</span></li><li>若分配给 B，则对 A 的不公平值(相对): <span class="math display">\[r_A(n_1,n_2+1) = 1 - \frac{n_1 m_2}{m_1(n_2 + 1)}\]</span></li></ul></li></ol><p>我们定义 <span class="math inline">\(Q_i = \frac{m_i ^2}{n_i(n_i+1)}\)</span>，那么分配给 B 等价于 <span class="math inline">\(r_A(n_1,n_2+1)&lt;r_B(n_1+1,n_2)\)</span> 等价于<span class="math inline">\(Q_1 &lt; Q_2\)</span>。即我们应该将席位分配给 <span class="math inline">\(Q\)</span> 值较大者。</p><blockquote><p>讲 <span class="math inline">\(Q_i\)</span> 定义成 <span class="math inline">\(Q_i = \frac{n_i(n_i+1)}{m_i ^2}\)</span> ，然后找最小的比较合理，不过这样会有小数点太长，所以没这么做</p></blockquote><h3 id="模型求解">模型求解</h3><p>先按照平均原则取整之后。分出了 19 席：<span class="math inline">\(n_1=10,n_2=6,n_3=3\)</span>，第 20 席： <span class="math display">\[Q_1 = \frac{103^2}{10 \times 11 } \approx 96.4 \; , \;Q_2 = \frac{63^2}{6 \times 7} \approx 94.5 \; , \;Q_3 = \frac{34^2}{3 \times 4} \approx 96.3\]</span> 则分配：<span class="math inline">\(n_1=11,n_2=6,n_3=3\)</span> 第 21 席：<span class="math inline">\(Q_1=80.4, Q_2 = 94.5, Q_3 = 96.3\)</span> 则分配：<span class="math inline">\(n_1=11,n_2=6,n_3=4\)</span>.</p><blockquote><p>相对不公平度有很多变种，从而 <strong>策略二有很多变种</strong>（最后计算发现都一样）</p><p>莫非策略二就是天选之子 0.0</p></blockquote><h2 id="本文参考文库-1和文库-2修改了其中的错误">本文参考<a href="http://wenku.baidu.com/view/396d4f6aaf1ffc4ffe47ac52.html?re=view">文库 1</a>和<a href="http://wenku.baidu.com/view/312ef3274b35eefdc9d33304.html?re=view">文库 2</a>，修改了其中的错误</h2><blockquote><p>其实作为分配者，如果你倾向 X，那你就选择让 X 收益最多的策略，反正 <strong>策略一</strong> 看上去也挺合理的，实在不行的话，再强行找花头...</p></blockquote><p>由于席位分配问题确实是一个经典问题，故在此记录。</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二次剩余和 Gauss 互反律</title>
    <link href="/quadraticResidueAndGaussReciprocity/"/>
    <url>/quadraticResidueAndGaussReciprocity/</url>
    
    <content type="html"><![CDATA[<p>从二次剩余问题，引入 Legendre 符号，由此一步步导出 Gauss 互反律，最后延伸到 Jacobi 符号，整个步骤确实连贯优美，脍炙人口。</p><span id="more"></span><p>寒假回家好好调整了一下状态，回学校后感觉还不错，效率也蛮高。发现理图虽然比较破，但是还是很不错的，哈哈哈。每次读潘承洞先生的《数论基础》都觉得受益匪浅，我把自己很喜欢的部分写入到该文中。</p><h2 id="二次剩余">二次剩余</h2><p>考虑如下形式二次同余式 <span class="math display">\[x^2 \equiv  a \; \mod \; p\]</span> 其中 <span class="math inline">\(p\)</span> 是奇素数，<span class="math inline">\(a\)</span> 是非负整数。若上述方程有解，则称 <span class="math inline">\(a\)</span> 是 <span class="math inline">\(p\)</span> 的二次剩余，记作 <span class="math inline">\(a\; R \; p\)</span>，否则称 <span class="math inline">\(a\)</span> 是 <span class="math inline">\(p\)</span> 的二次非剩余，记作 <span class="math inline">\(a \; \overline{R}\; p\)</span> 。<span class="math inline">\(p=2\)</span> 时就没啥意思了，所以 <strong>仅考虑奇素数。</strong></p><p>经过简单推理很容易发现，在模 <span class="math inline">\(p\)</span> 的简化系中，二次剩余与二次非剩余各占一半。且容易知道，<span class="math inline">\(1^2,2^2,\cdots,(\frac{p-1}{2})^2\)</span> 都是 <span class="math inline">\(p\)</span> 二次剩余。</p><h2 id="legendre-符号">Legendre 符号</h2><p><span class="math display">\[\left( \frac{a}{p} \right) = \left\{ \begin{array}{cc} 1, &amp; a\; R\; p \\0, &amp; p \mid a \\-1, &amp; a\; \overline{R}\; p. \end{array} \right.\]</span></p><h3 id="定理-1---p-1-a-p">定理 1: $ -() (p-1)! a^{} p $</h3><p><strong>Proof</strong>: 对于 <span class="math inline">\(p \mid a\)</span> 的情形，结论显然。下面考虑 <span class="math inline">\((p,a)=1\)</span> 的情形，令 <span class="math display">\[ S = \lbrace 1,2,\cdots,p-1 \rbrace\]</span> 对任意的 $ x S $ 必存在唯一的 $ y S $ 为下面同余式的解</p><p><span class="math display">\[yx \equiv a \; \mod p\]</span></p><p>当 $ () = -1 $ 时，同余式 $ x^2 = a ; p$ 无解，所以 $y x $ .因此集合 <span class="math inline">\(S\)</span> 中的元素可以分成 $ $ 对，我们就有 <span class="math display">\[(p-1)! \equiv a^{\frac{p-1}{2}} \;\mod p\]</span></p><p>当 $ () = 1 $ 时，同余式 $ x^2 = a ; p $有两个解 <span class="math inline">\(x_0\)</span> 和 <span class="math inline">\(p - x_0\)</span>.在<span class="math inline">\(S\)</span>中去掉这两个数外剩下<span class="math inline">\(p-3\)</span>个数分出 <span class="math inline">\(\frac{p-3}{2}\)</span>对，则有 <span class="math display">\[(p-1)! \equiv a^{\frac{p-3}{2}}x_0(p-x_0) \equiv - a^{\frac{p-1}{2}} \; \mod p\]</span></p><p>证毕。</p><h2 id="推论-2-wilson-定理">推论 2 (Wilson 定理)</h2><p><span class="math display">\[(p-1)! \equiv -1 \;\mod p\]</span></p><p><strong>Proof</strong>: <strong>定理 1</strong> 中取 <span class="math inline">\(a=1\)</span> 即可。</p><h2 id="推论-3euler-判别法">推论 3(Euler 判别法)</h2><p><span class="math display">\[\left( \frac{a}{p} \right ) \equiv a^{\frac{p-1}{2}} \; \mod \;p\]</span></p><p><strong>Proof</strong>: 由 <strong>定理 1</strong> 和 <strong>推论 2</strong> 显然。Euler 判别法不仅有理论价值(下面都是推论 3 的直接推论)，由于快速幂的存在，使得 Euler 判别法在计算时有相当好的效果。</p><h2 id="推论-4format-小定理-设-ap1-则">推论 4(Format 小定理) 设 <span class="math inline">\((a,p)=1\)</span> ,则</h2><p><span class="math display">\[a^{p-1} \equiv 1 \;\mod p\]</span></p><h2 id="推论-5frac-1p--1fracp-12">推论 5：<span class="math inline">\((\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}\)</span></h2><h2 id="推论-6">推论 6：$() =()() $</h2><blockquote><p>推论 6 说明，我们求 Legendre 符号，只需求 $ (),() $ 即可</p></blockquote><h2 id="定理-7frac2p--1fracp2-18">定理 7：<span class="math inline">\((\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}\)</span></h2><p><strong>Proof</strong>: <span class="math display">\[2^{\frac{p-1}{2}}(\frac{p-1}{2})! = 2 \cdot 4 \cdots (p-1) \equiv (\frac{p-1}{2})!(-1)^{1+2+\cdots+\frac{p-1}{2}}\;\mod p\]</span></p><p>其中最后一个等价是因为：</p><p><span class="math display">\[\begin{aligned}p-1 \equiv (-1)^1 \mod p \\2 \equiv (-1)^2 \mod p \\p-3 \equiv (-1)^3 \mod p \\\cdots(\frac{2}{p}) \equiv 2^{\frac{p-1}{2}} \equiv (-1)^{\frac{p^2-1}{8}} \;\mod p\end{aligned}\]</span></p><p>证毕。</p><h2 id="定理-8gauss-二次互反律-设-pq-为不同的奇素数则有">定理 8：(Gauss 二次互反律) 设 <span class="math inline">\(p,q\)</span> 为不同的奇素数，则有</h2><p><span class="math display">\[(\frac{p}{q}) (\frac{q}{p}) = (-1)^{\frac{(p-1)(q-1)}{4}}\]</span></p><blockquote><p>证明太长了，下次一定吧 0.0</p></blockquote><h2 id="jacobi-符号">Jacobi 符号</h2><blockquote><p>Jacobi 符号的引入只是为了让计算更加简洁！</p></blockquote><p>我们在计算用 Gauss 二次互反律求 <span class="math inline">\((\frac{a}{q})\)</span> 时，由于 <span class="math inline">\(a\)</span> 要因式分解成很多项，所以直接用不是很方便。因此我们引入 Jacobi 符号:</p><p>设 <span class="math inline">\(Q = q_1 \cdots q_s\)</span> 是正奇数，其中 <span class="math inline">\(q_1 \leq \cdots \leq q_s\)</span> 是奇素数（手算时候可以保证严格小于），我们定义： <span class="math display">\[(\frac{a}{Q}) = (\frac{a}{q_1}) \cdots (\frac{1}{q_s})\]</span></p><ul><li><span class="math inline">\(Q\)</span> 为奇素数时，Jacobi 符号就是 Legendre 符号</li><li><span class="math inline">\((\frac{a}{Q}) = 1\)</span> 并不等价于 <span class="math inline">\(x^2 \equiv a \mod Q\)</span> 有解！</li><li><span class="math inline">\((\frac{a}{Q})\)</span> 是 <span class="math inline">\(a\)</span> 的可乘函数，周期为 <span class="math inline">\(Q\)</span> 的周期函数</li><li>当 <span class="math inline">\((a,Q)&gt;1\)</span> 时，<span class="math inline">\((\frac{a}{Q})=0\)</span></li><li>当 <span class="math inline">\((a,Q)= 1\)</span> 时，<span class="math inline">\((\frac{a^2}{Q})=1\)</span>；特别地，<span class="math inline">\((\frac{1}{Q}) = 1\)</span></li><li><span class="math inline">\((\frac{-1}{Q}) = (-1)^{\frac{Q-1}{2}}\)</span></li><li><span class="math inline">\((\frac{2}{Q}) = (-1)^{\frac{Q^2-1}{8}}\)</span></li><li><span class="math inline">\((\frac{P}{Q}) = (-1)^{\frac{(P-1)(Q-1)}{4}} (\frac{Q}{P})\)</span>，其中 <span class="math inline">\(P,Q\)</span> 都是正奇数。</li><li>写程序计算时可以避免做质因数分解！！！</li></ul><blockquote><p>注意到 Jacobi 符号只是为了简化 Legendre 符号的计算的！</p></blockquote><h2 id="计算例子">计算例子</h2><p>判断二次同余式 <span class="math inline">\(x^2 \equiv 888 \mod 1999\)</span> 是否有解。 <span class="math display">\[\begin{aligned}(\frac{888}{1999}) &amp;= (\frac{4}{1999}) (\frac{2}{1999}) (\frac{111}{1999}) \\&amp;= (-1) ^{\frac{1999^2 -1}{8}}  (\frac{111}{1999}) \\&amp;= (-1)^{\frac{(1999-1)(111-1)}{4}} (\frac{1999}{111}) \\&amp;= -(\frac{1}{111}) = -1\end{aligned}\]</span></p><blockquote><p>如果取模的数不是素数，那么就把它分解素因数，然后每个单独判断即可。</p></blockquote><h2 id="jacobi-符号-python-程序">Jacobi 符号 Python 程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># a是整数，Q是正奇数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Jacobi</span>(<span class="hljs-params">a,Q</span>):</span><br>  <span class="hljs-comment"># print(a,Q)  # 需要看过程就取消本行最前面的注释</span><br>  a%=Q<br>  <span class="hljs-keyword">if</span> math.gcd(a,Q) &gt; <span class="hljs-number">1</span>:  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> a%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>: a//=<span class="hljs-number">4</span><br>  f = <span class="hljs-keyword">lambda</span> n:<span class="hljs-number">1</span>-<span class="hljs-number">2</span>*(n&amp;<span class="hljs-number">1</span>)<br>  ans = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> a%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>: a//=<span class="hljs-number">2</span>;ans = f((Q**<span class="hljs-number">2</span>-<span class="hljs-number">1</span>)//<span class="hljs-number">8</span>)<br>  <span class="hljs-comment"># 此时a也是正奇数了</span><br>  <span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span>:  <span class="hljs-keyword">return</span> ans<br>  <span class="hljs-keyword">return</span> ans*f((a-<span class="hljs-number">1</span>)*(Q-<span class="hljs-number">1</span>)//<span class="hljs-number">4</span>)*Jacobi(Q,a)<br><br><span class="hljs-built_in">print</span>(Jacobi(<span class="hljs-number">888</span>,<span class="hljs-number">1999</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二项式反演公式及其应用</title>
    <link href="/inverseFormulaAndItsMatrixForm/"/>
    <url>/inverseFormulaAndItsMatrixForm/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="../DirichletProduct">上一篇博文</a> 中，介绍过数论中的 Möbius 反演公式，让我想起了另一个经典的反演公式：<strong>二项式反演公式</strong>。本质上反演公式就是矩阵求逆的过程。</p><p>只是它的逆有很简单的形式，因此才有了二项式反演公式，这个公式帮助我们队伍在 2014 年 ACM－ICPC 亚洲区域赛西安站拿银，当时 <a href="2014xian.pdf">F 题</a>答案直接算需要 <span class="math inline">\(O(n^3)\)</span> 复杂度，而利用二项式反演公式后，可以在 <span class="math inline">\(O(n^2)\)</span> 复杂度内完美解决。1A 过题，感觉超爽。</p><blockquote><p>最后简单提一下：Möbius 反演公式及其矩阵形式</p></blockquote><span id="more"></span><h2 id="反演公式与其矩阵形式">反演公式与其矩阵形式</h2><p>由</p><p><span class="math display">\[\sum_{r = 1} ^n a_{n,r} f(r) = g(n)\]</span> 其中 <span class="math inline">\(g(n)\)</span> 已知，解出 <span class="math inline">\(f(n)\)</span></p><p><span class="math display">\[f(n) = \sum_{r = 1} ^n b_{n,r} g(r)\]</span> 为其反演公式，也称上面两式互为反演公式。</p><p>令</p><p><span class="math display">\[A = \left( \begin{matrix} a_{11} &amp; &amp;  \\a_{21} &amp; a_{22} &amp; \\\cdots &amp; \cdots &amp; \ddots &amp; \\a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \\\end{matrix} \right),\qquadB = \left( \begin{matrix} b_{11} &amp; &amp;  \\b_{21} &amp; b_{22} &amp; \\\cdots &amp; \cdots &amp; \ddots &amp; \\b_{n1} &amp; b_{n2} &amp; \cdots &amp; b_{nn} \\\end{matrix} \right)\]</span></p><p>则上述反演公式本质上就是求矩阵 <span class="math inline">\(A\)</span> 的逆 <span class="math inline">\(B\)</span>.</p><h2 id="二项式反演公式">二项式反演公式</h2><p>若</p><p><span class="math display">\[g(n) = \sum_{r = s} ^n {n \choose r} f(r)\]</span> 其中 <span class="math inline">\(s \geq 0\)</span> 则</p><p><span class="math display">\[f(n) = \sum_{r = s} ^n (-1)^{n-r} {n \choose r} g(r)\]</span></p><p><strong>Proof</strong>: 要证明反演公式，只需证明，对应的矩阵 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 互为逆即可. 令 <span class="math inline">\(C = A \star B\)</span> 则</p><p><span class="math display">\[\begin{aligned}c_{ij} = \sum_{k=1} ^n a_{ik} b_{kj} &amp; = \sum_{k =j} ^ i {i \choose k} (-1)^{k-j}{k \choose j} =\sum_{k=0} ^ {i-j} {i \choose k + j} (-1)^k {k + j \choose j} \\&amp; = {i \choose j} \sum_{k=0} ^ {i-j} (-1)^k {i - j \choose k} = \left\{ \begin{array}{ll} 1,&amp; i=j \\  0,&amp; i&gt;j \end{array} \right.\end{aligned}\]</span> 证毕。</p><h2 id="二项式反演写成卷积形式便于-ntt">二项式反演写成卷积形式便于 NTT</h2><p>不妨取 <span class="math inline">\(s = 0\)</span></p><p><span class="math display">\[\frac{g(n)}{n!} = \sum_{i + j = n} \frac{f(i)}{i} \cdot \frac{1}{j!}\]</span> 等价于 <span class="math display">\[\frac{f(n)}{n!} = \sum_{i + j = n} ^n \frac{g(i)}{i!} \cdot \frac{(-1)^{j}}{j!}\]</span></p><blockquote><p>也就是说二项式反演公式本质上是说：<span class="math inline">\(\frac{1}{n!}\)</span> 和 <span class="math inline">\(\frac{(-1)^n}{n!}\)</span> 互为卷积逆。</p></blockquote><h2 id="二项式反演公式的应用">二项式反演公式的应用</h2><p>二项式反演公式在组合数学和数论中都有诸多应用，这里简单的提两个。</p><h3 id="错排问题-在-n-个数字-1-2-dots-n-形成-n-个排列-a_1a_2-dots-a_n-中满足-a_i-neq-i-的排列有多少个">(错排问题) 在 <span class="math inline">\(n\)</span> 个数字 <span class="math inline">\(1, 2, \dots, n\)</span> 形成 <span class="math inline">\(n!\)</span> 个排列 <span class="math inline">\(a_1a_2 \dots a_n\)</span> 中满足 <span class="math inline">\(a_i \neq i\)</span> 的排列有多少个</h3><p>不妨设答案为 <span class="math inline">\(D_n\)</span> ,则可以看出恰好有 <span class="math inline">\(r\)</span> 个 <span class="math inline">\(a_i=i\)</span>的排列数为 <span class="math inline">\(\left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}\)</span>，因此</p><p><span class="math display">\[n! = \sum_{r = 0} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}\]</span></p><p>因此</p><p><span class="math display">\[D_n ＝ \sum_{r = 0} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r! = n! \sum_{r=0} ^n \frac{(-1)^r}{r!}\]</span> &gt; 当然 <span class="math inline">\(D_n\)</span> 还有递推关系式 <span class="math inline">\(D_1=0,D_2 = 1\)</span> &gt; <span class="math display">\[&gt; D_n = (n-1) (D_{n-1} + D_{n-2}),\quad n \geq 2&gt; \]</span></p><h3 id="满射个数-求-m-元集-a-到-n-元集-b-的满身的个数-gmn">(满射个数) 求 <span class="math inline">\(m\)</span> 元集 <span class="math inline">\(A\)</span> 到 <span class="math inline">\(n\)</span> 元集 <span class="math inline">\(B\)</span> 的满身的个数 <span class="math inline">\(g(m,n)\)</span></h3><p>类似于错排的思路，我们有</p><p><span class="math display">\[n^m = \sum_{r = 1} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) g(m,r)\]</span> 于是</p><p><span class="math display">\[g(m,n) =  \sum_{r = 1} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r^m\]</span></p><h2 id="möbius-反演公式及其矩阵形式">Möbius 反演公式及其矩阵形式</h2><p>由 Möbius 反演公式对应的矩阵我们有,若 <span class="math display">\[a_{ij} = \left\{ \begin{array}{cc} 1, &amp; j \mid i \\0, &amp; else. \end{array} \right.\]</span> 则，其逆矩阵为 <span class="math display">\[b_{ij} = \left\{ \begin{array}{cc} \mu (\frac{i}{j}), &amp; j \mid i \\0, &amp; else. \end{array} \right.\]</span></p><blockquote><p>本文参考了<a href="http://www.douban.com/note/480023639/?type=like">豆瓣</a>和<a href="http://wenku.baidu.com/link?url=0m3D-588KfEUvocmKGoW5X4z5SHrEKVOaqfLoTeRtJaJcG6oDEUh2QEbJmNa1p2OTkqFLCqhfhM-RsoOI2fkutlqL9q3xgJhIAic4HumI5W">百度文库</a>以及 许胤龙，孙淑玲《组合数学引论》。</p></blockquote><h2 id="单位根反演">单位根反演</h2><p>DFT 的本质就是单位根反演 <span class="math display">\[\forall k,[n \mid k] = \frac{1}{n} \sum_{i=0}^{n-1} \omega_n^{ik}\]</span> 一个应用的例子 <span class="math display">\[\begin{aligned}\sum_{i=0}^{[\frac{n}{k}]} [x^{ik}] f(x)&amp;= \sum_{i=0}^n [k \mid i] [x^i] f(x)\\&amp;=\sum_{i=0}^n [x^i] f(x) \frac{1}{k} \sum_{j=0}^{k-1} \omega_{k}^{ji}\\&amp;=\frac{1}{k} \sum_{i=0}^n a_i \sum_{j=0}^{k-1} \omega_{k}^{ij}\\&amp;=\frac{1}{k} \sum_{j=0}^{k-1} \sum_{i=0}^n a_i(\omega_k^j)^i\\&amp;=\frac{1}{k} \sum_{j=0}^{k-1} f(\omega_{k}^j)\end{aligned}\]</span></p><blockquote><p>单位根反演转自：<a href="https://www.cnblogs.com/cjyyb/p/10838495.html" class="uri">https://www.cnblogs.com/cjyyb/p/10838495.html</a></p></blockquote><p>具体的例子求：<span class="math inline">\(\sum_{i \in [0,n],k \mid i} \binom{n}{i} G^i\)</span></p><p>计<span class="math inline">\(f(x) = (G+x)^n\)</span>，则由上面公式 <span class="math display">\[\sum_{i \in [0, n], k \mid i} \binom{n}{i} G^i = \frac{1}{k} \sum_{j=0}^{k-1} (G+\omega_{k}^j) ^n\]</span> 即复杂度 <span class="math inline">\(O(k \log n)\)</span>，如果要结果模一个 NTT friendly 的，那就更好了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dirichlet 积</title>
    <link href="/DirichletProduct/"/>
    <url>/DirichletProduct/</url>
    
    <content type="html"><![CDATA[<p>潘承洞先生的《数论基础》(现代数学基础丛书 34) 以现代数学的眼光看数论函数，使得分析问题更加简洁本质，而这些都要归功于 Dirichlet 积的引入。</p><span id="more"></span><h2 id="常见数论函数">常见数论函数</h2><p>为了更好的介绍 Dirichlet 积，先引入一些记号，数论函数是指定义于全体正整数集上的函数。</p><ol type="1"><li><p><span class="math inline">\(u(n) \equiv 1\)</span></p></li><li><p><span class="math inline">\(e(n) = n\)</span></p></li><li><p><span class="math inline">\(I(n) = \left\{\begin{array}{ll} 1, &amp; n=1, \\ 0, &amp; n&gt;1. \end{array} \right.\)</span></p></li><li><p><span class="math inline">\(n\)</span> 的所有正除数的个数 <span class="math inline">\(d(n)\)</span>.</p><p><span class="math display">\[d(n)= \sum_{d|n} 1 = (a_1+1)(a_2+1) \cdots (a_n+1), \; n=p_1^{a_1} \cdots p_s^{a_s}\]</span></p></li><li><p><span class="math inline">\(n\)</span> 的全部素因子的个数（按重数计）<span class="math inline">\(\Omega(n)\)</span></p><p><span class="math display">\[\begin{array}{ll} \Omega(1)=0 &amp; \\\Omega(n) = a_1 + a_2+ \cdots a_n, &amp; n=p_1^{a_1} \cdots p_s^{a_s} \end{array}\]</span></p></li><li><p><span class="math inline">\(n\)</span> 的不同素因子的个数 <span class="math inline">\(\omega(n)\)</span></p><p><span class="math display">\[\begin{array}{ll} \omega(1)=0 &amp; \\\omega(n) = s, &amp; n=p_1^{a_1} \cdots p_s^{a_s} \end{array}\]</span></p></li><li><p><span class="math inline">\(n\)</span> 的正除数的幂和函数 <span class="math inline">\(\sigma_{\lambda}(n) = \sum_{d|n} d^{\lambda}\)</span></p></li><li><p>所有不超过 <span class="math inline">\(n\)</span> 且和 <span class="math inline">\(n\)</span> 互素的正整数的个数 <span class="math inline">\(\psi(n)\)</span> <span class="math display">\[\psi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\(d,n)=1 \end{array} } 1\]</span></p><p><span class="math inline">\(\psi(n)\)</span> 称之为 Euler 函数。</p></li><li><p>Möbius 函数 <span class="math inline">\(\mu(n)\)</span> <span class="math display">\[\mu(n) = \left\{\begin{array}{ll} 1, &amp; n=1, \\ (-1)^s, &amp; n=p_1p_2 \cdots p_s, \; p_1 &lt; p_2&lt; \cdots &lt; p_s. \\0, &amp; else. \end{array} \right.\]</span></p></li><li><p>Mangoldt 函数 <span class="math inline">\(\Lambda(n)\)</span></p><p><span class="math display">\[\Lambda(n) = \left\{\begin{array}{ll} \log p, &amp; n= p^k, k \geq 1\\0, &amp; else. \end{array} \right.\]</span></p></li><li><p>Liouville 函数 <span class="math inline">\(\lambda(n) = (-1)^{\Omega(n)}\)</span></p></li><li><p>Euler 函数的推广(自创) <span class="math inline">\(\psi _{\lambda}(n)\)</span></p><p><span class="math display">\[\psi _{\lambda} (n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\(d,n)=1 \end{array} } d^{\lambda}\]</span></p><p>当 <span class="math inline">\(\lambda = 0\)</span> 时即为 Euler 函数。</p></li></ol><p>用下面的 Dirichlet 积的概念，大家就会对上面常见的数论函数有更深刻的认识。</p><h2 id="dirichlet-积">Dirichlet 积</h2><p>设<span class="math inline">\(f(n)\)</span>,<span class="math inline">\(g(n)\)</span>是两个数论函数，则</p><p><span class="math display">\[h(n) = \sum_{d|n} f(d)g(\frac{n}{d})\]</span></p><p>称为<span class="math inline">\(f(n)\)</span>和<span class="math inline">\(g(n)\)</span>的 Dirichlet 积,记作<span class="math inline">\(h=f \star g\)</span>.</p><h3 id="定理-1-dirichlet-积满足交换律和结合律即">定理 1 Dirichlet 积满足交换律和结合律即</h3><ol type="1"><li>交换律： <span class="math inline">\(f \star g = g \star f\)</span></li><li>结合律： <span class="math inline">\((f\star g) \star h = f \star (g \star h)\)</span></li></ol><h3 id="定理-2-dirichlet-积的幺元存在为-in">定理 2 Dirichlet 积的幺元存在为 <span class="math inline">\(I(n)\)</span></h3><ul><li>由 <strong>定理 1</strong> 和 <strong>定理 2</strong> 知。数论函数全体关于 Dirichlet 积构成了一个含幺交换半群(Commutative Monoid)</li><li>由抽象代数的基本知识知道 Monoid 中的元如果存在逆元必然唯一，证明也是显然的</li><li>现在的问题就是这个 Monoid 那些元有逆元( Dirichlet 逆，以下简称逆)。或者说一个数论函数可逆的充要条件是什么。</li></ul><p>实际上，我们有如下结论</p><h3 id="定理-3-数论函数-f-可逆的充要条件是-f1-neq-0.此时它的逆元为">定理 3 数论函数 <span class="math inline">\(f\)</span> 可逆的充要条件是 <span class="math inline">\(f(1) \neq 0\)</span>.此时它的逆元为</h3><p><span class="math display">\[f^{-1} (1) = \frac{1}{f(1)},\quadf^{-1} (n) = \frac{-1}{f(1)} \sum _{d|n,\, d&lt;n} f(\frac{n}{d})f^{-1}(d),\; n&gt;1\]</span></p><p>证明是显然的，验算即知。</p><blockquote><p>至此从抽象的层次已经对数论函数的 Dirichlet 积有了一个清晰的认识，下面用这套语言考虑我们的常见函数</p></blockquote><h3 id="定理-4-möbius-函数-mun-是-un-的逆即">定理 4 Möbius 函数 <span class="math inline">\(\mu(n)\)</span> 是 <span class="math inline">\(u(n)\)</span> 的逆，即</h3><p><span class="math display">\[\sum_{ d|n } \mu(n) = \left\{ \begin{array}{ll}  1, &amp; n=1, \\0, &amp; n&gt;1. \end{array} \right.\]</span></p><p><strong>Proof</strong> : <span class="math inline">\(n=1\)</span> 时显然，不妨设 <span class="math inline">\(n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s} &gt; 0\)</span> 则由 <span class="math inline">\(\mu(n)\)</span> 的定义</p><p><span class="math display">\[\begin{array}{ll}\sum_{ d|n } \mu(n) &amp; = \mu(1) + \mu(p_1) + \mu(p_2) + \cdots +\mu(p_s) + \cdots + \mu(p_1 p_2) + \cdots \\&amp; \quad + \mu(p_{s-1}p_s) + \cdots \mu(p_1 p_2 \cdots p_s) \\&amp; =  1 + {s \choose 1} (-1) + {s \choose 2} (-1)^2 + \cdots + {s \choose s} (-1)^s \\&amp;= (1-1)^s = 0 \end{array}\]</span></p><blockquote><p>由此可见，原来看上去复杂的不知所以然的 Möbius 函数本质上是恒为 1 的函数的 Dirichlet 逆元。</p></blockquote><h3 id="定义-5-若-ff-star-u-则称-f-是-f-的-möbius-变换即">定义 5 若 <span class="math inline">\(F=f \star u\)</span> 则称 <span class="math inline">\(F\)</span> 是 <span class="math inline">\(f\)</span> 的 Möbius 变换，即</h3><p><span class="math display">\[F(n) = \sum_{d|n} f(d)\]</span></p><p>显然此时我们有 <span class="math inline">\(f=F * \mu\)</span>, 称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(F\)</span> 的 Möbius 反变换。 实际上，这就是我们常说的 Möbius 反演公式。</p><p><span class="math display">\[F(n) = \sum_{d|n} f(d) \Longleftrightarrow f(n) = \sum_{d|n} F(d) \mu(\frac{n}{d})\]</span></p><p>Möbius 变换的例子</p><ol type="1"><li><span class="math inline">\(I(n)\)</span> 是 <span class="math inline">\(\mu(n)\)</span> 的 Möbius 变换</li><li><span class="math inline">\(d(n)\)</span> 是 <span class="math inline">\(u(n)\)</span> 的 Möbius 变换</li><li><span class="math inline">\(e(n)\)</span> 是 <span class="math inline">\(\psi(n)\)</span> 的 Möbius 变换</li><li><span class="math inline">\(\log n\)</span> 是 <span class="math inline">\(\Lambda(n)\)</span> 的 Möbius 变换</li></ol><p>前两个由定义显然，后面两个证明如下。</p><p><span class="math display">\[n = \sum _{i=1} ^n 1 =\sum _{d|n} \sum_{(n,i) = d} 1 =\sum _{d|n} \sum_{(\frac{n}{d},k)=1} 1 =\sum _{d|n} \psi(\frac{n}{d}) = \sum _{d|n} \psi(d)\]</span></p><p>因此</p><p><span class="math display">\[\psi(n) = \sum _{d|n} \mu(d) \frac{n}{d} = n \sum _{d|n} \frac{\mu(d)}{d}\]</span></p><p>另外我们还有一个证明方式</p><p><span class="math display">\[\psi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\(d,n)=1 \end{array} } 1 ＝ \sum_{1 \leq d \leq n} \sum_{l|(d,n)} \mu(l) = \sum _{l|n} \mu(l) \sum _{1 \leq d \leq n , l|d} 1 = \sum _{l|n} \mu(l) \frac{n}{l}\]</span></p><blockquote><p>上述两种证明都是两种常用处理数论函数的技术手段。</p></blockquote><p>至于 <span class="math inline">\(\log n\)</span> 是 <span class="math inline">\(\Lambda(n)\)</span> 的 Möbius 变换的证明只需验算即知。</p><p>用上面所说的技术，我们来考虑一下推广的 Euler 函数 <span class="math inline">\(\psi _{\lambda}\)</span></p><p><span class="math display">\[\sum _{i=1} ^n i^{\lambda} =\sum _{d|n} \sum_{(n,i) = d} i^{\lambda}  =\sum _{d|n} d^{\lambda} \sum_{(\frac{n}{d},k)=1} k^{\lambda}  =\sum _{d|n} d^{\lambda} \psi _{\lambda} (\frac{n}{d}) =n^{\lambda} * \psi _{\lambda}\]</span></p><h3 id="可乘函数">可乘函数</h3><p>寻找不变量一直是数学关心的问题，变化中的不变量，可以大大简化运算，并且反过来刻画了变化。具体说，寻找 Dirichlet 积不变量一方面对于那些不变量，可以简化它们操作，另一方面，由于 Dirichlet 积保持这些性质也就刻画了 Dirichlet 本身。其中这样的一个不变量就是可乘函数。</p><p>设 <span class="math inline">\(f(n)\)</span> 是定义在全体自然数上不恒为 0 的数论函数，若它满足条件</p><p><span class="math display">\[f(mn) = f(m) f(n), \quad (m,n)=1\]</span></p><p>则称之为可乘函数。若对任意正整数 <span class="math inline">\(m,n\)</span> 恒有</p><p><span class="math display">\[f(mn) = f(m) f(n)\]</span></p><p>则称之为完全可乘函数。</p><p>可乘函数例子： <span class="math inline">\(\mu(n)\)</span>, <span class="math inline">\(d(n)\)</span>. 完全可乘函数例子： <span class="math inline">\(n^{\lambda}\)</span>, <span class="math inline">\(I(n)\)</span>.</p><blockquote><p>显然(完全)可乘函数的的积，倒数(如果有意义的话)都是(完全)可乘函数。</p></blockquote><h3 id="定理-6-可乘函数-fn-有如下性质">定理 6 可乘函数 <span class="math inline">\(f(n)\)</span> 有如下性质</h3><ol type="1"><li><span class="math inline">\(f(1)=1\)</span></li><li><span class="math inline">\(f(n)=f(p_1^{a_1}) f(p_2)^{a_2} \cdots f(p_s)^{a_s}, \quad n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s}\)</span></li><li><span class="math inline">\(f(n)\)</span> 为完全可乘的充要条件是对任意的 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(k \geq 1\)</span> 恒有 <span class="math display">\[ f(p^k) = f ^k (p) \]</span></li><li><span class="math inline">\(f((m,n)[m,n])=f(m)f(n)\)</span></li><li><span class="math inline">\(f\)</span>的逆元必然存在</li><li><span class="math inline">\(f\)</span>的 Möbius 变换也可逆</li></ol><blockquote><p>上述定理的证明是显然的，结论是重要的。</p></blockquote><h3 id="定理七-dirchlet-积-保持可乘性">定理七 Dirchlet 积 保持可乘性</h3><ol type="1"><li>若 <span class="math inline">\(f\)</span> 可乘, <span class="math inline">\(g\)</span> 可乘, 则 <span class="math inline">\(h=f \star g\)</span> 可乘;</li><li>若 <span class="math inline">\(g\)</span> 可乘, <span class="math inline">\(h=f \star g\)</span> 可乘，则 <span class="math inline">\(f\)</span> 可乘.</li></ol><p><strong>Proof</strong>:</p><ol type="1"><li><p>若 <span class="math inline">\(f\)</span> 可乘, <span class="math inline">\(g\)</span> 可乘, 则对任意满足 <span class="math inline">\((m,n)=1\)</span> 的正整数 <span class="math inline">\(m,n\)</span>,对于 <span class="math inline">\(mn\)</span> 的每一个正因子 <span class="math inline">\(d\)</span> 可以分解为 <span class="math inline">\(d=d_1 d_2\)</span> 的形式, 其中 <span class="math inline">\((d_1,d_2)=1, d_1|m, d_2|n\)</span> <span class="math display">\[  h(mn) = \sum_{d|mn} f(d)g(\frac{mn}{d}) = \sum_{d_1|m} f(d_1)g(\frac{m}{d_1}) \sum_{d_2|n} f(d_2)g(\frac{n}{d_2}) = h(m)h(n)\]</span></p></li><li><p>反证，若 <span class="math inline">\(f\)</span> 不可乘，则可以推出<span class="math inline">\(h\)</span>不可乘即可。若 <span class="math inline">\(f\)</span> 不可乘,则必存在 <span class="math inline">\(m,n\)</span>,<span class="math inline">\((m,n)=1\)</span> 但是</p></li></ol><p><span class="math display">\[  f(mn) \neq f(m)f(n)\]</span></p><p>若 <span class="math inline">\(mn=1\)</span> , 则 <span class="math inline">\(f(1) \neq f(1) f(1)\)</span> 知 <span class="math inline">\(f(1) \neq 1\)</span>. 因此 <span class="math inline">\(h(1)=f(1)g(1)=f(1) \neq 1\)</span> 矛盾于 <span class="math inline">\(h\)</span> 可乘。 我们选取满足上述性质的最小正整数 <span class="math inline">\(mn\)</span>,即当 <span class="math inline">\(d_1d_2&lt;mn\)</span> 是恒有 <span class="math display">\[f(d_1d_2) = f(d_1)f(d_2),\quad (d_1,d_2)=1\]</span></p><p>由 <span class="math inline">\(h\)</span> 的定义 <span class="math display">\[\begin{array}{cl}h(mn) = \sum_{d \mid mn} f(d) g(\frac{mn}{d}) &amp;=\sum_{d_1 \mid m} f(d_1) g(\frac{m}{d_1}) \sum_{d_2|m} f(d_2)g(\frac{n}{d_2}) - f(m)f(n) + f(mn) \\&amp;= h(m)h(n) - f(m)f(n) + f(mn) \neq h(m)h(n)\end{array}\]</span></p><p>证毕。</p><blockquote><p>Dirichlet 积一般不保持完全可乘性。</p></blockquote><p>由 <strong>定理 6</strong> 和 <strong>定理 7</strong>，我们有如下推论: 若 <span class="math inline">\(F\)</span> 是 <span class="math inline">\(f\)</span> 的 Möbius 变换，则</p><ol type="1"><li><p><span class="math inline">\(f\)</span> 可乘 <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(F\)</span> 可乘</p></li><li><p><span class="math inline">\(f\)</span> 可乘，则 <span class="math display">\[F(n) = \sum_{d|n} f(d) = \prod_{p^a || n} (1+ f(p)+\cdots f(p^a))\]</span></p></li><li><p><span class="math inline">\(f\)</span> 可乘，则</p></li></ol><p><span class="math display">\[\sum _{d|n} \mu(d) f(d) = \prod _{p | n} (1 - f(p))\]</span></p><blockquote><p>上面 1 是定理 7.1 的直接推论，2 可由定理 6.2 的直接推论，3 是 2 的直接推论。由 3 我们可以得到著名的欧拉公式：</p></blockquote><p><span class="math display">\[\psi(n) = n \sum _{d|n} \frac{\mu(d)}{d} ＝ n \prod _{p|n} (1-\frac{1}{p})\]</span></p><h3 id="完全可乘的逆">完全可乘的逆</h3><p>由于可乘函数满足 <span class="math inline">\(f(1)=1\)</span> 因此可乘函数的逆相对而言更加简单，并且它的逆也是可乘函数。但是计算逆的过程仍然很复杂，但是完全可乘函数的逆却特别简单。</p><h3 id="定理-8-设-f-可乘则-f-完全可乘的充要条件是">定理 8 设 <span class="math inline">\(f\)</span> 可乘，则 <span class="math inline">\(f\)</span> 完全可乘的充要条件是</h3><p><span class="math display">\[f^{-1}(n) = \mu(n)f(n)\]</span></p><h3 id="推广的-möbius-反演公式">推广的 Möbius 反演公式</h3><p>设 <span class="math inline">\(g\)</span> 完全可乘, <span class="math inline">\(h= f \star g\)</span> ,则 <span class="math inline">\(f= h \star \mu g\)</span>，即</p><p><span class="math display">\[h(n) = \sum _{d|n} f(d)g(\frac{n}{d})\quad \Longleftrightarrow \quad f(n) = \sum _{d|n} h(d)\mu(\frac{n}{d})g(\frac{n}{d})\]</span></p><p>另上式中 <span class="math inline">\(g=u\)</span>，上式就变成了 Möbius 反演公式。 由推广的 Möbius 反演公式，我们由</p><p><span class="math display">\[\sum _{i=1} ^n i^{\lambda} = n^{\lambda} \star \psi _{\lambda}\]</span></p><p>可知</p><p><span class="math display">\[\psi_{\lambda}(n) = (\sum _{i=1} ^n i^{\lambda}) \star \mu(n) n^{\lambda}\]</span></p><h2 id="广义-dirichlet-积">广义 Dirichlet 积</h2><p>考虑和式</p><p><span class="math display">\[G(x) = \sum_{n \leq x} f(n)H(\frac{x}{n})\]</span></p><p>其中 <span class="math inline">\(f(n)\)</span> 是数论函数，<span class="math inline">\(H(x)\)</span> 是 <span class="math inline">\((0,\infty)\)</span>上的函数。 我们记 <span class="math inline">\(G = f \circ H\)</span>。特别的若<span class="math inline">\(H(x)\)</span>在所有非整数点取值为<span class="math inline">\(0\)</span>，则此时就是通常的 Dirichlet 积。 我们有以下性质：</p><p><span class="math display">\[f \circ (g \circ H) = (f*g) \circ H\]</span></p><p>若 <span class="math inline">\(G = f \circ H\)</span> 则 <span class="math inline">\(H = f^{-1} \circ G\)</span>。 特别的，若 <span class="math inline">\(G(x) = \sum_{n \leq x} H(\frac{x}{n})\)</span>, 则我们有</p><p><span class="math display">\[H(x) = \sum_{n \leq x} \mu(n) G(\frac{x}{n})\]</span></p><p>几种特殊重要情况：</p><ul><li>仅在整点上取值，普通 Dirichlet 积</li><li><span class="math inline">\(H(x) \equiv 1\)</span>，<span class="math inline">\(G(x)\)</span> 为前缀和</li><li><span class="math inline">\(H(x) = \lfloor x \rfloor\)</span> 向下取整，<span class="math inline">\(G(x) = \sum_{n \leq x} f(n) \lfloor \frac{x}{n} \rfloor\)</span></li></ul><p>注意到 <span class="math inline">\(\sum_{n \leq x} 1 = \lfloor x \rfloor\)</span>，所以 <span class="math inline">\(\lfloor x \rfloor = e \circ 1\)</span> （这给出了恒等于 1 与 向下取整的关系）</p><p>从而我们有直接推论</p><p><span class="math display">\[\sum_{n \leq x} f(n) \lfloor \frac{x}{n} \rfloor = \sum_{n \leq x} (f \star u)(n)\]</span></p><p>特别地，</p><ul><li><span class="math inline">\(\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor = 1\)</span></li><li><span class="math inline">\(\sum_{n \leq x} d(n) = \sum_{n \leq x} \lfloor \frac{x}{n} \rfloor\)</span></li></ul><p>更一般地，若 <span class="math inline">\(h = f \star g\)</span>，</p><p><span class="math display">\[H(x) = \sum_{n \leq x} h(n),\quad F(x) = \sum_{n \leq x} f(n),\quad G(x) = \sum_{n \leq x} g(n)\]</span></p><p>则 <span class="math display">\[H(x) = \sum_{n \leq x} f(n) G(\frac{x}{n})  = \sum_{n \leq x} g(n) F(\frac{x}{n})\]</span></p><p>特别地，取 <span class="math inline">\(g = u\)</span>，设 <span class="math inline">\(F(x) = \sum_{n \leq x} f(n)\)</span> 则</p><p><span class="math display">\[\sum_{n \leq x} F(\frac{x}{n}) = \sum_{n \leq x} (f * u)(n)\]</span></p><p>例如</p><ul><li>取 <span class="math inline">\(f = \phi\)</span> 为 Euler 函数，<span class="math inline">\(\sum_{n \leq x} sumPhi(\frac{x}{n}) = \frac{n(n + 1)}{2}\)</span></li><li>取 <span class="math inline">\(f = \mu\)</span> 为 Möbius 函数，<span class="math inline">\(\sum_{i=1} ^n sumMu(\lfloor \frac{n}{i} \rfloor) = 1\)</span></li></ul><p>最一般的情况是，对任意 <span class="math inline">\(ab = x\)</span> 成立</p><p><span class="math display">\[H(x) = \sum_{n \leq a} f(n) G(\frac{x}{n}) + \sum_{n \leq b} g(n) F(\frac{x}{n}) - F(a)F(b)\]</span></p><blockquote><p>取 <span class="math inline">\(a = 1\)</span> 或者 <span class="math inline">\(b = 1\)</span> 就是刚刚的式子</p></blockquote><p>这个公式一般是用于做估计的。</p><h3 id="一个技巧相当强大的公式-qxsum_n-leq-x-mun显然表示不超过-x-的无平方因子的正整数个数则">一个技巧相当强大的公式 <span class="math inline">\(Q(x)=\sum_{n \leq x} |\mu(n)|\)</span>，显然表示不超过 <span class="math inline">\(x\)</span> 的无平方因子的正整数个数，则</h3><p><span class="math display">\[Q(x) = \frac{6}{\pi^2} x + O(\sqrt{x})\]</span></p><p><strong>Proof</strong> ：显然我们有</p><p><span class="math display">\[\lfloor x \rfloor = \sum_{k \leq \sqrt{x}} Q(\frac{x}{k^2})\]</span></p><p>另一方面</p><p><span class="math display">\[Q(x) = \sum_{n \leq \sqrt{x}} Q(\frac{x}{n^2}) \sum_{d \mid n} \mu(d) =  \sum_{d \leq \sqrt{x}} \mu(d) \sum_{ k \leq \sqrt{\frac{x}{d^2}} } Q(\frac{x}{d^2k^2})\]</span></p><p>所以</p><p><span class="math display">\[\sum_{n \leq x} |\mu(n)| =  Q(x) =  \sum_{d \leq \sqrt{x}} \mu(d) \lfloor \frac{x}{d^2} \rfloor\]</span></p><p>根据上式</p><p><span class="math display">\[Q(x) = x \sum_{d=1}^{\infty} \frac{\mu(d)}{d^2} +O(\sqrt{x}) = \frac{6}{\pi^2} x + O(\sqrt{x})\]</span></p><h3 id="一个优美公式sum-_n1infty-fracmunn2-frac6pi2">一个优美公式：<span class="math inline">\(\sum _{n=1}^{\infty} \frac{\mu(n)}{n^2} = \frac{6}{\pi^2}\)</span></h3><p><strong>Proof</strong>:</p><p><span class="math display">\[\sum _{n=1} ^{\infty} \frac{1}{n^2} \sum_{n=1} ^{\infty} \frac{\mu(n)}{n^2} = \sum_{n=1} ^{\infty} \frac{a_n}{n^2}\]</span></p><p>其中 <span class="math inline">\(a_n = \sum_{d|n} \mu(d) = I(n)\)</span>，又由 <span class="math inline">\(\sum _{n=1} ^{\infty} \frac{1}{n^2} = \frac{\pi^2}{6}\)</span> 结论显然。</p><h2 id="多维广义-dirichlet-积">多维广义 Dirichlet 积</h2><p>为了简洁不妨考虑二维，有两种形式</p><p><span class="math display">\[G(x, y) = \sum_{n \leq \min(x, y)} f(n) H(\frac{x}{n}, \frac{y}{n})\]</span></p><p>此形式可以看作向量版的广义 Dirichlet 积。</p><p><span class="math display">\[G(x, y) = \sum_{i \leq x} \sum_{j \leq y} f(i) g(j)H(\frac{x}{i}, \frac{y}{j})\]</span></p><blockquote><p>这个怎么搞呢？</p></blockquote><p>利用图形可说明的一个公式：</p><p><span class="math display">\[\sum_{i = 1}^n \sum_{j = 1, gcd(i, j) = 1}^m f \left( \min(\lfloor \frac{n}{i} \rfloor, \lfloor \frac{m}{j} \rfloor) \right) = \sum_{i = 1}^n \sum_{j = 1}^m f(\gcd(i, j)) - f(\gcd(i, j) - 1)\]</span></p><p>一般地怎么弄呢？</p><p>设 <span class="math inline">\(F_d(n, m) = \sum_{i = 1}^n \sum_{j = 1, gcd(i, j) = d}^m f \left( \min(\lfloor \frac{n}{i} \rfloor, \lfloor \frac{m}{j} \rfloor) \right)\)</span>，则</p><p><span class="math display">\[\sum_{d = 1}^{\min(n, m)} F_1(\frac{n}{d}, \frac{m}{d}) = \sum_{d = 1}^{\min(n, m)} F_d(n, m) =  \sum_{i = 1}^n \sum_{j = 1}^m f \left( \min(\lfloor \frac{n}{i} \rfloor, \lfloor \frac{m}{j} \rfloor) \right) = G(n, m)\]</span></p><blockquote><p><span class="math inline">\(G(n, m)\)</span> 可以用图形，分情况利用 floorSum 计算，但是还是很慢，这是因为 map 二维记忆化搜索不可避免的慢！一定要避免使用。但是无妨，我们可以反演，得到 <span class="math inline">\(F_1(n, m) = \sum_{d = 1}^{\min(n, m)} \mu(d) G(\frac{n}{d}, \frac{m}{d})\)</span>，依然还是<a href="https://ac.nowcoder.com/acm/contest/view-submission?submissionId=47913393">慢</a>（floorSum 多了一个 log）。</p></blockquote><p>那么最终问题就变成：</p><p><span class="math display">\[\sum_{d = 1}^{\min(n, m)} \mu(d) G(\frac{n}{d}, \frac{m}{d}) = \sum_{d = 1}^{\min(n, m)} \mu(d) \sum_{i = 1}^{\frac{n}{d}} \sum_{j = 1}^{\frac{m}{d}} f \left( \min(\lfloor \frac{n}{id} \rfloor, \lfloor \frac{m}{jd} \rfloor) \right) = \sum_{i = 1}^n \sum_{j = 1}^m f(\gcd(i, j)) - f(\gcd(i, j) - 1)\]</span></p><h2 id="dirichlet-级数">Dirichlet 级数</h2><p><span class="math inline">\(\mathcal{D}_f(s) = \sum_{n = 1}^{\infty} f(n) n^{-s}\)</span></p><p>注意到 <span class="math inline">\(f(n)\)</span> 为恒等时，就是 Riemann-zeta 函数</p><p>一些重要的性质：</p><ul><li><span class="math inline">\(\mathcal{D}_{f \star g} = \mathcal{D}_{f} \mathcal{D}_{g}\)</span></li><li>若 <span class="math inline">\(f\)</span> 可乘，则 <span class="math inline">\(\mathcal{D}_f(s) = \prod_{p \text{ prime}} \sum_{i = 0}^{\infty} f(p^i) p^{-es}\)</span></li><li>若 <span class="math inline">\(f\)</span> 完全可乘，则 <span class="math inline">\(\mathcal{D}_f(s) = \prod_{p \text{ prime}} \frac{1}{1 - \frac{f(p)}{p^s}}\)</span></li></ul><p>素数定理：<span class="math inline">\(\lim_{x \to \infty} \frac{\pi(x)}{x / \ln x} = 1\)</span> 的证明就用到了 Dirichlet 级数。</p><h2 id="应用">应用</h2><h3 id="dn-的一个公式"><span class="math inline">\(d(n)\)</span> 的一个公式</h3><p>按照公式，我们有 <span class="math inline">\(d(n) = \sum_{i \mid n} 1\)</span>。其实这个公式可以推广为</p><p><span class="math display">\[d(n_1 \cdots n_m) = \sum_{i_1 \mid n_1} \cdots \sum_{i_m \mid n_m} 1, \; \gcd(i_s,i_t)=1,1 \leq  s &lt; t \leq m\]</span> <strong>Proof</strong>： 数学归纳法证明：<span class="math inline">\(m=1\)</span> 时结论显然。 设结论对 <span class="math inline">\(m-1\)</span> 成立。 <span class="math display">\[\begin{aligned}d(n_1 \cdots n_m) &amp;= \sum_{i \mid n_1 \cdots n_m} 1 =  \sum_{d \mid n_m} \sum_{i \mid n_1 \cdots n_m , \gcd(i,n_m)=d} 1 \\&amp;= \sum_{d \mid n_m} \sum_{\frac{i}{d} \mid n_1 \cdots n_{m-1} , \gcd(\frac{i}{d},\frac{n_m}{d})=1} 1 \\&amp;= \sum_{d \mid n_m} \sum_{i \mid n_1 \cdots n_{m-1} , \gcd(i,d)=1} 1\end{aligned}\]</span> 由数学归纳法知，原结论成立。</p><h3 id="上面公式的一个应用">上面公式的一个应用</h3><p><span class="math display">\[\sum_{i_1 = 1} ^{n_1} \cdots \sum_{i_m = 1} ^{n_m} d(n_1 \cdots n_m) = \sum_{\gcd(i_s,i_t)=1,1 \leq  s &lt; t \leq m } \lfloor \frac{n_1}{i_1} \rfloor \cdots  \lfloor \frac{n_m}{i_m} \rfloor\]</span></p><h3 id="一道例题codeforce-235">一道例题：<a href="http://codeforces.com/contest/235/problem/E">codeforce 235</a></h3><p>求解: <span class="math display">\[\sum_{i=1}^a \sum_{j=1}^b \sum_{k=1}^c d(ijk)\]</span> 如果令 <span class="math inline">\(f(n) = \sum_{i=1} ^n d(i),g(n)=\sum_{i \mid n} \mu(i) f(\lfloor \frac{c}{i} \rfloor)\)</span> 那么 <span class="math display">\[\sum_{i=1}^a \sum_{j=1}^b \sum_{k=1}^c d(ijk) = \sum_{t} \mu(t) \lfloor \frac{a}{it} \rfloor \lfloor \frac{b}{it} \rfloor g(ijt^2)\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>numberTheory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整除分块</title>
    <link href="/divBlock/"/>
    <url>/divBlock/</url>
    
    <content type="html"><![CDATA[<p>ACMer 考虑算法时总会优先考虑时间复杂度，这里介绍几个优美的根号复杂度的算法（原来这个叫整除分块）</p><span id="more"></span><p>可能需要 <a href="../DirichletProduct">这里的基础知识</a></p><h2 id="sn-sum_i1n-lfloor-fracni-rfloor"><span class="math inline">\(s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor\)</span></h2><p>由于 <span class="math inline">\(\lfloor \frac{n}{i} \rfloor\)</span> 的取值个数不会超过 <span class="math inline">\(2\sqrt{n}\)</span>，所以可能存在 <span class="math inline">\(O(\sqrt{n})\)</span> 的算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">getsum</span><span class="hljs-params">(LL n)</span></span>&#123; <span class="hljs-comment">// The code is simple and easy to understand</span><br>    LL sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>,j;i&lt;=n;i=j+<span class="hljs-number">1</span>)&#123;<br>        j = n/(n/i);<br>        sum += (j-i+<span class="hljs-number">1</span>)*(n/i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>事实上， <span class="math inline">\(s(n)\)</span> 表示图像 <span class="math inline">\(xy=1\)</span> 下方正整点的个数</p></blockquote><h2 id="sigma_kn-sum_dn-dk"><span class="math inline">\(\sigma_k(n) = \sum_{d|n} d^k\)</span></h2><ol type="1"><li><span class="math inline">\(\sigma_0(n)\)</span> 表示正因子个数</li><li><span class="math inline">\(\sigma_1(n)\)</span> 表示正因子之和</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">mypow</span><span class="hljs-params">(LL x,LL n)</span></span>&#123;<br>    LL r = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) r=r*x;<br>        n&gt;&gt;=<span class="hljs-number">1</span>;  x=x*x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">getr</span><span class="hljs-params">(LL n,LL k)</span></span>&#123;<br>    LL r = <span class="hljs-number">0</span>,d;<br>    <span class="hljs-keyword">for</span>(d=<span class="hljs-number">1</span>;d*d&lt;n;++d)&#123;<br>        <span class="hljs-keyword">if</span>(n%d==<span class="hljs-number">0</span>)  r += <span class="hljs-built_in">mypow</span>(d,k) + <span class="hljs-built_in">mypow</span>(n/d,k);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(d*d == n) r+=<span class="hljs-built_in">mypow</span>(d,k);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="f_kn-sum_i1n-sigma_ki"><span class="math inline">\(f_k(n) = \sum_{i=1}^n \sigma_k(i)\)</span></h2><p><span class="math display">\[f_k(n) = \sum_{i=1}^n \sigma_k(n) =\sum_{i=1}^n \sum_{d|i} d^k =\sum_{d=1} d^k \sum_i ^n[d|i] =\sum_{d=1} ^n d^k \lfloor \frac{n}{d} \rfloor\]</span></p><p>如果我们已经得到 <span class="math inline">\(ts[n] = \sum_{i=1}^n i^k\)</span> 类似问题一，我们有以下 C++ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">getf</span><span class="hljs-params">(LL n)</span></span>&#123;<br>    LL sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(LL i=<span class="hljs-number">1</span>,j;i&lt;=n;i=j+<span class="hljs-number">1</span>)&#123;<br>        j = n/(n/i);<br>        sum += (ts[j]-ts[i<span class="hljs-number">-1</span>])*(n/i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上我们有： <span class="math display">\[ts[n] = \left \lbrace\begin{array}{ll}\frac{n(n+1)}{2} &amp; k=1 \\\frac{n(n+1)(2n+1)}{6} &amp; k=2 \\\frac{n^2(n+1)^2}{4} &amp; k=3 \\\end{array} \right.\]</span></p><p>更一般的我们有 <span class="math display">\[1^p+2^p+ \dots + n^p = \sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C_{n+1} ^{k+1}\]</span></p><h2 id="gn-sum_i1npsii"><span class="math inline">\(g(n) = \sum_{i=1}^n\psi(i)\)</span></h2><p>这里 <span class="math inline">\(\psi(n)\)</span> 是欧拉函数表示小于 <span class="math inline">\(n\)</span> 且和 <span class="math inline">\(n\)</span> 互素的数的个数。 Euler's 乘积公式: <span class="math display">\[\psi(n) = n \prod _{p|n}( 1-\frac{1}{p} )\]</span> 我们现在开始计算 <span class="math inline">\(g(n)\)</span> <span class="math display">\[g(n) = \sum_{i=1}^n \psi(i) = \sum_{1 \leq x \leq y \leq n , \gcd(x,y)=1} 1\]</span> 我们定义 <span class="math display">\[g_k(n) = \sum_{1 \leq x \leq y \leq n , \gcd(x,y)=k} 1 = g(\lfloor \frac{n}{k} \rfloor)\]</span> 并且 <span class="math inline">\(\sum_{i=1}^n g_k(i) = \sum_{1 \leq x \leq y \leq n} 1 = \frac{n(n+1)}{2}\)</span> ，于是我们知道 <span class="math display">\[g(n) = \frac{n(n+1)}{2} - \sum_{k=2}^n g(\lfloor \frac{n}{k} \rfloor)\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000006</span>;<br>LL ans[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));<br>    ans[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;ans[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;N&amp;&amp;ans[n]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ans[n];<br>    LL r = n*(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j;i&lt;=n;i=j+<span class="hljs-number">1</span>)&#123;<br>        j = n/(n/i);<br>        r -= (j-i+<span class="hljs-number">1</span>)*<span class="hljs-built_in">getans</span>(n/i);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&lt;N) ans[n]=r;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fn-sum_i1n-sum_j1n-gcdij1"><span class="math inline">\(f(n) = \sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)==1]\)</span></h2><p><span class="math display">\[f(n) = \sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)==1] = \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}  \sum_{d|i,d|j} \mu(d) = \sum_{d=1}^n \mu(d) (\lfloor \frac{n}{d} \rfloor)^2\]</span></p><p>实际上画图可知，<span class="math inline">\(f(n)\)</span> 还有一个表达式：</p><p><span class="math display">\[f(n)= 2 \sum_{i=1}^{n} \phi(i) - 1\]</span></p><p>我们有不妨设 <span class="math inline">\(n \leq m\)</span></p><h2 id="rnmsum_i1n-sum_j1m-fgcdij"><span class="math inline">\(r(n,m)=\sum_{i=1}^n \sum_{j=1}^m f(\gcd(i,j))\)</span></h2><p><span class="math display">\[\begin{aligned} r(n,m) &amp;=\sum_{i=1}^n \sum_{j=1}^m f(gcd(i,j)) \\ &amp;= \sum_{d=1}^n f(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}  \sum_{t|i,t|j} \mu(t) \\ &amp;= \sum_{d=1}^n f(d) \sum_{t=1}^{\lfloor \frac{n}{d} \rfloor} \mu(t) \lfloor \frac{n}{dt} \rfloor \lfloor \frac{m}{dt} \rfloor \\ &amp;= \sum_{G=1}^n \lfloor \frac{n}{G} \rfloor \lfloor \frac{m}{G} \rfloor (f \star \mu)(G)\end{aligned}\]</span></p><p>特别地，<span class="math inline">\(g(n, m) = \sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)==1] = \sum_{d=1}^n \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor \mu(d)\)</span></p><h2 id="problem-hdu5608">Problem hdu5608</h2><p>已知 <span class="math inline">\(n^2 -3n+2 = \sum_{d|n} f(d)\)</span> 计算 <span class="math inline">\(h(n) = \sum_{i=1}^n f(i) \mod 10^9+7\)</span></p><p>由于 <span class="math display">\[\sum_{i=1}^n \sum_{d|i} f(d) = \sum_{i=1}^n f(i) \lfloor \frac{n}{i} \rfloor =  \sum_{i=1}^n h(\lfloor \frac{n}{i} \rfloor)\]</span> 我们知道 <span class="math display">\[\sum_{i=1}^n \sum_{d|i} f(d) = \sum_{i=1}^n i^2-3i+2 = \sum_{i=1}^n (i-1)(i-2) = \frac{n(n-1)(n-2)}{3}\]</span> 所以 <span class="math display">\[h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">1000006</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inv3 = (M+<span class="hljs-number">1</span>)/<span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> ans[N];<br>map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;++i)&#123;<br>        ans[i] = <span class="hljs-built_in">LL</span>(i<span class="hljs-number">-1</span>)*(i<span class="hljs-number">-2</span>)%M;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;N;++i)&#123;  <span class="hljs-comment">// Pretreatment acceleration</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i&lt;&lt;<span class="hljs-number">1</span>;j&lt;N;j+=i)&#123;<br>            ans[j] -= ans[i];<br>            <span class="hljs-keyword">if</span>(ans[j] &lt; <span class="hljs-number">0</span>) ans[j] += M;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;N;++i)&#123;<br>        ans[i] += ans[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(ans[i] &gt; M)  ans[i] -= M;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;N) <span class="hljs-keyword">return</span> ans[n];<br>    map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = mp.<span class="hljs-built_in">find</span>(n); <span class="hljs-comment">//Memory search</span><br>    <span class="hljs-keyword">if</span> (it != mp.<span class="hljs-built_in">end</span>())  <span class="hljs-keyword">return</span> it-&gt;second;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">LL</span>(n)*(n<span class="hljs-number">-1</span>)%M*(n<span class="hljs-number">-2</span>)%M*inv3%M;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>,j;i&lt;=n;i=j+<span class="hljs-number">1</span>)&#123;<br>        j = n/(n/i);<br>        r -= <span class="hljs-built_in">LL</span>(j-i+<span class="hljs-number">1</span>)*<span class="hljs-built_in">getans</span>(n/i)%M;<br>        <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>) r+=M;<br>    &#125;<br>    mp.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(n,r));<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">int</span> T,n;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        cout&lt;&lt;<span class="hljs-built_in">getans</span>(n)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Perron-Frobenius 理论</title>
    <link href="/perronFrobeniusTheory/"/>
    <url>/perronFrobeniusTheory/</url>
    
    <content type="html"><![CDATA[<p>1907 年 O.Perron 发现正矩阵的谱有特别有趣的性质。G.Frobenius 在 1908-1912 年间将 Perron 的工作推广到不可约非负矩阵的情形，并得到了新的进一步结果。Ferron-Frobenius 理论有很多证明方式，下面介绍 H.Wielandt 的优美证明。（一步步的读下去会发现很清晰明了简单）</p><blockquote><p>非负矩阵的谱半径（下面有定义）是它的一个特征值，并且这个特征值对应着非负特征向量。</p></blockquote><span id="more"></span><p>两个矩阵 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 称为置换相似的，若存在一个置换矩阵 <span class="math inline">\(P\)</span> 满足 <span class="math inline">\(P^TXP=Y\)</span>。设<span class="math inline">\(A\in M_n\)</span>.称<span class="math inline">\(A\)</span>为可约的，若 <span class="math inline">\(A\)</span> 置换相似于一个形如 <span class="math inline">\(\left( \begin{matrix} B &amp; 0 \\ C &amp; D \end{matrix} \right)\)</span> 其中 <span class="math inline">\(B,D\)</span> 是方阵，否则称 <span class="math inline">\(A\)</span> 不可约。</p><blockquote><p><span class="math inline">\(X \geq 0\)</span> 表示矩阵的每个元素 <span class="math inline">\(\geq 0\)</span>, （对向量，或者 <span class="math inline">\(&gt;0\)</span> 等情形类似定义即可）。</p><p>以下矩阵除非特别说明都是 <span class="math inline">\(n \times n\)</span> 矩阵 <span class="math inline">\(n&gt;1\)</span></p></blockquote><h2 id="引理-1-设-a-是不可约非负矩阵y_n-且至少有一个分量为-0-则-iay-的正分量的个数大于-y-的正分量个数">引理 1 设 <span class="math inline">\(A\)</span> 是不可约非负矩阵，$y_+^{n}  $ 且至少有一个分量为 0, 则 <span class="math inline">\((I+A)y\)</span> 的正分量的个数大于 <span class="math inline">\(y\)</span> 的正分量个数</h2><p><strong>Proof</strong>： 设 <span class="math inline">\(y\)</span> 恰好有 <span class="math inline">\(k\)</span> 个正分量，<span class="math inline">\(1 \leq k \leq n-1\)</span>。设 <span class="math inline">\(P\)</span> 是置换矩阵，使得<span class="math inline">\(x=Py\)</span>的前<span class="math inline">\(k\)</span>个分量为正，其它为 0，因为 <span class="math inline">\(A\)</span> 是非负矩阵，所以 <span class="math inline">\((I+A)y\)</span>的零分量个数不会超过 <span class="math inline">\(n-k\)</span>。假设这个个数等于 <span class="math inline">\(n-k\)</span>，则有 <span class="math inline">\(y_i = 0 \Rightarrow (Ay)_i = 0\)</span>。即 <span class="math inline">\((PAP^Tx)_i = (PAy)_i = 0,\quad i=k+1,\cdots,n\)</span>，设 <span class="math inline">\(B=PAP^T\)</span>. 则当 <span class="math inline">\(k+1 \leq i \leq n\)</span> 时， <span class="math display">\[(Bx)_i = \sum_{j=1} ^{n} b _{ij} x_j =\sum _{j=1} ^{k} b_{ij} x _j = 0\]</span> 但当 <span class="math inline">\(1 \leq j \leq k\)</span> 时，<span class="math inline">\(x_j &gt;0\)</span>。所以 <span class="math inline">\(b_{ij}=0\)</span>, 其中 <span class="math inline">\(k+1 \leq i \leq n,1 \leq j \leq k\)</span> 矛盾于 <span class="math inline">\(A\)</span> 不可约，证毕。</p><h2 id="引理-2-设-a-是-n-阶不可约非负矩阵y_n-则-ian-1y0">引理 2 设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(n\)</span> 阶不可约非负矩阵，$y_+^{n}  $ 则 <span class="math inline">\((I+A)^{n-1}y&gt;0\)</span></h2><h2 id="引理-3-设-n1则-n-阶非负矩阵-a-不可约当且仅当-ian-10">引理 3 设 <span class="math inline">\(n&gt;1\)</span>，则 <span class="math inline">\(n\)</span> 阶非负矩阵 <span class="math inline">\(A\)</span> 不可约当且仅当 <span class="math inline">\((I+A)^{n-1}&gt;0\)</span></h2><p><strong>Proof</strong>: 应用<strong>引理 2</strong>，考虑 <span class="math inline">\((I+A)^{n-1}e_j\)</span> 即可。</p><p>若 <span class="math inline">\(A\)</span> 不可约，考虑 <span class="math inline">\((I+A)^{n-1}e_j\)</span> 即可知 <span class="math inline">\((I+A)\)</span> 第 <span class="math inline">\(j\)</span> 列每个元素都大于 <span class="math inline">\(0\)</span>。</p><p>若 <span class="math inline">\(A\)</span> 可约，按照定义存在置换矩阵 <span class="math inline">\(P\)</span> 使得 <span class="math inline">\(A = P^{T} \left( \begin{matrix} B &amp; 0 \\ C &amp; D \end{matrix} \right) P\)</span>，从而 <span class="math inline">\((I + A)^{n - 1} = P^{T} \left( \begin{matrix} B + I &amp; 0 \\ C &amp; D + I \end{matrix} \right)^{n - 1} P\)</span>。</p><h2 id="引理-4-一个不可约非负矩阵的非负特征向量是正特征向量">引理 4 一个不可约非负矩阵的非负特征向量是正特征向量</h2><p><strong>Proof</strong>：设 <span class="math inline">\(A\)</span> 是不可约非负矩阵，<span class="math inline">\(Ax=\lambda x, x \geq 0,x \neq 0\)</span>。显然 <span class="math inline">\(\lambda \geq 0\)</span> 我们有 <span class="math inline">\((I+A)x = (1 + \lambda)x\)</span> ，因此<span class="math inline">\((1+A)x\)</span>与<span class="math inline">\(x\)</span>有相同个数的正分量，有 <strong>引理 1</strong> 知 <span class="math inline">\(x&gt;0\)</span>。</p><h2 id="collatz-wielandt-函数">Collatz-Wielandt 函数</h2><p>设 <span class="math inline">\(A\)</span> 是一个非负矩阵。<span class="math inline">\(A\)</span> 的 Collatz－Wielandt 函数 <span class="math inline">\(f_A \colon \mathbf{R}_+ ^n \backslash \lbrace 0 \rbrace \to \mathbf{R}_+\)</span> 定义为： <span class="math display">\[f_A(x) = \min _{ x_i \neq 0 } \frac{(Ax) _i }{x_i}\]</span></p><h2 id="引理-5-设-a-为非负不可约矩阵则">引理 5 设 <span class="math inline">\(A\)</span> 为非负不可约矩阵，则</h2><ol type="1"><li><span class="math inline">\(f_A(tx) = f_A(x), \forall t &gt; 0\)</span></li><li><span class="math inline">\(f_A(x) = \max \lbrace \rho | Ax-\rho x \geq 0 \rbrace\)</span></li><li>设 <span class="math inline">\(x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace\)</span>，记 <span class="math inline">\(y = (I+A)^{n-1} x\)</span> ,则 <span class="math inline">\(f_A(y) \geq f_A(x)\)</span>。</li></ol><p><strong>Proof</strong>：(1),(2)显然。下证明(3)： 我们有<span class="math inline">\(Ax- f_A(x)x \geq 0\)</span>，在等式两边左乘以<span class="math inline">\((I+A)^{n-1}\)</span>并利用<span class="math inline">\(A\)</span>和<span class="math inline">\((I+A)^{n-1}\)</span>乘法可交换的性质，得到<span class="math inline">\(A(I+A)^{n-1}x - f_A(x)(I+A)^{n-1}x \geq 0\)</span> 即 <span class="math inline">\(Ay - f_A(x)y\geq 0\)</span> 再由（2）证毕。</p><blockquote><p>容易证明：<span class="math inline">\(f_A\)</span> 是有界函数，实际上，<span class="math inline">\(f_A\)</span> 非负且不超过 <span class="math inline">\(A\)</span> 的最大行和（考虑每一个 <span class="math inline">\(f_A(e_j)\)</span> 即可)。</p><p>记<span class="math inline">\(\Omega _n = \lbrace x \in \mathbf{R}_+ ^n | \sum _{i=1} ^n = 1 \rbrace\)</span> 引理 5.1 说明，我们只需要在 <span class="math inline">\(\Omega_n\)</span> 上研究 <span class="math inline">\(f_A\)</span> 即可。显然<span class="math inline">\(\Omega_n\)</span>是一个紧集，但是 <span class="math inline">\(f_A\)</span> 可能在 <span class="math inline">\(\Omega_n\)</span> 的边界不连续。</p><p>但是我们仍然有下面 <strong>引理 6</strong>。</p></blockquote><h2 id="引理-6-设-a-是非负不可约矩阵则-f_a-在-_-n-上可以取到最大值">引理 6 设 <span class="math inline">\(A\)</span> 是非负不可约矩阵，则 <span class="math inline">\(f_A\)</span> 在 $_{+} ^n  $上可以取到最大值</h2><p><strong>Proof</strong>: 记<span class="math inline">\(\Delta = (I+A)^{n-1} \Omega _n = \lbrace y \mid y=(I+A)^{n-1} x ,x \in \Omega_n \rbrace\)</span> 则 <span class="math inline">\(\Delta\)</span> 是一个紧集， 且有 <strong>引理 2</strong> 知 <span class="math inline">\(\Delta\)</span> 中向量都是正向量，因此 <span class="math inline">\(f_A\)</span> 在 <span class="math inline">\(\Delta\)</span> 上连续，由 Weierstrass 定理，<span class="math inline">\(f_A\)</span> 在某一点 <span class="math inline">\(y^0 \in \Delta\)</span> 取得 <span class="math inline">\(f_A\)</span> 在 <span class="math inline">\(\Delta\)</span> 上的最大值。记 <span class="math inline">\(z^0 = y^0/ \sum_{i=1} ^n y_i ^0 \in \Omega_ n\)</span>。<span class="math inline">\(\forall x \in \Omega_n\)</span>，记 <span class="math inline">\(y=(I+A)^{n-1}x\)</span> 利用 <strong>引理 5</strong> 可知 <span class="math display">\[f_A(x) \leq f_A(y) \leq f_A(y^0) = f_A(z^0)\]</span> 这就证明了 <span class="math inline">\(f_A\)</span> 在 <span class="math inline">\(z^0\)</span> 上取到它在 <span class="math inline">\(\Omega_n\)</span> 上的最大值。利用对$ z R_+ ^n  $ 和 <strong>引理 6.1</strong> 有 <span class="math display">\[f_A(z) = f_A(\frac{z}{\sum_{i=1}^n z_i}) \leq f_A(z^0)\]</span> 可见 <span class="math inline">\(f_A\)</span> 在 <span class="math inline">\(z^0\)</span> 处取到它在 <span class="math inline">\(R _+ ^n \backslash \lbrace 0 \rbrace\)</span> 上的最大值。</p><h2 id="perron-frobenius-定理">Perron-Frobenius 定理</h2><p><strong>矩阵 <span class="math inline">\(A\)</span> 的谱半径 <span class="math inline">\(\rho(A)\)</span> 定义成矩阵 <span class="math inline">\(A\)</span> 的所有特征值的绝对值的最大值。</strong></p><p>现在万事俱备了，下面开始介绍著名的 Perron-Frobenius 定理</p><h3 id="定理-7perron-frobenius-设a是非负不可约矩阵则下面结论成立">定理 7(Perron-Frobenius) 设<span class="math inline">\(A\)</span>是非负不可约矩阵，则下面结论成立</h3><ol type="1"><li><span class="math inline">\(\rho(A)&gt;0\)</span> 且 <span class="math inline">\(\rho(A)\)</span> 是矩阵 <span class="math inline">\(A\)</span> 的一个单特征值</li><li><span class="math inline">\(A\)</span> 有一个对应于 <span class="math inline">\(\rho(A)\)</span> 的正特征向量</li><li><span class="math inline">\(A\)</span> 的每个非负特征向量都对应于特征值 <span class="math inline">\(\rho(A)\)</span></li></ol><p><strong>Proof</strong>：由 <strong>引理 6</strong> 存在 <span class="math inline">\(x^0 \in R _+ ^n \backslash \lbrace 0 \rbrace\)</span> 满足 <span class="math inline">\(f_A(x^0) \geq f_A(x), \forall x \in \mathbf{R}_+ ^n \backslash \lbrace 0 \rbrace\)</span> 记 <span class="math inline">\(r=f_A(x^0)\)</span>，取 <span class="math inline">\(u=(1,\cdots,1)^T\)</span>。因为 <span class="math inline">\(A\)</span> 不可约，没有零行，所以 <span class="math inline">\(r \geq f_A(u) = \min \sum_{i=1} ^n a_{ij} &gt; 0\)</span></p><p>下面证明 <span class="math inline">\(r\)</span> 是 <span class="math inline">\(A\)</span> 的一个特征值，我们有: <span class="math inline">\(Ax^0 - rx^0 \geq 0\)</span>，假设 <span class="math inline">\(Ax^0 - rx^0 \neq 0\)</span>。由 <strong>引理 5.2</strong> 知 <span class="math inline">\((I+A)^{n-1}(Ax^0 - rx^0) &gt; 0\)</span> 即 <span class="math inline">\(Ay^0 - ry^0&gt; 0\)</span> 其中，<span class="math inline">\(y_0 = (I+A)^{n-1}x^0 &gt;0\)</span>。因此存在 <span class="math inline">\(\epsilon &gt; 0\)</span> 使得 <span class="math inline">\(Ay^0 - (r+\epsilon)y^0&gt; 0\)</span>. 由<strong>引理 5.2</strong>，<span class="math inline">\(f_A(y^0) \geq r+\epsilon &gt; r\)</span> 这就与 <span class="math inline">\(r=f_A(x^0)\)</span> 的最大性矛盾。所以 <span class="math inline">\(Ax^0=rx^0\)</span>。从而<span class="math inline">\(r\)</span>是<span class="math inline">\(A\)</span>的一个特征值，<span class="math inline">\(x^0\)</span> 是 <span class="math inline">\(A\)</span> 的一个特征向量。有 <strong>引理 4</strong> 知，<span class="math inline">\(x^0\)</span> 是正向量。 设 <span class="math inline">\(\lambda\)</span> 是 <span class="math inline">\(A\)</span> 的任何一个特征向量：<span class="math inline">\(Ax=\lambda x\)</span> 则 <span class="math inline">\(|\lambda||x| \leq A|x|\)</span>，于是 <span class="math inline">\(|\lambda| \leq f_ A(|x|) \leq r\)</span> 这表明 <span class="math inline">\(r = \rho(A)\)</span>。</p><blockquote><p>以下关于证明 <span class="math inline">\(\rho(A)\)</span> 是单特征值的部分可以不看</p></blockquote><hr /><p>现证明 <span class="math inline">\(\rho(A)\)</span> 是单特征值，我们先证明 <span class="math inline">\(\rho(A)\)</span> 的几何重数是 1，设 <span class="math inline">\(Ay = \rho(A) y,0 \neq y \in \mathbf{C}^n\)</span> 则 <span class="math inline">\(A|y| \geq \rho(A)|y|\)</span> 上面证明过程表明上式是等式（细品，走一遍没毛病）且 <span class="math inline">\(|y|&gt;0\)</span>。可见 <span class="math inline">\(A\)</span> 的对应于 <span class="math inline">\(\rho(A)\)</span> 的特征向量不含零分量。设 <span class="math inline">\(y\)</span> 和 <span class="math inline">\(z\)</span> 是对应 <span class="math inline">\(\rho(A)\)</span> 的特征向量。则 <span class="math inline">\(|y|&gt;0,|z|&gt;0.z_1 y-y_ 1 z\)</span> 属于 <span class="math inline">\(\rho(A)\)</span> 的特征子空间，但 <span class="math inline">\(z_1 y-y_ 1 z\)</span> 的第一个分量为 0，所以它不可能是 <span class="math inline">\(\rho(A)\)</span> 的特征值，因此，<span class="math inline">\(z_1 y-y_ 1 z＝0\)</span>，<span class="math inline">\(y\)</span> 和 <span class="math inline">\(z\)</span> 线性相关，所以 <span class="math inline">\(\rho(A)\)</span> 的几何重数为 1.</p><p>为了证明 <span class="math inline">\(r=\rho(A)\)</span> 是特征多项式 <span class="math inline">\(\phi(\lambda) = det(\lambda I - A)\)</span> 的单根，只需证明，导数 <span class="math inline">\(\phi&#39;(r) \neq 0\)</span></p><p>用 <span class="math inline">\(adj(X)\)</span> 表示矩阵 <span class="math inline">\(X\)</span> 的 <a href="https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5/10034983?fr=aladdin">伴随矩阵</a>。我们有 <span class="math display">\[\phi&#39;(\lambda) = \sum_{i=1}^n det[(\lambda I - A)(i|i)]=tr[adj(\lambda I - A)]\]</span> &gt; <span class="math inline">\(X(i|j)\)</span> 表示矩阵去掉第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 列所剩下的矩阵</p><p>记 <span class="math inline">\(B(r)=adj(rI-A)\)</span> 则 <span class="math inline">\(\phi&#39;(r) = tr B(r)\)</span> <span class="math display">\[(rI-A)B(r) = det(rI-A)I\]</span> 因为 <span class="math inline">\(r\)</span> 的几何重数为 1，所以 <span class="math inline">\(rank(rI-A)=n-1\)</span>，于是 <span class="math inline">\(B(r) \neq 0\)</span>。设 <span class="math inline">\(b\)</span> 是<span class="math inline">\(B(r)\)</span>的任意一个非零列，则<span class="math inline">\((rI-A)b=0\)</span>,因此 <span class="math inline">\(b\)</span> 是 <span class="math inline">\(A\)</span> 的对应于 <span class="math inline">\(r\)</span> 的特征向量，但是 <span class="math inline">\(A\)</span> 有一个对应于 <span class="math inline">\(r\)</span> 的特征向量 <span class="math inline">\(x^0\)</span>，且因为 <span class="math inline">\(r\)</span> 的几何重数为 1，因此 <span class="math inline">\(b\)</span> 是 <span class="math inline">\(x^0\)</span> 的一个常数倍，从而 <span class="math inline">\(b&gt;0\)</span> 或者 <span class="math inline">\(b&lt;0\)</span>。这就证明了 <span class="math inline">\(B(r)\)</span> 的每一列要么是零列，要么是正向量，要么是负向量。考虑 <span class="math inline">\([B(r)]^T = adj(rI-A^T),r=\rho(A)=\rho(A^T)\)</span>。上面结论应用于 <span class="math inline">\([B(r)]^T\)</span> 的列，所以 <span class="math inline">\(B(r)&gt;0\)</span> 或者 <span class="math inline">\(B(r)&lt;0\)</span>，从而 <span class="math inline">\(\phi&#39;(r)=tr[B(r)] \neq 0\)</span>，这就证明了 <span class="math inline">\(\rho(A)\)</span> 是单特征值。</p><hr /><p>我们已经证明了(1),(2)。现在来证明(3)。设 <span class="math inline">\(y&gt;0\)</span> 是 <span class="math inline">\(A^T\)</span> 对应于 <span class="math inline">\(\rho(A)\)</span> 的特征向量，设 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(A\)</span> 的任意一个非负特征向量：<span class="math inline">\(Ax = \mu x\)</span>。则 <span class="math inline">\(\mu y^T x = y^T Ax = \rho(A)y^Tx\)</span>, 因为 <span class="math inline">\(y^Tx&gt;0\)</span>, 我们有 <span class="math inline">\(\mu = \rho(A)\)</span>，证毕。</p><blockquote><p>由<strong>引理 4</strong>，<span class="math inline">\(A\)</span> 的非负特征向量实际上都是正向量，因此结论 3 可叙述成：在<span class="math inline">\(A\)</span> 的所有特征向量中，只有 <span class="math inline">\(\rho(A)\)</span> 有非负特征向量。上述证明还确定了以下结果：</p></blockquote><h2 id="定理-8.-设-a-是不可约非负矩阵则-rhoa-max-lbrace-f_axxin-mathbfr_-n-backslash-lbrace-0-rbrace-rbrace-0-若-x-_-n-f_ax-a-则x0-是对应于rhoa的一个特征向量">定理 8. 设 <span class="math inline">\(A\)</span> 是不可约非负矩阵，则 <span class="math inline">\(\rho(A) = \max \lbrace f_A(x)|x\in \mathbf{R}_+ ^n \backslash \lbrace 0 \rbrace \rbrace &gt; 0\)</span> , 若$ x  _+ ^n  ,f_A(x) = (A)$ 则<span class="math inline">\(x&gt;0\)</span> 是对应于<span class="math inline">\(\rho(A)\)</span>的一个特征向量</h2><h2 id="定理-9.-设-a-是一个非负矩阵则-rhoa-是-a-的特征值且-a-有一个对应于rhoa的非负特征向量">定理 9. 设 <span class="math inline">\(A\)</span> 是一个非负矩阵，则 <span class="math inline">\(\rho(A)\)</span> 是 <span class="math inline">\(A\)</span> 的特征值，且 <span class="math inline">\(A\)</span> 有一个对应于<span class="math inline">\(\rho(A)\)</span>的非负特征向量</h2><p><strong>Proof</strong>：设<span class="math inline">\(A\)</span>的阶数为<span class="math inline">\(n\)</span>，定理对<span class="math inline">\(n=1\)</span>是平凡地成立。下面设<span class="math inline">\(n=2\)</span>，用<span class="math inline">\(J\)</span>表示元素全为 1 的矩阵。 对于正整数 <span class="math inline">\(k\)</span>，记 <span class="math inline">\(A_k = A + \frac{1}{k} J\)</span> 是一个正矩阵，由 Perron-Frobenius 定理，<span class="math inline">\(A_k\)</span> 在 <span class="math inline">\(\Omega _n = \lbrace x \in \mathbf{R}_+ ^n | \sum _{i=1} ^n = 1 \rbrace\)</span> 中有唯一一个对应于 <span class="math inline">\(\rho(A_k)\)</span> 的特征向量 <span class="math inline">\(x^k\)</span>。</p><p>因为向量序列 <span class="math inline">\(\lbrace x^k \rbrace\)</span> 有界因此，由 Bolzano-Weierstrass 定理,$x^k $ 有收敛子列 <span class="math inline">\(\lbrace x^{k_i} \rbrace: \lim_{i \to \infty } x^{k_i} = x\)</span>。显然 <span class="math inline">\(x \in \Omega_n\)</span> 因此 <span class="math display">\[A _{k_i}x^{k _i} = \rho(A_{k _i}) x^{k_i}\]</span> 注意到当 <span class="math inline">\(i \to \infty\)</span> 时， <span class="math inline">\(A _{k_i} \to A , \rho(A _{k_i}) \to \rho(A)\)</span> 从而得到 <span class="math inline">\(Ax = \rho(A)x\)</span>，证毕。</p><blockquote><p>至此，Prron-Frobenius 定理介绍完毕。下面介绍一个非负矩阵特征值的界。</p></blockquote><h2 id="定理-10-设-a-是非负矩阵则">定理 10 设 <span class="math inline">\(A\)</span> 是非负矩阵，则</h2><p><span class="math display">\[\min_{1 \leq i \leq n} r_i \leq \rho(A) \leq \max_{1 \leq i \leq n} r_i\]</span></p><p><span class="math display">\[\min_{1 \leq i \leq n} c_i \leq \rho(A) \leq \max_{1 \leq i \leq n} c_i\]</span></p><p>其中 <span class="math inline">\(r_i, c_i\)</span> 分别为 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(i\)</span> 行之和以及第 <span class="math inline">\(i\)</span> 列之和。</p><p><strong>Proof</strong>：设 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(A^T\)</span> 的一个 Perron 向量(对应于谱半径的非负特征向量)。因为 <span class="math inline">\(\rho(A^T)=\rho(A)\)</span>， 从而 <span class="math inline">\(A^Tx=\rho(A)x\)</span> 得到 <span class="math display">\[\rho(A)x_i = \sum_{k=1}^n a_{ki}x_k \qquad i = 1,\cdots,n.\]</span> 将这些等式相加得到 <span class="math inline">\(\rho(A) \sum_{i=1}^n x_i =\sum_{k=1}^n r_k x_k\)</span> 即 <span class="math display">\[\rho(A)= \frac{\sum_{k=1}^n r_k x_k }{\sum_{i=1}^n x_i}\]</span> 证毕。</p><h2 id="定理-11wielandt-设a是不可约非负矩阵且b-leq-a-则对于-b-的任何特征值-lambda有">定理 11(Wielandt) 设<span class="math inline">\(A\)</span>是不可约非负矩阵，且<span class="math inline">\(|B| \leq A\)</span> 则对于 <span class="math inline">\(B\)</span> 的任何特征值 <span class="math inline">\(\lambda\)</span>有</h2><p><span class="math display">\[|\lambda| \leq \rho(A)\]</span></p><p><strong>Proof</strong>：设<span class="math inline">\(Bx=\lambda x\)</span> 则 <span class="math inline">\(|B||x| \geq |\lambda||x|\)</span>，但是 <span class="math inline">\(|B| \leq A\)</span>，所以 <span class="math inline">\(|\lambda| |x| \leq |B||x| \leq A |x|\)</span>，由 <strong>引理 5.2</strong> 和 <strong>引理 8</strong> 知 <span class="math display">\[|\lambda| \leq f_A(|x|) \leq \rho(A)\]</span> 证毕。</p><p>根据谱半径的连续性，我们马上有如下推论</p><ol type="1"><li>若矩阵 <span class="math inline">\(A\)</span> 非负，且<span class="math inline">\(|B| \leq A\)</span>，则 <span class="math inline">\(\rho(B) \leq \rho(A)\)</span></li><li>对任意矩阵<span class="math inline">\(A\)</span>，<span class="math inline">\(\rho(A) \leq \rho(|A|)\)</span>.(这个直接证明也可以)</li></ol><blockquote><p>本文源自詹兴致所著的《矩阵论》第六章。</p></blockquote><p>定理虽然很长但是整个过程十分优美，思路十分清晰，仔细分析每一步还是很容易看懂的，并且在证明的过程中就能体会为什么一开始要提出“非负不可约矩阵”的概念了，然后应用连续性把一些结果推广到非负矩阵。</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Schur 定理</title>
    <link href="/schurTheorem/"/>
    <url>/schurTheorem/</url>
    
    <content type="html"><![CDATA[<p>在研究一个数学对象时，我们经常会对它进行分类。比如我们通常把数分为：实数，虚数；实数又分成有理数，无理数；当然也有按照正负来分的。还有整数分成素数（也叫质数）和合数，等等。现在我们谈谈矩阵的分类，以下默认矩阵是方的。</p><span id="more"></span><h2 id="数学中分类一般是按照等价关系划分等价类的">数学中分类一般是按照等价关系划分等价类的</h2><p>所谓等价关系其实就是满足反身性，对称性，传递性的二元关系（总结一下我们等于号的全部性质就知道了） 矩阵中最常见的三种等价关系分别是</p><ol type="1"><li>相抵等价---初等变换</li><li>合同等价---合同变换</li><li>相似等价---相似变换</li></ol><p>相抵等价完全由秩确定，合同变换我们一般只针对实对称矩阵处理。相似变化是我们讨论最多的也是最复杂的，我们总想把复杂的东西变简单，对于一个矩阵我们总想做变换把它变成最简单形式（称为标准型），相抵等价的标准型和对称矩阵合同等价的标准型都十分简单，但是很不幸的也是最幸运的是，并非所有的矩阵都可以相似于对角阵，相似变换标准型称为若尔当标准型，以纪念若尔当对矩阵相似变换所做的贡献。</p><p>然而今天主题并不是上面的任何一种，而是由伟大的数学家 Issai Schur 提出的酉相似，酉变换的概念和相应定理。</p><h2 id="任意复方阵酉相似于上三角矩阵">任意复方阵酉相似于上三角矩阵</h2><h3 id="酉矩阵和酉相似">酉矩阵和酉相似</h3><p>一个矩阵称为酉矩阵，如果它的共轭转置是它的逆。复矩阵 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 称为酉相似的，如果存在酉矩阵 <span class="math inline">\(U\)</span> 使得 <span class="math inline">\(B=U^ \star AU\)</span> ，这里<span class="math inline">\(U^ \star\)</span> 表示 <span class="math inline">\(U\)</span> 的共轭转置。</p><h3 id="定理-1.-对任意复方阵-a存在酉矩阵-u-使得">定理 1. <strong>对任意复方阵 <span class="math inline">\(A\)</span>，存在酉矩阵 <span class="math inline">\(U\)</span> 使得</strong></h3><p><span class="math display">\[A = U \left( \begin{matrix}\lambda_1 &amp; \star &amp; \star &amp; \star \\ &amp; \lambda_2 &amp; \star &amp; \star \\ &amp; &amp; \ddots &amp; \star \\ &amp; &amp; &amp;  \lambda_n\end{matrix} \right)U^\star\]</span></p><p>其中<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n\)</span> 为<span class="math inline">\(A\)</span>的全部特征值。</p><p><strong>Proof</strong>：设 <span class="math inline">\(\alpha_1\)</span> 是<span class="math inline">\(A\)</span>的特征值 <span class="math inline">\(\lambda_1\)</span> 对应的特征向量，将 <span class="math inline">\(\alpha_1\)</span> 扩充为<span class="math inline">\(\mathbf{C}^n\)</span>的一组标准正交基 <span class="math inline">\(P=(\alpha_1,\alpha_2,\cdots,\alpha_n)\)</span> ，则 <span class="math inline">\(A = P \left( \begin{matrix} \lambda_1 &amp; \star \\ \mathbf{0} &amp; B \end{matrix} \right)P^\star\)</span> 。对复矩阵的阶数应用数学归纳法，存在<span class="math inline">\(n-1\)</span> 阶酉矩阵 <span class="math inline">\(Q\)</span> 使得 <span class="math display">\[B = Q \left( \begin{matrix} \lambda_2 &amp; \star &amp; \star  \\ &amp; \ddots &amp; \star \\ &amp; &amp; \lambda_n \end{matrix} \right) Q^ \star\]</span> 因此 <span class="math display">\[A = U \left( \begin{matrix}\lambda_1 &amp; \star &amp; \star &amp; \star \\ &amp; \lambda_2 &amp; \star &amp; \star \\ &amp; &amp; \ddots &amp; \star \\ &amp; &amp; &amp;  \lambda_n\end{matrix} \right)U^\star\]</span> 其中 <span class="math inline">\(U = P \left( \begin{matrix} 1 &amp; \\ &amp; Q \end{matrix} \right)\)</span> 是 <span class="math inline">\(n\)</span> 阶酉矩阵，证毕。</p><h3 id="矩阵酉相似于对角阵当且仅当它是正规矩阵">矩阵酉相似于对角阵当且仅当它是正规矩阵</h3><p>矩阵 <span class="math inline">\(A\)</span> 称为正规矩阵(<strong>normal matrix</strong>)，如果$ A^ A=AA^ $。显然酉矩阵，Hermite 阵，反 Hermite 阵都是正规矩阵。</p><h3 id="定理-2issai-schur矩阵-a-酉相似于对角阵的充分必要条件是-a-是正规矩阵">定理 2（Issai Schur）矩阵 <span class="math inline">\(A\)</span> 酉相似于对角阵的充分必要条件是 <span class="math inline">\(A\)</span> 是正规矩阵</h3><p><strong>Proof</strong>：必要性显然，下证明充分性：</p><p>由定理 1 知，存在酉矩阵 <span class="math inline">\(U\)</span> 使得</p><p><span class="math display">\[A = U \left( \begin{matrix}\lambda_1 &amp; \star &amp; \star &amp; \star \\ &amp; \lambda_2 &amp; \star &amp; \star \\ &amp; &amp; \ddots &amp; \star \\ &amp; &amp; &amp;  \lambda_n\end{matrix} \right)U^\star\]</span></p><p>若 <span class="math inline">\(A\)</span> 是正规矩阵，则有</p>$$ (<span class="math display">\[\begin{matrix}\overline{\lambda_1} &amp;  &amp;  &amp;  \\\star &amp; \overline{\lambda_2} &amp;  &amp;  \\\star &amp; \star &amp; \ddots &amp; \\\star &amp; \star &amp; \star &amp;  \overline{\lambda_n}\end{matrix}\]</span>)  (<span class="math display">\[\begin{matrix}\lambda_1 &amp; \star &amp; \star &amp; \star \\ &amp; \lambda_2 &amp; \star &amp; \star \\ &amp; &amp; \ddots &amp; \star \\ &amp; &amp; &amp;  \lambda_n\end{matrix}\]</span><h1 id="section">)</h1>(<span class="math display">\[\begin{matrix}\lambda_1 &amp; \star &amp; \star &amp; \star \\ &amp; \lambda_2 &amp; \star &amp; \star \\ &amp; &amp; \ddots &amp; \star \\ &amp; &amp; &amp;  \lambda_n\end{matrix}\]</span>) (<span class="math display">\[\begin{matrix}\overline{\lambda_1} &amp;  &amp;  &amp;  \\\star &amp; \overline{\lambda_2} &amp;  &amp;  \\\star &amp; \star &amp; \ddots &amp; \\\star &amp; \star &amp; \star &amp;  \overline{\lambda_n}\end{matrix}\]</span>) <span class="math display">\[考虑矩阵两端$(1,1)$位置得到:\]</span> _1 ＝ _1 +^2 <span class="math display">\[其中$ \sigma^2 $是上三角矩阵\]</span> (<span class="math display">\[\begin{matrix}\lambda_1 &amp; \star &amp; \star &amp; \star \\ &amp; \lambda_2 &amp; \star &amp; \star \\ &amp; &amp; \ddots &amp; \star \\ &amp; &amp; &amp;  \lambda_n\end{matrix}\]</span><p>) $$ 的第一行的非对角元绝对值之平方和，因此由 <span class="math inline">\(\sigma^2\)</span> 可知上三角矩阵的第一行非对角元全为 0，类似的考察矩阵两端 <span class="math inline">\((2,2)\)</span> 的位置，一直到 <span class="math inline">\((n,n)\)</span> 的位置即可知道上面矩阵是对角阵，证毕。</p><p>上述定理给出了酉相似于对角型的充分必要条件，而且条件十分易于判断。整个过程简洁优美。另外由于酉矩阵条件数恒定为 1，有其数值稳定性，因此经常用于实际计算中，例如 QR 方法涉及的两个矩阵变换 Househoulder 变换和 Givens 变换都是酉变换。</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cayley-Hamilton 定理</title>
    <link href="/cayleyHamiltonTheorem/"/>
    <url>/cayleyHamiltonTheorem/</url>
    
    <content type="html"><![CDATA[<p>大一学了矩阵之后，一直很喜欢它，因为它形式简洁优美，又不缺乏技巧，是抽象和具体的桥梁，又有其实用性，成为现代数学最基础的工具之一。个人认为，矩阵中最优美的定理非 Cayley-Hamilton 定理（矩阵的特征多项式是它的一个化零多项式）莫属了。</p><blockquote><p>交换环上的矩阵都有 Cayley-Hamilton 定理成立</p></blockquote><span id="more"></span><p>详细表述和证明如下： <span class="math display">\[\phi(\lambda)=det(\lambda I - A) = a_n \lambda^n + \cdots + a_1 \lambda + a_0\]</span> 设<span class="math inline">\(\lambda I - A\)</span>的 <a href="https://baike.baidu.com/item/%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5/10034983?fr=aladdin">伴随矩阵</a> 为 <span class="math inline">\(B\)</span>，则<span class="math inline">\(B\)</span>中元素为关于 <span class="math inline">\(\lambda\)</span> 的次数小于 <span class="math inline">\(n\)</span> 的多项式，不妨设 <span class="math display">\[B = \lambda^{n-1} B_ {n-1} + \cdots + \lambda B_1 + B_0\]</span> 所以 $$ (I - A)B = ^n B_{n-1} + ^{n-1} (B_ {n-2} - AB_ {n-1})</p><ul><li>+ (B_0 - AB_1) - AB_0 $$ 又因为 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 的伴随矩阵，我们有 <span class="math inline">\((\lambda I - A)B = det(\lambda I - A) I\)</span></li></ul><p>比较系数得到： <span class="math display">\[\left\{\begin{array}{l}B_{n-1} = a_n I \\B_{n-2} - AB_ {n-1} = a_{n-1} I \\\cdots \\B_0 - AB_1 = a_1 I \\-AB_0 = a_0 I\end{array} \right.\]</span> 对上式分别左乘$ A<sup>n,A</sup>{n-1},,A,I$得到： <span class="math display">\[\left\{\begin{array}{l}A^n B_{n-1} = a_n A^n \\A^{n-1} B_{n-2} - A^n B_ {n-1} = a_{n-1} A^{n-1} \\\cdots \\A B_0 - A^2 B_1 = a_1 A \\-AB_0 = a_0 I\end{array} \right.\]</span> 再将上式相加得到最终结果 <span class="math display">\[\phi(A)= a_n A^n + a_{n-1} A^{n-1} + \cdots + a_1 A +a_0 I = \mathbf{0}\]</span> 上述定理优美在于从形式上，<span class="math inline">\(\phi(\lambda)=det(\lambda I - A)\)</span> 取 <span class="math inline">\(\lambda = A\)</span> 带入恰好也是 0（注意数字 0 和零矩阵的差别）<strong>虽然说这样做是完全没有道理</strong>。作为直接推论我们知道，一个 <span class="math inline">\(n\)</span> 阶方阵的任何次方都可以被它的不超过 <span class="math inline">\(n\)</span> 次的幂线性表出。</p><h2 id="非交换环可逆矩阵的转置不一定可逆">非交换环可逆矩阵的转置不一定可逆</h2><p>非交换环 <span class="math inline">\(R\)</span> 上的方阵 <span class="math inline">\(A\)</span> 可逆，它的转置不一定可逆。例如 <span class="math inline">\(R\)</span> 是除环，<span class="math inline">\(ab \neq ba\)</span>，则 <span class="math inline">\(\begin{pmatrix} 1 &amp; a \\ b ab \end{pmatrix}\)</span> 可逆（待定系数即可求出逆元），但是 <span class="math inline">\(\begin{pmatrix} 1 &amp; b \\ a ab \end{pmatrix}\)</span> 不可逆（可以简单的找到零因子），而这个性质满足当且仅当 <span class="math inline">\(R/rad(R)\)</span> 是交换的(Lam)。一个更为直观的例子：<span class="math inline">\(M_2(M_2(k))\)</span> 中四个只有分别只有一个位置非 0 且为 1 的矩阵转置就不是可逆的啦。当然了非交换环中一维的转置必然满足，上/下三角的为何满足呢？这是因为上/下三角方阵可逆当且仅当对角元素都可逆。</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>仅在一点连续的函数例子</title>
    <link href="/exampleOfFunctionOnlyContinueAtOnePoint/"/>
    <url>/exampleOfFunctionOnlyContinueAtOnePoint/</url>
    
    <content type="html"><![CDATA[<p>在一元微积分中，有一个广为人知的结论：一元函数在一点可导，必在该点连续，即可导必连续。那么自然会有这样一个问题：</p><blockquote><p>一元函数在一点可导能否推出它在该点的一个小邻域连续呢？</p></blockquote><span id="more"></span><p>这个想法是很自然的，不严格的思考可能会认为应该是对的,但是它并不成立。下面给出一个反例： <span class="math display">\[f(x) = x^2 D(x) = \left\{\begin{array}{ll}x^2 &amp; x \in \mathbb{Q} \\0 &amp; x \notin \mathbb{Q}\end{array} \right.\]</span> 其中 <span class="math inline">\(D(x)\)</span> 为 Dirichlet 函数。</p><p>容易验证函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x=0\)</span> 处可导，但在 <span class="math inline">\(x \neq 0\)</span> 处不连续，从而否定了上述问题。</p><p>最后，类似地，我们还可以通过 Dirichlet 函数构造 <span class="math inline">\(\mathbb{R}\)</span> 上一些仅在有限个点连续的函数。也可以通过周期函数构造仅在所有整数点连续的函数。但是由 Baire 纲定理可以证明，不存在在所有有理数点连续，无理点间断的函数。最后 Riemann 函数给出了一个在所有有理数点间断，无理点连续的函数。这些反例使得人们对函数连续的概念有了更感性的认识。</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用方法</title>
    <link href="/readme/"/>
    <url>/readme/</url>
    
    <content type="html"><![CDATA[<p>本博客基于 <a href="https://hexo.io/">hexo</a> 框架 + <a href="https://hexo.fluid-dev.com/docs">fuild</a> 主题 + <a href="https://twikoo.js.org/">twikoo</a> 评论，双线部署（国内部署在 <a href="https://cloud.tencent.com/document/product/876/47006">腾讯云</a>，国外部署在 <a href="https://github.com/izlyforever">github</a>）</p><p>本博客记录着一些 有趣有用优雅的数学，算法问题，以及一些日记。</p><p>写作的时候能理清很多问题，如果还能帮助到别人就更好了。</p><blockquote><p>如果你发现任何问题，欢迎评论，email，github 留言</p></blockquote><span id="more"></span><h2 id="使用方法">使用方法</h2><ul><li>右上角可以调节 明/暗 主题</li><li>右上角搜索可以全局本地搜索</li><li>通过归档查看全部博文列表</li><li>可以通过 tags 快速定位到 数学，算法，cpp，python 等内容</li><li>网页工具还是有很多有意思的东西的</li><li>所有算法及其模版放在：<a href="https://github.com/izlyforever/cpplibforCP">cpplibforCP 仓库</a>，提交记录和题解放在 <a href="https://github.com/izlyforever/cf">cf 仓库</a>（欢迎 star）</li></ul><h2 id="一些注记">一些注记</h2><ul><li>全站 https</li><li>本域名：<code>izlyforever.com</code> 已经实名制</li><li>mkdocs 是一个不错的 文档生成器，但是博客还是 hexo 更好一点</li><li>hexo 是基于 markdown 的，尽量不要过多利用 hexo 特有，而 markdown 没有的东西</li><li>用 <code>**</code> 而非 <code>__</code> 强调</li><li>都 2021 年了 hexo 还是有 mathjax 问题</li></ul><h3 id="mathjax-解决方案">mathjax 解决方案</h3><p>卸载 <code>marked</code> 改用 <code>kmarked</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-kramed --save<br></code></pre></td></tr></table></figure><p>然后修改 <code>node_modules\kramed\lib\rules\inline.js</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br>  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,<br><span class="hljs-comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br>  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,<br></code></pre></td></tr></table></figure><p>详细<a href="https://www.jianshu.com/p/7ab21c7f0674">解决方案</a></p><h2 id="博客历史">博客历史</h2><p>2015 年 12 月 15 号，开始基于 github page + hexo + next 写数学博客</p><p>当时想做一个 GUI 界面的计算器，然后发现逻辑上并不简单，后来知道是用著名的 <strong>逆波兰式</strong> 解决，于是写了第一篇博客：计算器程序。后来陆续写了很多数学相关的短篇博客，记录着 <strong>数学和程序的点滴</strong></p><p>2017 年 5 月 27 号就断更了。主要是因为电脑坏了，当时没有使用 git 备份源码，然后就没法更新</p><p>2020 年 2 月，疫情开始了，在家闲着没事干，根据网站的内容结合一些工具，重新搞了一遍源码</p><p>2020 年 2 月 16 号，刚开始学习 python，然后更新了 三个月 与 python 有关的东西</p><p>2020 年，把前几年想写的东西也写了进去，数学相关的内容，还有重新学了 C++17，开始打 codeforces，开始全面回归博客，并且用知乎来引流（其实没必要）</p><p>2020 年，折腾了很多主题，后来选择了 butterfly，用了一年的 butterfly</p><p>2021 年，发生了很多大事，用了一段时间 mkdocs（写文档确实很实用），后来不想折腾了转战 cnblog，但是由于更新实在麻烦，最后回归 hexo，然后用 fuild 作为主题</p><p>2021 年 11 月 2 号，cf repo 删除了所有中文信息</p><p>2021 年 11 月 12 号，cf repo 删除了所有非必要 fropen</p><p>2022 年 2 月 2 号，更新了 Nodejs、Hexo，使用 Hide 功能（fluid 主题自带）隐藏一些水的。</p><p>2022 年 5 月 16 号，做了一次大规模调整</p><h2 id="不在主页显示的博文">不在主页显示的博文</h2><p>把一些很水的，没啥意思的以及一些加密的隐藏了</p><h3 id="私密">私密</h3><ul><li><a href="../AgoraAlgorithmNotes">Agora ThunderTalks 笔记</a></li><li><a href="../workRecord">工作记录</a></li><li><a href="../DME">The Dixmier-Moeglin Equivalence</a></li><li><a href="../primeInOperatorRing"><span class="math inline">\(R, R[x; \delta]\)</span> 的素理想关系及 Baire 空间</a></li><li><a href="../primeInPolyRing"><span class="math inline">\(R, R[x; \sigma], R[x^{\pm}; \sigma]\)</span> 的素理想关系</a></li><li><a href="../mixed">杂记</a></li><li><a href="../loveMemory">恋爱日记</a></li><li><a href="../toDo">ToDo</a></li><li><a href="../words">私密警句</a></li></ul><h3 id="学习系列">学习系列</h3><ul><li><a href="../learnASM">汇编</a></li><li><a href="../learnANSIC">ANSI C</a></li><li><a href="../learnCpp">C++</a></li><li><a href="../learnOCSWIFT">OC、SWIFT</a></li><li><a href="../learnPython">Python</a></li><li><a href="../learnHaskell">Haskell</a></li><li><a href="../thread">多线程编程</a></li><li><a href="https://izlyforever.com/algebraicNumberTheory/">代数数论笔记</a></li></ul><h3 id="水">水</h3><ul><li><a href="../spookywooky">Talk with spookywooky</a></li><li><a href="../workLatex">Latex 编辑的一些文档</a></li><li><a href="../sageMath">上流开源免费数学软件之 SageMath</a></li><li><a href="../typeStyle">书写风格</a></li></ul><h3 id="有待完善">有待完善</h3><ul><li><a href="../readAfterWork">工作后的读书笔记</a></li><li><a href="../preload">预加载（狸猫换太子技术）</a></li><li><a href="../bigInt">大整数 cpp 版</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
